/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/admin.js":
/*!*******************************!*\
  !*** ./resources/js/admin.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! filepond */ \"./node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond-plugin-file-validate-type */ \"./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\");\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! filepond-plugin-image-preview */ \"./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js\");\n/* harmony import */ var filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! filepond-plugin-file-validate-size */ \"./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\");\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var livewire_sortable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! livewire-sortable */ \"./node_modules/livewire-sortable/dist/livewire-sortable.js\");\n/* harmony import */ var livewire_sortable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(livewire_sortable__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nwindow.FilePond = filepond__WEBPACK_IMPORTED_MODULE_0__;\nwindow.FilePondPluginFileValidateType = (filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_1___default());\nwindow.FilePondPluginImagePreview = (filepond_plugin_image_preview__WEBPACK_IMPORTED_MODULE_2___default());\nwindow.FilePondPluginFileValidateSize = (filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default());\n// window.LivewireSortable = livewireSortable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYWRtaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUM7QUFDMkM7QUFDVDtBQUNTO0FBQ3JEO0FBRTNCSSxNQUFNLENBQUNKLFFBQVEsR0FBR0EscUNBQVE7QUFDMUJJLE1BQU0sQ0FBQ0gsOEJBQThCLEdBQUdBLDJFQUE4QjtBQUN0RUcsTUFBTSxDQUFDRiwwQkFBMEIsR0FBR0Esc0VBQTBCO0FBQzlERSxNQUFNLENBQUNELDhCQUE4QixHQUFHQSwyRUFBOEI7QUFDdEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4uanM/OTI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGaWxlUG9uZCBmcm9tICdmaWxlcG9uZCc7XG5pbXBvcnQgRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUnO1xuaW1wb3J0IEZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3IGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3JztcbmltcG9ydCBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgZnJvbSAnZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZSc7XG5pbXBvcnQgJ2xpdmV3aXJlLXNvcnRhYmxlJztcblxud2luZG93LkZpbGVQb25kID0gRmlsZVBvbmQ7XG53aW5kb3cuRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlID0gRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlO1xud2luZG93LkZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3ID0gRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXc7XG53aW5kb3cuRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplID0gRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplO1xuLy8gd2luZG93LkxpdmV3aXJlU29ydGFibGUgPSBsaXZld2lyZVNvcnRhYmxlO1xuIl0sIm5hbWVzIjpbIkZpbGVQb25kIiwiRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIiwiRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXciLCJGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/admin.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js ***!
  \****************************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileValidateSize 2.2.8\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? (module.exports = factory())\n        : 0;\n})(this, function() {\n    'use strict';\n\n    var plugin = function plugin(_ref) {\n        var addFilter = _ref.addFilter,\n            utils = _ref.utils;\n        // get quick reference to Type utils\n        var Type = utils.Type,\n            replaceInString = utils.replaceInString,\n            toNaturalFileSize = utils.toNaturalFileSize;\n\n        // filtering if an item is allowed in hopper\n        addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n            var query = _ref2.query;\n            if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n                return true;\n            }\n\n            var sizeMax = query('GET_MAX_FILE_SIZE');\n            if (sizeMax !== null && file.size > sizeMax) {\n                return false;\n            }\n\n            var sizeMin = query('GET_MIN_FILE_SIZE');\n            if (sizeMin !== null && file.size < sizeMin) {\n                return false;\n            }\n\n            return true;\n        });\n\n        // called for each file that is loaded\n        // right before it is set to the item state\n        // should return a promise\n        addFilter('LOAD_FILE', function(file, _ref3) {\n            var query = _ref3.query;\n            return new Promise(function(resolve, reject) {\n                // if not allowed, all fine, exit\n                if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n                    return resolve(file);\n                }\n\n                // check if file should be filtered\n                var fileFilter = query('GET_FILE_VALIDATE_SIZE_FILTER');\n                if (fileFilter && !fileFilter(file)) {\n                    return resolve(file);\n                }\n\n                // reject or resolve based on file size\n                var sizeMax = query('GET_MAX_FILE_SIZE');\n                if (sizeMax !== null && file.size > sizeMax) {\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_MAX_FILE_SIZE_EXCEEDED'),\n                            sub: replaceInString(query('GET_LABEL_MAX_FILE_SIZE'), {\n                                filesize: toNaturalFileSize(\n                                    sizeMax,\n                                    '.',\n                                    query('GET_FILE_SIZE_BASE'),\n                                    query('GET_FILE_SIZE_LABELS', query)\n                                ),\n                            }),\n                        },\n                    });\n\n                    return;\n                }\n\n                // reject or resolve based on file size\n                var sizeMin = query('GET_MIN_FILE_SIZE');\n                if (sizeMin !== null && file.size < sizeMin) {\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_MIN_FILE_SIZE_EXCEEDED'),\n                            sub: replaceInString(query('GET_LABEL_MIN_FILE_SIZE'), {\n                                filesize: toNaturalFileSize(\n                                    sizeMin,\n                                    '.',\n                                    query('GET_FILE_SIZE_BASE'),\n                                    query('GET_FILE_SIZE_LABELS', query)\n                                ),\n                            }),\n                        },\n                    });\n\n                    return;\n                }\n\n                // returns the current option value\n                var totalSizeMax = query('GET_MAX_TOTAL_FILE_SIZE');\n                if (totalSizeMax !== null) {\n                    // get the current total file size\n                    var currentTotalSize = query('GET_ACTIVE_ITEMS').reduce(function(total, item) {\n                        return total + item.fileSize;\n                    }, 0);\n\n                    // get the size of the new file\n                    if (currentTotalSize > totalSizeMax) {\n                        reject({\n                            status: {\n                                main: query('GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED'),\n                                sub: replaceInString(query('GET_LABEL_MAX_TOTAL_FILE_SIZE'), {\n                                    filesize: toNaturalFileSize(\n                                        totalSizeMax,\n                                        '.',\n                                        query('GET_FILE_SIZE_BASE'),\n                                        query('GET_FILE_SIZE_LABELS', query)\n                                    ),\n                                }),\n                            },\n                        });\n\n                        return;\n                    }\n                }\n\n                // file is fine, let's pass it back\n                resolve(file);\n            });\n        });\n\n        return {\n            options: {\n                // Enable or disable file type validation\n                allowFileSizeValidation: [true, Type.BOOLEAN],\n\n                // Max individual file size in bytes\n                maxFileSize: [null, Type.INT],\n\n                // Min individual file size in bytes\n                minFileSize: [null, Type.INT],\n\n                // Max total file size in bytes\n                maxTotalFileSize: [null, Type.INT],\n\n                // Filter the files that need to be validated for size\n                fileValidateSizeFilter: [null, Type.FUNCTION],\n\n                // error labels\n                labelMinFileSizeExceeded: ['File is too small', Type.STRING],\n                labelMinFileSize: ['Minimum file size is {filesize}', Type.STRING],\n\n                labelMaxFileSizeExceeded: ['File is too large', Type.STRING],\n                labelMaxFileSize: ['Maximum file size is {filesize}', Type.STRING],\n\n                labelMaxTotalFileSizeExceeded: ['Maximum total size exceeded', Type.STRING],\n                labelMaxTotalFileSize: ['Maximum total file size is {filesize}', Type.STRING],\n            },\n        };\n    };\n\n    // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n    var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    if (isBrowser) {\n        document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n    }\n\n    return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEU7QUFDQSxVQUFVLENBRWdGO0FBQzFGLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7O0FBRW5FO0FBQ0EsMERBQTBELFNBQVM7O0FBRW5FO0FBQ0EscUVBQXFFLFNBQVM7QUFDOUUsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdCQUFnQjtBQUMxRjs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanM/ZGEyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlU2l6ZSAyLjIuOFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgICAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCAoZ2xvYmFsLkZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlU2l6ZSA9IGZhY3RvcnkoKSkpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgICAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICAgICAgLy8gZ2V0IHF1aWNrIHJlZmVyZW5jZSB0byBUeXBlIHV0aWxzXG4gICAgICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgICAgICAgIHJlcGxhY2VJblN0cmluZyA9IHV0aWxzLnJlcGxhY2VJblN0cmluZyxcbiAgICAgICAgICAgIHRvTmF0dXJhbEZpbGVTaXplID0gdXRpbHMudG9OYXR1cmFsRmlsZVNpemU7XG5cbiAgICAgICAgLy8gZmlsdGVyaW5nIGlmIGFuIGl0ZW0gaXMgYWxsb3dlZCBpbiBob3BwZXJcbiAgICAgICAgYWRkRmlsdGVyKCdBTExPV19IT1BQRVJfSVRFTScsIGZ1bmN0aW9uKGZpbGUsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmMi5xdWVyeTtcbiAgICAgICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1NJWkVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgICAgICBpZiAoc2l6ZU1heCAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPiBzaXplTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2l6ZU1pbiA9IHF1ZXJ5KCdHRVRfTUlOX0ZJTEVfU0laRScpO1xuICAgICAgICAgICAgaWYgKHNpemVNaW4gIT09IG51bGwgJiYgZmlsZS5zaXplIDwgc2l6ZU1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGxlZCBmb3IgZWFjaCBmaWxlIHRoYXQgaXMgbG9hZGVkXG4gICAgICAgIC8vIHJpZ2h0IGJlZm9yZSBpdCBpcyBzZXQgdG8gdGhlIGl0ZW0gc3RhdGVcbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgYWRkRmlsdGVyKCdMT0FEX0ZJTEUnLCBmdW5jdGlvbihmaWxlLCBfcmVmMykge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQsIGFsbCBmaW5lLCBleGl0XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfU0laRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZmlsZSBzaG91bGQgYmUgZmlsdGVyZWRcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUZpbHRlciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9TSVpFX0ZJTFRFUicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlRmlsdGVyICYmICFmaWxlRmlsdGVyKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICAgICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVNYXggIT09IG51bGwgJiYgZmlsZS5zaXplID4gc2l6ZU1heCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9NQVhfRklMRV9TSVpFX0VYQ0VFREVEJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NQVhfRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZU1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRklMRV9TSVpFX0xBQkVMUycsIHF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICAgICAgICAgIHZhciBzaXplTWluID0gcXVlcnkoJ0dFVF9NSU5fRklMRV9TSVpFJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVNaW4gIT09IG51bGwgJiYgZmlsZS5zaXplIDwgc2l6ZU1pbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9NSU5fRklMRV9TSVpFX0VYQ0VFREVEJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NSU5fRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZU1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRklMRV9TSVpFX0xBQkVMUycsIHF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIGN1cnJlbnQgb3B0aW9uIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsU2l6ZU1heCA9IHF1ZXJ5KCdHRVRfTUFYX1RPVEFMX0ZJTEVfU0laRScpO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbFNpemVNYXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHRvdGFsIGZpbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRvdGFsU2l6ZSA9IHF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKyBpdGVtLmZpbGVTaXplO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNpemUgb2YgdGhlIG5ldyBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG90YWxTaXplID4gdG90YWxTaXplTWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9UT1RBTF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NQVhfVE9UQUxfRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzaXplOiB0b05hdHVyYWxGaWxlU2l6ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemVNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfU0laRV9MQUJFTFMnLCBxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsZSBpcyBmaW5lLCBsZXQncyBwYXNzIGl0IGJhY2tcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBhbGxvd0ZpbGVTaXplVmFsaWRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgICAgICAgICAvLyBNYXggaW5kaXZpZHVhbCBmaWxlIHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAgICAgICAgIC8vIE1pbiBpbmRpdmlkdWFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICAgICAgICAgIG1pbkZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgICAgICAgICAgLy8gTWF4IHRvdGFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICAgICAgICAgIG1heFRvdGFsRmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGZpbGVzIHRoYXQgbmVlZCB0byBiZSB2YWxpZGF0ZWQgZm9yIHNpemVcbiAgICAgICAgICAgICAgICBmaWxlVmFsaWRhdGVTaXplRmlsdGVyOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciBsYWJlbHNcbiAgICAgICAgICAgICAgICBsYWJlbE1pbkZpbGVTaXplRXhjZWVkZWQ6IFsnRmlsZSBpcyB0b28gc21hbGwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgICAgICAgICAgbGFiZWxNaW5GaWxlU2l6ZTogWydNaW5pbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgICAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZUV4Y2VlZGVkOiBbJ0ZpbGUgaXMgdG9vIGxhcmdlJywgVHlwZS5TVFJJTkddLFxuICAgICAgICAgICAgICAgIGxhYmVsTWF4RmlsZVNpemU6IFsnTWF4aW11bSBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAgICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiBbJ01heGltdW0gdG90YWwgc2l6ZSBleGNlZWRlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6IFsnTWF4aW11bSB0b3RhbCBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js ***!
  \****************************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginFileValidateType 1.2.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? (module.exports = factory())\n        : 0;\n})(this, function() {\n    'use strict';\n\n    var plugin = function plugin(_ref) {\n        var addFilter = _ref.addFilter,\n            utils = _ref.utils;\n        // get quick reference to Type utils\n        var Type = utils.Type,\n            isString = utils.isString,\n            replaceInString = utils.replaceInString,\n            guesstimateMimeType = utils.guesstimateMimeType,\n            getExtensionFromFilename = utils.getExtensionFromFilename,\n            getFilenameFromURL = utils.getFilenameFromURL;\n\n        var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(mimeType, wildcard) {\n            var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n            var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n            return mimeTypeGroup === wildcardGroup;\n        };\n\n        var isValidMimeType = function isValidMimeType(acceptedTypes, userInputType) {\n            return acceptedTypes.some(function(acceptedType) {\n                // accepted is wildcard mime type\n                if (/\\*$/.test(acceptedType)) {\n                    return mimeTypeMatchesWildCard(userInputType, acceptedType);\n                }\n\n                // is normal mime type\n                return acceptedType === userInputType;\n            });\n        };\n\n        var getItemType = function getItemType(item) {\n            // if the item is a url we guess the mime type by the extension\n            var type = '';\n            if (isString(item)) {\n                var filename = getFilenameFromURL(item);\n                var extension = getExtensionFromFilename(filename);\n                if (extension) {\n                    type = guesstimateMimeType(extension);\n                }\n            } else {\n                type = item.type;\n            }\n\n            return type;\n        };\n\n        var validateFile = function validateFile(item, acceptedFileTypes, typeDetector) {\n            // no types defined, everything is allowed \\o/\n            if (acceptedFileTypes.length === 0) {\n                return true;\n            }\n\n            // gets the item type\n            var type = getItemType(item);\n\n            // no type detector, test now\n            if (!typeDetector) {\n                return isValidMimeType(acceptedFileTypes, type);\n            }\n\n            // use type detector\n            return new Promise(function(resolve, reject) {\n                typeDetector(item, type)\n                    .then(function(detectedType) {\n                        if (isValidMimeType(acceptedFileTypes, detectedType)) {\n                            resolve();\n                        } else {\n                            reject();\n                        }\n                    })\n                    .catch(reject);\n            });\n        };\n\n        var applyMimeTypeMap = function applyMimeTypeMap(map) {\n            return function(acceptedFileType) {\n                return map[acceptedFileType] === null\n                    ? false\n                    : map[acceptedFileType] || acceptedFileType;\n            };\n        };\n\n        // setup attribute mapping for accept\n        addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n            return Object.assign(map, {\n                accept: 'acceptedFileTypes',\n            });\n        });\n\n        // filtering if an item is allowed in hopper\n        addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n            var query = _ref2.query;\n            // if we are not doing file type validation exit\n            if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n                return true;\n            }\n\n            // we validate the file against the accepted file types\n            return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n        });\n\n        // called for each file that is loaded\n        // right before it is set to the item state\n        // should return a promise\n        addFilter('LOAD_FILE', function(file, _ref3) {\n            var query = _ref3.query;\n            return new Promise(function(resolve, reject) {\n                if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n                    resolve(file);\n                    return;\n                }\n\n                var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n                // custom type detector method\n                var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n                // if invalid, exit here\n                var validationResult = validateFile(file, acceptedFileTypes, typeDetector);\n\n                var handleRejection = function handleRejection() {\n                    var acceptedFileTypesMapped = acceptedFileTypes\n                        .map(\n                            applyMimeTypeMap(\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n                            )\n                        )\n                        .filter(function(label) {\n                            return label !== false;\n                        });\n\n                    var acceptedFileTypesMappedUnique = acceptedFileTypesMapped.filter(function(\n                        item,\n                        index\n                    ) {\n                        return acceptedFileTypesMapped.indexOf(item) === index;\n                    });\n\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n                            sub: replaceInString(\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                                {\n                                    allTypes: acceptedFileTypesMappedUnique.join(', '),\n                                    allButLastType: acceptedFileTypesMappedUnique\n                                        .slice(0, -1)\n                                        .join(', '),\n                                    lastType:\n                                        acceptedFileTypesMappedUnique[\n                                            acceptedFileTypesMappedUnique.length - 1\n                                        ],\n                                }\n                            ),\n                        },\n                    });\n                };\n\n                // has returned new filename immidiately\n                if (typeof validationResult === 'boolean') {\n                    if (!validationResult) {\n                        return handleRejection();\n                    }\n                    return resolve(file);\n                }\n\n                // is promise\n                validationResult\n                    .then(function() {\n                        resolve(file);\n                    })\n                    .catch(handleRejection);\n            });\n        });\n\n        // expose plugin\n        return {\n            // default options\n            options: {\n                // Enable or disable file type validation\n                allowFileTypeValidation: [true, Type.BOOLEAN],\n\n                // What file types to accept\n                acceptedFileTypes: [[], Type.ARRAY],\n                // - must be comma separated\n                // - mime types: image/png, image/jpeg, image/gif\n                // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n                // - wildcards: image/*\n\n                // label to show when a type is not allowed\n                labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n                // nicer label\n                fileValidateTypeLabelExpectedTypes: [\n                    'Expects {allButLastType} or {lastType}',\n                    Type.STRING,\n                ],\n\n                // map mime types to extensions\n                fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n                // Custom function to detect type of file\n                fileValidateTypeDetectType: [null, Type.FUNCTION],\n            },\n        };\n    };\n\n    // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n    var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    if (isBrowser) {\n        document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n    }\n\n    return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEU7QUFDQSxVQUFVLENBRWdGO0FBQzFGLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RTtBQUN2RSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQixJQUFJLFNBQVM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS10eXBlLmpzPzhkNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgMS4yLjlcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICAgICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSwgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgICAgICB2YXIgYWRkRmlsdGVyID0gX3JlZi5hZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlscyA9IF9yZWYudXRpbHM7XG4gICAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgICAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICAgICAgICBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nLFxuICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nID0gdXRpbHMucmVwbGFjZUluU3RyaW5nLFxuICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZSA9IHV0aWxzLmd1ZXNzdGltYXRlTWltZVR5cGUsXG4gICAgICAgICAgICBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSB1dGlscy5nZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUsXG4gICAgICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkwgPSB1dGlscy5nZXRGaWxlbmFtZUZyb21VUkw7XG5cbiAgICAgICAgdmFyIG1pbWVUeXBlTWF0Y2hlc1dpbGRDYXJkID0gZnVuY3Rpb24gbWltZVR5cGVNYXRjaGVzV2lsZENhcmQobWltZVR5cGUsIHdpbGRjYXJkKSB7XG4gICAgICAgICAgICB2YXIgbWltZVR5cGVHcm91cCA9ICgvXlteL10rLy5leGVjKG1pbWVUeXBlKSB8fCBbXSkucG9wKCk7IC8vIGltYWdlL3BuZyAtPiBpbWFnZVxuICAgICAgICAgICAgdmFyIHdpbGRjYXJkR3JvdXAgPSB3aWxkY2FyZC5zbGljZSgwLCAtMik7IC8vIGltYWdlLyogLT4gaW1hZ2VcbiAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZUdyb3VwID09PSB3aWxkY2FyZEdyb3VwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc1ZhbGlkTWltZVR5cGUgPSBmdW5jdGlvbiBpc1ZhbGlkTWltZVR5cGUoYWNjZXB0ZWRUeXBlcywgdXNlcklucHV0VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VwdGVkVHlwZXMuc29tZShmdW5jdGlvbihhY2NlcHRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBhY2NlcHRlZCBpcyB3aWxkY2FyZCBtaW1lIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoL1xcKiQvLnRlc3QoYWNjZXB0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWltZVR5cGVNYXRjaGVzV2lsZENhcmQodXNlcklucHV0VHlwZSwgYWNjZXB0ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpcyBub3JtYWwgbWltZSB0eXBlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VwdGVkVHlwZSA9PT0gdXNlcklucHV0VHlwZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRJdGVtVHlwZSA9IGZ1bmN0aW9uIGdldEl0ZW1UeXBlKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIGlzIGEgdXJsIHdlIGd1ZXNzIHRoZSBtaW1lIHR5cGUgYnkgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgdmFyIHR5cGUgPSAnJztcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldEZpbGVuYW1lRnJvbVVSTChpdGVtKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gaXRlbS50eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gdmFsaWRhdGVGaWxlKGl0ZW0sIGFjY2VwdGVkRmlsZVR5cGVzLCB0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIG5vIHR5cGVzIGRlZmluZWQsIGV2ZXJ5dGhpbmcgaXMgYWxsb3dlZCBcXG8vXG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRGaWxlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldHMgdGhlIGl0ZW0gdHlwZVxuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRJdGVtVHlwZShpdGVtKTtcblxuICAgICAgICAgICAgLy8gbm8gdHlwZSBkZXRlY3RvciwgdGVzdCBub3dcbiAgICAgICAgICAgIGlmICghdHlwZURldGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVzZSB0eXBlIGRldGVjdG9yXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZURldGVjdG9yKGl0ZW0sIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgZGV0ZWN0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwcGx5TWltZVR5cGVNYXAgPSBmdW5jdGlvbiBhcHBseU1pbWVUeXBlTWFwKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFjY2VwdGVkRmlsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwW2FjY2VwdGVkRmlsZVR5cGVdID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgOiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gfHwgYWNjZXB0ZWRGaWxlVHlwZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0dXAgYXR0cmlidXRlIG1hcHBpbmcgZm9yIGFjY2VwdFxuICAgICAgICBhZGRGaWx0ZXIoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgICAgICAgICAgYWNjZXB0OiAnYWNjZXB0ZWRGaWxlVHlwZXMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbHRlcmluZyBpZiBhbiBpdGVtIGlzIGFsbG93ZWQgaW4gaG9wcGVyXG4gICAgICAgIGFkZEZpbHRlcignQUxMT1dfSE9QUEVSX0lURU0nLCBmdW5jdGlvbihmaWxlLCBfcmVmMikge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGZpbGUgdHlwZSB2YWxpZGF0aW9uIGV4aXRcbiAgICAgICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIHZhbGlkYXRlIHRoZSBmaWxlIGFnYWluc3QgdGhlIGFjY2VwdGVkIGZpbGUgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUZpbGUoZmlsZSwgcXVlcnkoJ0dFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsZWQgZm9yIGVhY2ggZmlsZSB0aGF0IGlzIGxvYWRlZFxuICAgICAgICAvLyByaWdodCBiZWZvcmUgaXQgaXMgc2V0IHRvIHRoZSBpdGVtIHN0YXRlXG4gICAgICAgIC8vIHNob3VsZCByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgIGFkZEZpbHRlcignTE9BRF9GSUxFJywgZnVuY3Rpb24oZmlsZSwgX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWYzLnF1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXMgPSBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKTtcblxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSB0eXBlIGRldGVjdG9yIG1ldGhvZFxuICAgICAgICAgICAgICAgIHZhciB0eXBlRGV0ZWN0b3IgPSBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9ERVRFQ1RfVFlQRScpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB2YWxpZGF0ZUZpbGUoZmlsZSwgYWNjZXB0ZWRGaWxlVHlwZXMsIHR5cGVEZXRlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUmVqZWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU1pbWVUeXBlTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWwgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkVW5pcXVlID0gYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuZmlsdGVyKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHJlcGxhY2VJblN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHlwZXM6IGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkVW5pcXVlLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxCdXRMYXN0VHlwZTogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VHlwZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFVuaXF1ZVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGhhcyByZXR1cm5lZCBuZXcgZmlsZW5hbWUgaW1taWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZWplY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpcyBwcm9taXNlXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChoYW5kbGVSZWplY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGV4cG9zZSBwbHVnaW5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGZpbGUgdHlwZSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgYWxsb3dGaWxlVHlwZVZhbGlkYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgICAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICAgICAgICAgIGFjY2VwdGVkRmlsZVR5cGVzOiBbW10sIFR5cGUuQVJSQVldLFxuICAgICAgICAgICAgICAgIC8vIC0gbXVzdCBiZSBjb21tYSBzZXBhcmF0ZWRcbiAgICAgICAgICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgICAgICAgICAgLy8gLSBleHRlbnNpb25zOiAucG5nLCAuanBnLCAuanBlZyAoIG5vdCBlbmFibGVkIHlldCApXG4gICAgICAgICAgICAgICAgLy8gLSB3aWxkY2FyZHM6IGltYWdlLypcblxuICAgICAgICAgICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgICAgICAgICBsYWJlbEZpbGVUeXBlTm90QWxsb3dlZDogWydGaWxlIGlzIG9mIGludmFsaWQgdHlwZScsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAgICAgICAgIC8vIG5pY2VyIGxhYmVsXG4gICAgICAgICAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICAgICAgICAgICAnRXhwZWN0cyB7YWxsQnV0TGFzdFR5cGV9IG9yIHtsYXN0VHlwZX0nLFxuICAgICAgICAgICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAgICAgLy8gbWFwIG1pbWUgdHlwZXMgdG8gZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVMYWJlbEV4cGVjdGVkVHlwZXNNYXA6IFt7fSwgVHlwZS5PQkpFQ1RdLFxuXG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVjdCB0eXBlIG9mIGZpbGVcbiAgICAgICAgICAgICAgICBmaWxlVmFsaWRhdGVUeXBlRGV0ZWN0VHlwZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js ***!
  \******************************************************************************************/
/***/ (function(module) {

eval("/*!\n * FilePondPluginImagePreview 4.6.12\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : 0;\n})(this, function() {\n  'use strict';\n\n  // test if file is of type image and can be viewed in canvas\n  var isPreviewableImage = function isPreviewableImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol.for &&\n          Symbol.for('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol === 'function') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var vectorMultiply = function vectorMultiply(v, amount) {\n    return createVector(v.x * amount, v.y * amount);\n  };\n\n  var vectorAdd = function vectorAdd(a, b) {\n    return createVector(a.x + b.x, a.y + b.y);\n  };\n\n  var vectorNormalize = function vectorNormalize(v) {\n    var l = Math.sqrt(v.x * v.x + v.y * v.y);\n    if (l === 0) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    return createVector(v.x / l, v.y / l);\n  };\n\n  var vectorRotate = function vectorRotate(v, radians, origin) {\n    var cos = Math.cos(radians);\n    var sin = Math.sin(radians);\n    var t = createVector(v.x - origin.x, v.y - origin.y);\n    return createVector(\n      origin.x + cos * t.x - sin * t.y,\n      origin.y + sin * t.x + cos * t.y\n    );\n  };\n\n  var createVector = function createVector() {\n    var x =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return { x: x, y: y };\n  };\n\n  var getMarkupValue = function getMarkupValue(value, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var axis = arguments.length > 3 ? arguments[3] : undefined;\n    if (typeof value === 'string') {\n      return parseFloat(value) * scalar;\n    }\n    if (typeof value === 'number') {\n      return value * (axis ? size[axis] : Math.min(size.width, size.height));\n    }\n    return;\n  };\n\n  var getMarkupStyles = function getMarkupStyles(markup, size, scale) {\n    var lineStyle = markup.borderStyle || markup.lineStyle || 'solid';\n    var fill = markup.backgroundColor || markup.fontColor || 'transparent';\n    var stroke = markup.borderColor || markup.lineColor || 'transparent';\n    var strokeWidth = getMarkupValue(\n      markup.borderWidth || markup.lineWidth,\n      size,\n      scale\n    );\n    var lineCap = markup.lineCap || 'round';\n    var lineJoin = markup.lineJoin || 'round';\n    var dashes =\n      typeof lineStyle === 'string'\n        ? ''\n        : lineStyle\n            .map(function(v) {\n              return getMarkupValue(v, size, scale);\n            })\n            .join(',');\n    var opacity = markup.opacity || 1;\n    return {\n      'stroke-linecap': lineCap,\n      'stroke-linejoin': lineJoin,\n      'stroke-width': strokeWidth || 0,\n      'stroke-dasharray': dashes,\n      stroke: stroke,\n      fill: fill,\n      opacity: opacity\n    };\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  var getMarkupRect = function getMarkupRect(rect, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var left =\n      getMarkupValue(rect.x, size, scalar, 'width') ||\n      getMarkupValue(rect.left, size, scalar, 'width');\n    var top =\n      getMarkupValue(rect.y, size, scalar, 'height') ||\n      getMarkupValue(rect.top, size, scalar, 'height');\n    var width = getMarkupValue(rect.width, size, scalar, 'width');\n    var height = getMarkupValue(rect.height, size, scalar, 'height');\n    var right = getMarkupValue(rect.right, size, scalar, 'width');\n    var bottom = getMarkupValue(rect.bottom, size, scalar, 'height');\n\n    if (!isDefined(top)) {\n      if (isDefined(height) && isDefined(bottom)) {\n        top = size.height - height - bottom;\n      } else {\n        top = bottom;\n      }\n    }\n\n    if (!isDefined(left)) {\n      if (isDefined(width) && isDefined(right)) {\n        left = size.width - width - right;\n      } else {\n        left = right;\n      }\n    }\n\n    if (!isDefined(width)) {\n      if (isDefined(left) && isDefined(right)) {\n        width = size.width - left - right;\n      } else {\n        width = 0;\n      }\n    }\n\n    if (!isDefined(height)) {\n      if (isDefined(top) && isDefined(bottom)) {\n        height = size.height - top - bottom;\n      } else {\n        height = 0;\n      }\n    }\n\n    return {\n      x: left || 0,\n      y: top || 0,\n      width: width || 0,\n      height: height || 0\n    };\n  };\n\n  var pointsToPathShape = function pointsToPathShape(points) {\n    return points\n      .map(function(point, index) {\n        return ''\n          .concat(index === 0 ? 'M' : 'L', ' ')\n          .concat(point.x, ' ')\n          .concat(point.y);\n      })\n      .join(' ');\n  };\n\n  var setAttributes = function setAttributes(element, attr) {\n    return Object.keys(attr).forEach(function(key) {\n      return element.setAttribute(key, attr[key]);\n    });\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svg = function svg(tag, attr) {\n    var element = document.createElementNS(ns, tag);\n    if (attr) {\n      setAttributes(element, attr);\n    }\n    return element;\n  };\n\n  var updateRect = function updateRect(element) {\n    return setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles)\n    );\n  };\n\n  var updateEllipse = function updateEllipse(element) {\n    var cx = element.rect.x + element.rect.width * 0.5;\n    var cy = element.rect.y + element.rect.height * 0.5;\n    var rx = element.rect.width * 0.5;\n    var ry = element.rect.height * 0.5;\n    return setAttributes(\n      element,\n      Object.assign(\n        {\n          cx: cx,\n          cy: cy,\n          rx: rx,\n          ry: ry\n        },\n        element.styles\n      )\n    );\n  };\n\n  var IMAGE_FIT_STYLE = {\n    contain: 'xMidYMid meet',\n    cover: 'xMidYMid slice'\n  };\n\n  var updateImage = function updateImage(element, markup) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || 'none'\n      })\n    );\n  };\n\n  var TEXT_ANCHOR = {\n    left: 'start',\n    center: 'middle',\n    right: 'end'\n  };\n\n  var updateText = function updateText(element, markup, size, scale) {\n    var fontSize = getMarkupValue(markup.fontSize, size, scale);\n    var fontFamily = markup.fontFamily || 'sans-serif';\n    var fontWeight = markup.fontWeight || 'normal';\n    var textAlign = TEXT_ANCHOR[markup.textAlign] || 'start';\n\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        'stroke-width': 0,\n        'font-weight': fontWeight,\n        'font-size': fontSize,\n        'font-family': fontFamily,\n        'text-anchor': textAlign\n      })\n    );\n\n    // update text\n    if (element.text !== markup.text) {\n      element.text = markup.text;\n      element.textContent = markup.text.length ? markup.text : ' ';\n    }\n  };\n\n  var updateLine = function updateLine(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        fill: 'none'\n      })\n    );\n\n    var line = element.childNodes[0];\n    var begin = element.childNodes[1];\n    var end = element.childNodes[2];\n\n    var origin = element.rect;\n\n    var target = {\n      x: element.rect.x + element.rect.width,\n      y: element.rect.y + element.rect.height\n    };\n\n    setAttributes(line, {\n      x1: origin.x,\n      y1: origin.y,\n      x2: target.x,\n      y2: target.y\n    });\n\n    if (!markup.lineDecoration) return;\n\n    begin.style.display = 'none';\n    end.style.display = 'none';\n\n    var v = vectorNormalize({\n      x: target.x - origin.x,\n      y: target.y - origin.y\n    });\n\n    var l = getMarkupValue(0.05, size, scale);\n\n    if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n      var arrowBeginRotationPoint = vectorMultiply(v, l);\n      var arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n      var arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n      var arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n      setAttributes(begin, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowBeginA.x, ',')\n          .concat(arrowBeginA.y, ' L')\n          .concat(origin.x, ',')\n          .concat(origin.y, ' L')\n          .concat(arrowBeginB.x, ',')\n          .concat(arrowBeginB.y)\n      });\n    }\n\n    if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n      var arrowEndRotationPoint = vectorMultiply(v, -l);\n      var arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n      var arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n      var arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n      setAttributes(end, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowEndA.x, ',')\n          .concat(arrowEndA.y, ' L')\n          .concat(target.x, ',')\n          .concat(target.y, ' L')\n          .concat(arrowEndB.x, ',')\n          .concat(arrowEndB.y)\n      });\n    }\n  };\n\n  var updatePath = function updatePath(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.styles, {\n        fill: 'none',\n        d: pointsToPathShape(\n          markup.points.map(function(point) {\n            return {\n              x: getMarkupValue(point.x, size, scale, 'width'),\n              y: getMarkupValue(point.y, size, scale, 'height')\n            };\n          })\n        )\n      })\n    );\n  };\n\n  var createShape = function createShape(node) {\n    return function(markup) {\n      return svg(node, { id: markup.id });\n    };\n  };\n\n  var createImage = function createImage(markup) {\n    var shape = svg('image', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round',\n      opacity: '0'\n    });\n\n    shape.onload = function() {\n      shape.setAttribute('opacity', markup.opacity || 1);\n    };\n    shape.setAttributeNS(\n      'http://www.w3.org/1999/xlink',\n      'xlink:href',\n      markup.src\n    );\n    return shape;\n  };\n\n  var createLine = function createLine(markup) {\n    var shape = svg('g', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round'\n    });\n\n    var line = svg('line');\n    shape.appendChild(line);\n\n    var begin = svg('path');\n    shape.appendChild(begin);\n\n    var end = svg('path');\n    shape.appendChild(end);\n\n    return shape;\n  };\n\n  var CREATE_TYPE_ROUTES = {\n    image: createImage,\n    rect: createShape('rect'),\n    ellipse: createShape('ellipse'),\n    text: createShape('text'),\n    path: createShape('path'),\n    line: createLine\n  };\n\n  var UPDATE_TYPE_ROUTES = {\n    rect: updateRect,\n    ellipse: updateEllipse,\n    image: updateImage,\n    text: updateText,\n    path: updatePath,\n    line: updateLine\n  };\n\n  var createMarkupByType = function createMarkupByType(type, markup) {\n    return CREATE_TYPE_ROUTES[type](markup);\n  };\n\n  var updateMarkupByType = function updateMarkupByType(\n    element,\n    type,\n    markup,\n    size,\n    scale\n  ) {\n    if (type !== 'path') {\n      element.rect = getMarkupRect(markup, size, scale);\n    }\n    element.styles = getMarkupStyles(markup, size, scale);\n    UPDATE_TYPE_ROUTES[type](element, markup, size, scale);\n  };\n\n  var MARKUP_RECT = [\n    'x',\n    'y',\n    'left',\n    'top',\n    'right',\n    'bottom',\n    'width',\n    'height'\n  ];\n\n  var toOptionalFraction = function toOptionalFraction(value) {\n    return typeof value === 'string' && /%/.test(value)\n      ? parseFloat(value) / 100\n      : value;\n  };\n\n  // adds default markup properties, clones markup\n  var prepareMarkup = function prepareMarkup(markup) {\n    var _markup = _slicedToArray(markup, 2),\n      type = _markup[0],\n      props = _markup[1];\n\n    var rect = props.points\n      ? {}\n      : MARKUP_RECT.reduce(function(prev, curr) {\n          prev[curr] = toOptionalFraction(props[curr]);\n          return prev;\n        }, {});\n\n    return [\n      type,\n      Object.assign(\n        {\n          zIndex: 0\n        },\n        props,\n        rect\n      )\n    ];\n  };\n\n  var sortMarkupByZIndex = function sortMarkupByZIndex(a, b) {\n    if (a[1].zIndex > b[1].zIndex) {\n      return 1;\n    }\n    if (a[1].zIndex < b[1].zIndex) {\n      return -1;\n    }\n    return 0;\n  };\n\n  var createMarkupView = function createMarkupView(_) {\n    return _.utils.createView({\n      name: 'image-preview-markup',\n      tag: 'svg',\n      ignoreRect: true,\n      mixins: {\n        apis: ['width', 'height', 'crop', 'markup', 'resize', 'dirty']\n      },\n\n      write: function write(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n\n        if (!props.dirty) return;\n        var crop = props.crop,\n          resize = props.resize,\n          markup = props.markup;\n\n        var viewWidth = props.width;\n        var viewHeight = props.height;\n\n        var cropWidth = crop.width;\n        var cropHeight = crop.height;\n\n        if (resize) {\n          var _size = resize.size;\n\n          var outputWidth = _size && _size.width;\n          var outputHeight = _size && _size.height;\n          var outputFit = resize.mode;\n          var outputUpscale = resize.upscale;\n\n          if (outputWidth && !outputHeight) outputHeight = outputWidth;\n          if (outputHeight && !outputWidth) outputWidth = outputHeight;\n\n          var shouldUpscale =\n            cropWidth < outputWidth && cropHeight < outputHeight;\n\n          if (!shouldUpscale || (shouldUpscale && outputUpscale)) {\n            var scalarWidth = outputWidth / cropWidth;\n            var scalarHeight = outputHeight / cropHeight;\n\n            if (outputFit === 'force') {\n              cropWidth = outputWidth;\n              cropHeight = outputHeight;\n            } else {\n              var scalar;\n              if (outputFit === 'cover') {\n                scalar = Math.max(scalarWidth, scalarHeight);\n              } else if (outputFit === 'contain') {\n                scalar = Math.min(scalarWidth, scalarHeight);\n              }\n              cropWidth = cropWidth * scalar;\n              cropHeight = cropHeight * scalar;\n            }\n          }\n        }\n\n        var size = {\n          width: viewWidth,\n          height: viewHeight\n        };\n\n        root.element.setAttribute('width', size.width);\n        root.element.setAttribute('height', size.height);\n\n        var scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);\n\n        // clear\n        root.element.innerHTML = '';\n\n        // get filter\n        var markupFilter = root.query('GET_IMAGE_PREVIEW_MARKUP_FILTER');\n\n        // draw new\n        markup\n          .filter(markupFilter)\n          .map(prepareMarkup)\n          .sort(sortMarkupByZIndex)\n          .forEach(function(markup) {\n            var _markup = _slicedToArray(markup, 2),\n              type = _markup[0],\n              settings = _markup[1];\n\n            // create\n            var element = createMarkupByType(type, settings);\n\n            // update\n            updateMarkupByType(element, type, settings, size, scale);\n\n            // add\n            root.element.appendChild(element);\n          });\n      }\n    });\n  };\n\n  var createVector$1 = function createVector(x, y) {\n    return { x: x, y: y };\n  };\n\n  var vectorDot = function vectorDot(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n\n  var vectorSubtract = function vectorSubtract(a, b) {\n    return createVector$1(a.x - b.x, a.y - b.y);\n  };\n\n  var vectorDistanceSquared = function vectorDistanceSquared(a, b) {\n    return vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));\n  };\n\n  var vectorDistance = function vectorDistance(a, b) {\n    return Math.sqrt(vectorDistanceSquared(a, b));\n  };\n\n  var getOffsetPointOnEdge = function getOffsetPointOnEdge(length, rotation) {\n    var a = length;\n\n    var A = 1.5707963267948966;\n    var B = rotation;\n    var C = 1.5707963267948966 - rotation;\n\n    var sinA = Math.sin(A);\n    var sinB = Math.sin(B);\n    var sinC = Math.sin(C);\n    var cosC = Math.cos(C);\n    var ratio = a / sinA;\n    var b = ratio * sinB;\n    var c = ratio * sinC;\n\n    return createVector$1(cosC * b, cosC * c);\n  };\n\n  var getRotatedRectSize = function getRotatedRectSize(rect, rotation) {\n    var w = rect.width;\n    var h = rect.height;\n\n    var hor = getOffsetPointOnEdge(w, rotation);\n    var ver = getOffsetPointOnEdge(h, rotation);\n\n    var tl = createVector$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));\n\n    var tr = createVector$1(\n      rect.x + rect.width + Math.abs(ver.y),\n      rect.y + Math.abs(ver.x)\n    );\n\n    var bl = createVector$1(\n      rect.x - Math.abs(ver.y),\n      rect.y + rect.height - Math.abs(ver.x)\n    );\n\n    return {\n      width: vectorDistance(tl, tr),\n      height: vectorDistance(tl, bl)\n    };\n  };\n\n  var calculateCanvasSize = function calculateCanvasSize(\n    image,\n    canvasAspectRatio\n  ) {\n    var zoom =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var imageAspectRatio = image.height / image.width;\n\n    // determine actual pixels on x and y axis\n    var canvasWidth = 1;\n    var canvasHeight = canvasAspectRatio;\n    var imgWidth = 1;\n    var imgHeight = imageAspectRatio;\n    if (imgHeight > canvasHeight) {\n      imgHeight = canvasHeight;\n      imgWidth = imgHeight / imageAspectRatio;\n    }\n\n    var scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);\n    var width = image.width / (zoom * scalar * imgWidth);\n    var height = width * canvasAspectRatio;\n\n    return {\n      width: width,\n      height: height\n    };\n  };\n\n  var getImageRectZoomFactor = function getImageRectZoomFactor(\n    imageRect,\n    cropRect,\n    rotation,\n    center\n  ) {\n    // calculate available space round image center position\n    var cx = center.x > 0.5 ? 1 - center.x : center.x;\n    var cy = center.y > 0.5 ? 1 - center.y : center.y;\n    var imageWidth = cx * 2 * imageRect.width;\n    var imageHeight = cy * 2 * imageRect.height;\n\n    // calculate rotated crop rectangle size\n    var rotatedCropSize = getRotatedRectSize(cropRect, rotation);\n\n    // calculate scalar required to fit image\n    return Math.max(\n      rotatedCropSize.width / imageWidth,\n      rotatedCropSize.height / imageHeight\n    );\n  };\n\n  var getCenteredCropRect = function getCenteredCropRect(\n    container,\n    aspectRatio\n  ) {\n    var width = container.width;\n    var height = width * aspectRatio;\n    if (height > container.height) {\n      height = container.height;\n      width = height / aspectRatio;\n    }\n    var x = (container.width - width) * 0.5;\n    var y = (container.height - height) * 0.5;\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  var getCurrentCropSize = function getCurrentCropSize(imageSize) {\n    var crop =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var zoom = crop.zoom,\n      rotation = crop.rotation,\n      center = crop.center,\n      aspectRatio = crop.aspectRatio;\n\n    if (!aspectRatio) aspectRatio = imageSize.height / imageSize.width;\n\n    var canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n\n    var canvasCenter = {\n      x: canvasSize.width * 0.5,\n      y: canvasSize.height * 0.5\n    };\n\n    var stage = {\n      x: 0,\n      y: 0,\n      width: canvasSize.width,\n      height: canvasSize.height,\n      center: canvasCenter\n    };\n\n    var shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n    var stageZoomFactor = getImageRectZoomFactor(\n      imageSize,\n      getCenteredCropRect(stage, aspectRatio),\n      rotation,\n      shouldLimit ? center : { x: 0.5, y: 0.5 }\n    );\n\n    var scale = zoom * stageZoomFactor;\n\n    // start drawing\n    return {\n      widthFloat: canvasSize.width / scale,\n      heightFloat: canvasSize.height / scale,\n      width: Math.round(canvasSize.width / scale),\n      height: Math.round(canvasSize.height / scale)\n    };\n  };\n\n  var IMAGE_SCALE_SPRING_PROPS = {\n    type: 'spring',\n    stiffness: 0.5,\n    damping: 0.45,\n    mass: 10\n  };\n\n  // does horizontal and vertical flipping\n  var createBitmapView = function createBitmapView(_) {\n    return _.utils.createView({\n      name: 'image-bitmap',\n      ignoreRect: true,\n      mixins: { styles: ['scaleX', 'scaleY'] },\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        root.appendChild(props.image);\n      }\n    });\n  };\n\n  // shifts and rotates image\n  var createImageCanvasWrapper = function createImageCanvasWrapper(_) {\n    return _.utils.createView({\n      name: 'image-canvas-wrapper',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['crop', 'width', 'height'],\n\n        styles: [\n          'originX',\n          'originY',\n          'translateX',\n          'translateY',\n          'scaleX',\n          'scaleY',\n          'rotateZ'\n        ],\n\n        animations: {\n          originX: IMAGE_SCALE_SPRING_PROPS,\n          originY: IMAGE_SCALE_SPRING_PROPS,\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateX: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          rotateZ: IMAGE_SCALE_SPRING_PROPS\n        }\n      },\n\n      create: function create(_ref2) {\n        var root = _ref2.root,\n          props = _ref2.props;\n        props.width = props.image.width;\n        props.height = props.image.height;\n        root.ref.bitmap = root.appendChildView(\n          root.createChildView(createBitmapView(_), { image: props.image })\n        );\n      },\n      write: function write(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        var flip = props.crop.flip;\n        var bitmap = root.ref.bitmap;\n        bitmap.scaleX = flip.horizontal ? -1 : 1;\n        bitmap.scaleY = flip.vertical ? -1 : 1;\n      }\n    });\n  };\n\n  // clips canvas to correct aspect ratio\n  var createClipView = function createClipView(_) {\n    return _.utils.createView({\n      name: 'image-clip',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: [\n          'crop',\n          'markup',\n          'resize',\n          'width',\n          'height',\n          'dirty',\n          'background'\n        ],\n\n        styles: ['width', 'height', 'opacity'],\n        animations: {\n          opacity: { type: 'tween', duration: 250 }\n        }\n      },\n\n      didWriteView: function didWriteView(_ref4) {\n        var root = _ref4.root,\n          props = _ref4.props;\n        if (!props.background) return;\n        root.element.style.backgroundColor = props.background;\n      },\n      create: function create(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n\n        root.ref.image = root.appendChildView(\n          root.createChildView(\n            createImageCanvasWrapper(_),\n            Object.assign({}, props)\n          )\n        );\n\n        root.ref.createMarkup = function() {\n          if (root.ref.markup) return;\n          root.ref.markup = root.appendChildView(\n            root.createChildView(createMarkupView(_), Object.assign({}, props))\n          );\n        };\n\n        root.ref.destroyMarkup = function() {\n          if (!root.ref.markup) return;\n          root.removeChildView(root.ref.markup);\n          root.ref.markup = null;\n        };\n\n        // set up transparency grid\n        var transparencyIndicator = root.query(\n          'GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR'\n        );\n        if (transparencyIndicator === null) return;\n\n        // grid pattern\n        if (transparencyIndicator === 'grid') {\n          root.element.dataset.transparencyIndicator = transparencyIndicator;\n        }\n        // basic color\n        else {\n          root.element.dataset.transparencyIndicator = 'color';\n        }\n      },\n      write: function write(_ref6) {\n        var root = _ref6.root,\n          props = _ref6.props,\n          shouldOptimize = _ref6.shouldOptimize;\n        var crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty,\n          width = props.width,\n          height = props.height;\n\n        root.ref.image.crop = crop;\n\n        var stage = {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          center: {\n            x: width * 0.5,\n            y: height * 0.5\n          }\n        };\n\n        var image = {\n          width: root.ref.image.width,\n          height: root.ref.image.height\n        };\n\n        var origin = {\n          x: crop.center.x * image.width,\n          y: crop.center.y * image.height\n        };\n\n        var translation = {\n          x: stage.center.x - image.width * crop.center.x,\n          y: stage.center.y - image.height * crop.center.y\n        };\n\n        var rotation = Math.PI * 2 + (crop.rotation % (Math.PI * 2));\n\n        var cropAspectRatio = crop.aspectRatio || image.height / image.width;\n\n        var shouldLimit =\n          typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n        var stageZoomFactor = getImageRectZoomFactor(\n          image,\n          getCenteredCropRect(stage, cropAspectRatio),\n\n          rotation,\n          shouldLimit ? crop.center : { x: 0.5, y: 0.5 }\n        );\n\n        var scale = crop.zoom * stageZoomFactor;\n\n        // update markup view\n        if (markup && markup.length) {\n          root.ref.createMarkup();\n          root.ref.markup.width = width;\n          root.ref.markup.height = height;\n          root.ref.markup.resize = resize;\n          root.ref.markup.dirty = dirty;\n          root.ref.markup.markup = markup;\n          root.ref.markup.crop = getCurrentCropSize(image, crop);\n        } else if (root.ref.markup) {\n          root.ref.destroyMarkup();\n        }\n\n        // update image view\n        var imageView = root.ref.image;\n\n        // don't update clip layout\n        if (shouldOptimize) {\n          imageView.originX = null;\n          imageView.originY = null;\n          imageView.translateX = null;\n          imageView.translateY = null;\n          imageView.rotateZ = null;\n          imageView.scaleX = null;\n          imageView.scaleY = null;\n          return;\n        }\n\n        imageView.originX = origin.x;\n        imageView.originY = origin.y;\n        imageView.translateX = translation.x;\n        imageView.translateY = translation.y;\n        imageView.rotateZ = rotation;\n        imageView.scaleX = scale;\n        imageView.scaleY = scale;\n      }\n    });\n  };\n\n  var createImageView = function createImageView(_) {\n    return _.utils.createView({\n      name: 'image-preview',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['image', 'crop', 'markup', 'resize', 'dirty', 'background'],\n\n        styles: ['translateY', 'scaleX', 'scaleY', 'opacity'],\n\n        animations: {\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          opacity: { type: 'tween', duration: 400 }\n        }\n      },\n\n      create: function create(_ref7) {\n        var root = _ref7.root,\n          props = _ref7.props;\n        root.ref.clip = root.appendChildView(\n          root.createChildView(createClipView(_), {\n            id: props.id,\n            image: props.image,\n            crop: props.crop,\n            markup: props.markup,\n            resize: props.resize,\n            dirty: props.dirty,\n            background: props.background\n          })\n        );\n      },\n      write: function write(_ref8) {\n        var root = _ref8.root,\n          props = _ref8.props,\n          shouldOptimize = _ref8.shouldOptimize;\n        var clip = root.ref.clip;\n        var image = props.image,\n          crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty;\n\n        clip.crop = crop;\n        clip.markup = markup;\n        clip.resize = resize;\n        clip.dirty = dirty;\n\n        // don't update clip layout\n        clip.opacity = shouldOptimize ? 0 : 1;\n\n        // don't re-render if optimizing or hidden (width will be zero resulting in weird animations)\n        if (shouldOptimize || root.rect.element.hidden) return;\n\n        // calculate scaled preview image size\n        var imageAspectRatio = image.height / image.width;\n        var aspectRatio = crop.aspectRatio || imageAspectRatio;\n\n        // calculate container size\n        var containerWidth = root.rect.inner.width;\n        var containerHeight = root.rect.inner.height;\n\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n\n        if (panelAspectRatio && !allowMultiple) {\n          fixedPreviewHeight = containerWidth * panelAspectRatio;\n          aspectRatio = panelAspectRatio;\n        }\n\n        // determine clip width and height\n        var clipHeight =\n          fixedPreviewHeight !== null\n            ? fixedPreviewHeight\n            : Math.max(\n                minPreviewHeight,\n                Math.min(containerWidth * aspectRatio, maxPreviewHeight)\n              );\n\n        var clipWidth = clipHeight / aspectRatio;\n        if (clipWidth > containerWidth) {\n          clipWidth = containerWidth;\n          clipHeight = clipWidth * aspectRatio;\n        }\n\n        if (clipHeight > containerHeight) {\n          clipHeight = containerHeight;\n          clipWidth = containerHeight / aspectRatio;\n        }\n\n        clip.width = clipWidth;\n        clip.height = clipHeight;\n      }\n    });\n  };\n\n  var SVG_MASK =\n    '<svg width=\"500\" height=\"200\" viewBox=\"0 0 500 200\" preserveAspectRatio=\"none\">\\n    <defs>\\n        <radialGradient id=\"gradient-__UID__\" cx=\".5\" cy=\"1.25\" r=\"1.15\">\\n            <stop offset=\\'50%\\' stop-color=\\'#000000\\'/>\\n            <stop offset=\\'56%\\' stop-color=\\'#0a0a0a\\'/>\\n            <stop offset=\\'63%\\' stop-color=\\'#262626\\'/>\\n            <stop offset=\\'69%\\' stop-color=\\'#4f4f4f\\'/>\\n            <stop offset=\\'75%\\' stop-color=\\'#808080\\'/>\\n            <stop offset=\\'81%\\' stop-color=\\'#b1b1b1\\'/>\\n            <stop offset=\\'88%\\' stop-color=\\'#dadada\\'/>\\n            <stop offset=\\'94%\\' stop-color=\\'#f6f6f6\\'/>\\n            <stop offset=\\'100%\\' stop-color=\\'#ffffff\\'/>\\n        </radialGradient>\\n        <mask id=\"mask-__UID__\">\\n            <rect x=\"0\" y=\"0\" width=\"500\" height=\"200\" fill=\"url(#gradient-__UID__)\"></rect>\\n        </mask>\\n    </defs>\\n    <rect x=\"0\" width=\"500\" height=\"200\" fill=\"currentColor\" mask=\"url(#mask-__UID__)\"></rect>\\n</svg>';\n\n  var SVGMaskUniqueId = 0;\n\n  var createImageOverlayView = function createImageOverlayView(fpAPI) {\n    return fpAPI.utils.createView({\n      name: 'image-preview-overlay',\n      tag: 'div',\n      ignoreRect: true,\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        var mask = SVG_MASK;\n        if (document.querySelector('base')) {\n          var url = new URL(\n            window.location.href.replace(window.location.hash, '')\n          ).href;\n          mask = mask.replace(/url\\(\\#/g, 'url(' + url + '#');\n        }\n\n        SVGMaskUniqueId++;\n        root.element.classList.add(\n          'filepond--image-preview-overlay-'.concat(props.status)\n        );\n\n        root.element.innerHTML = mask.replace(/__UID__/g, SVGMaskUniqueId);\n      },\n      mixins: {\n        styles: ['opacity'],\n        animations: {\n          opacity: { type: 'spring', mass: 25 }\n        }\n      }\n    });\n  };\n\n  /**\n   * Bitmap Worker\n   */\n  var BitmapWorker = function BitmapWorker() {\n    self.onmessage = function(e) {\n      createImageBitmap(e.data.message.file).then(function(bitmap) {\n        self.postMessage({ id: e.data.id, message: bitmap }, [bitmap]);\n      });\n    };\n  };\n\n  /**\n   * ColorMatrix Worker\n   */\n  var ColorMatrixWorker = function ColorMatrixWorker() {\n    self.onmessage = function(e) {\n      var imageData = e.data.message.imageData;\n      var matrix = e.data.message.colorMatrix;\n\n      var data = imageData.data;\n      var l = data.length;\n\n      var m11 = matrix[0];\n      var m12 = matrix[1];\n      var m13 = matrix[2];\n      var m14 = matrix[3];\n      var m15 = matrix[4];\n\n      var m21 = matrix[5];\n      var m22 = matrix[6];\n      var m23 = matrix[7];\n      var m24 = matrix[8];\n      var m25 = matrix[9];\n\n      var m31 = matrix[10];\n      var m32 = matrix[11];\n      var m33 = matrix[12];\n      var m34 = matrix[13];\n      var m35 = matrix[14];\n\n      var m41 = matrix[15];\n      var m42 = matrix[16];\n      var m43 = matrix[17];\n      var m44 = matrix[18];\n      var m45 = matrix[19];\n\n      var index = 0,\n        r = 0.0,\n        g = 0.0,\n        b = 0.0,\n        a = 0.0;\n\n      for (; index < l; index += 4) {\n        r = data[index] / 255;\n        g = data[index + 1] / 255;\n        b = data[index + 2] / 255;\n        a = data[index + 3] / 255;\n        data[index] = Math.max(\n          0,\n          Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255)\n        );\n        data[index + 1] = Math.max(\n          0,\n          Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255)\n        );\n        data[index + 2] = Math.max(\n          0,\n          Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255)\n        );\n        data[index + 3] = Math.max(\n          0,\n          Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255)\n        );\n      }\n\n      self.postMessage({ id: e.data.id, message: imageData }, [\n        imageData.data.buffer\n      ]);\n    };\n  };\n\n  var getImageSize = function getImageSize(url, cb) {\n    var image = new Image();\n    image.onload = function() {\n      var width = image.naturalWidth;\n      var height = image.naturalHeight;\n      image = null;\n      cb(width, height);\n    };\n    image.src = url;\n  };\n\n  var transforms = {\n    1: function _() {\n      return [1, 0, 0, 1, 0, 0];\n    },\n    2: function _(width) {\n      return [-1, 0, 0, 1, width, 0];\n    },\n    3: function _(width, height) {\n      return [-1, 0, 0, -1, width, height];\n    },\n    4: function _(width, height) {\n      return [1, 0, 0, -1, 0, height];\n    },\n    5: function _() {\n      return [0, 1, 1, 0, 0, 0];\n    },\n    6: function _(width, height) {\n      return [0, 1, -1, 0, height, 0];\n    },\n    7: function _(width, height) {\n      return [0, -1, -1, 0, height, width];\n    },\n    8: function _(width) {\n      return [0, -1, 1, 0, 0, width];\n    }\n  };\n\n  var fixImageOrientation = function fixImageOrientation(\n    ctx,\n    width,\n    height,\n    orientation\n  ) {\n    // no orientation supplied\n    if (orientation === -1) {\n      return;\n    }\n\n    ctx.transform.apply(ctx, transforms[orientation](width, height));\n  };\n\n  // draws the preview image to canvas\n  var createPreviewImage = function createPreviewImage(\n    data,\n    width,\n    height,\n    orientation\n  ) {\n    // can't draw on half pixels\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // draw image\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n\n    // if is rotated incorrectly swap width and height\n    if (orientation >= 5 && orientation <= 8) {\n      var _ref = [height, width];\n      width = _ref[0];\n      height = _ref[1];\n    }\n\n    // correct image orientation\n    fixImageOrientation(ctx, width, height, orientation);\n\n    // draw the image\n    ctx.drawImage(data, 0, 0, width, height);\n\n    return canvas;\n  };\n\n  var isBitmap = function isBitmap(file) {\n    return /^image/.test(file.type) && !/svg/.test(file.type);\n  };\n\n  var MAX_WIDTH = 10;\n  var MAX_HEIGHT = 10;\n\n  var calculateAverageColor = function calculateAverageColor(image) {\n    var scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);\n\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var width = (canvas.width = Math.ceil(image.width * scalar));\n    var height = (canvas.height = Math.ceil(image.height * scalar));\n    ctx.drawImage(image, 0, 0, width, height);\n    var data = null;\n    try {\n      data = ctx.getImageData(0, 0, width, height).data;\n    } catch (e) {\n      return null;\n    }\n    var l = data.length;\n\n    var r = 0;\n    var g = 0;\n    var b = 0;\n    var i = 0;\n\n    for (; i < l; i += 4) {\n      r += data[i] * data[i];\n      g += data[i + 1] * data[i + 1];\n      b += data[i + 2] * data[i + 2];\n    }\n\n    r = averageColor(r, l);\n    g = averageColor(g, l);\n    b = averageColor(b, l);\n\n    return { r: r, g: g, b: b };\n  };\n\n  var averageColor = function averageColor(c, l) {\n    return Math.floor(Math.sqrt(c / (l / 4)));\n  };\n\n  var cloneCanvas = function cloneCanvas(origin, target) {\n    target = target || document.createElement('canvas');\n    target.width = origin.width;\n    target.height = origin.height;\n    var ctx = target.getContext('2d');\n    ctx.drawImage(origin, 0, 0);\n    return target;\n  };\n\n  var cloneImageData = function cloneImageData(imageData) {\n    var id;\n    try {\n      id = new ImageData(imageData.width, imageData.height);\n    } catch (e) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      id = ctx.createImageData(imageData.width, imageData.height);\n    }\n    id.data.set(new Uint8ClampedArray(imageData.data));\n    return id;\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.crossOrigin = 'Anonymous';\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var createImageWrapperView = function createImageWrapperView(_) {\n    // create overlay view\n    var OverlayView = createImageOverlayView(_);\n\n    var ImageView = createImageView(_);\n    var createWorker = _.utils.createWorker;\n\n    var applyFilter = function applyFilter(root, filter, target) {\n      return new Promise(function(resolve) {\n        // will store image data for future filter updates\n        if (!root.ref.imageData) {\n          root.ref.imageData = target\n            .getContext('2d')\n            .getImageData(0, 0, target.width, target.height);\n        }\n\n        // get image data reference\n        var imageData = cloneImageData(root.ref.imageData);\n\n        if (!filter || filter.length !== 20) {\n          target.getContext('2d').putImageData(imageData, 0, 0);\n          return resolve();\n        }\n\n        var worker = createWorker(ColorMatrixWorker);\n        worker.post(\n          {\n            imageData: imageData,\n            colorMatrix: filter\n          },\n\n          function(response) {\n            // apply filtered colors\n            target.getContext('2d').putImageData(response, 0, 0);\n\n            // stop worker\n            worker.terminate();\n\n            // done!\n            resolve();\n          },\n          [imageData.data.buffer]\n        );\n      });\n    };\n\n    var removeImageView = function removeImageView(root, imageView) {\n      root.removeChildView(imageView);\n      imageView.image.width = 1;\n      imageView.image.height = 1;\n      imageView._destroy();\n    };\n\n    // remove an image\n    var shiftImage = function shiftImage(_ref) {\n      var root = _ref.root;\n      var imageView = root.ref.images.shift();\n      imageView.opacity = 0;\n      imageView.translateY = -15;\n      root.ref.imageViewBin.push(imageView);\n      return imageView;\n    };\n\n    // add new image\n    var pushImage = function pushImage(_ref2) {\n      var root = _ref2.root,\n        props = _ref2.props,\n        image = _ref2.image;\n      var id = props.id;\n      var item = root.query('GET_ITEM', { id: id });\n      if (!item) return;\n\n      var crop = item.getMetadata('crop') || {\n        center: {\n          x: 0.5,\n          y: 0.5\n        },\n\n        flip: {\n          horizontal: false,\n          vertical: false\n        },\n\n        zoom: 1,\n        rotation: 0,\n        aspectRatio: null\n      };\n\n      var background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n\n      var markup;\n      var resize;\n      var dirty = false;\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        markup = item.getMetadata('markup') || [];\n        resize = item.getMetadata('resize');\n        dirty = true;\n      }\n\n      // append image presenter\n      var imageView = root.appendChildView(\n        root.createChildView(ImageView, {\n          id: id,\n          image: image,\n          crop: crop,\n          resize: resize,\n          markup: markup,\n          dirty: dirty,\n          background: background,\n          opacity: 0,\n          scaleX: 1.15,\n          scaleY: 1.15,\n          translateY: 15\n        }),\n\n        root.childViews.length\n      );\n\n      root.ref.images.push(imageView);\n\n      // reveal the preview image\n      imageView.opacity = 1;\n      imageView.scaleX = 1;\n      imageView.scaleY = 1;\n      imageView.translateY = 0;\n\n      // the preview is now ready to be drawn\n      setTimeout(function() {\n        root.dispatch('DID_IMAGE_PREVIEW_SHOW', { id: id });\n      }, 250);\n    };\n\n    var updateImage = function updateImage(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n      var imageView = root.ref.images[root.ref.images.length - 1];\n      imageView.crop = item.getMetadata('crop');\n      imageView.background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        imageView.dirty = true;\n        imageView.resize = item.getMetadata('resize');\n        imageView.markup = item.getMetadata('markup');\n      }\n    };\n\n    // replace image preview\n    var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n      var root = _ref4.root,\n        props = _ref4.props,\n        action = _ref4.action;\n      // only filter and crop trigger redraw\n      if (!/crop|filter|markup|resize/.test(action.change.key)) return;\n\n      // no images to update, exit\n      if (!root.ref.images.length) return;\n\n      // no item found, exit\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n\n      // for now, update existing image when filtering\n      if (/filter/.test(action.change.key)) {\n        var imageView = root.ref.images[root.ref.images.length - 1];\n        applyFilter(root, action.change.value, imageView.image);\n        return;\n      }\n\n      if (/crop|markup|resize/.test(action.change.key)) {\n        var crop = item.getMetadata('crop');\n        var image = root.ref.images[root.ref.images.length - 1];\n\n        // if aspect ratio has changed, we need to create a new image\n        if (\n          crop &&\n          crop.aspectRatio &&\n          image.crop &&\n          image.crop.aspectRatio &&\n          Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 0.00001\n        ) {\n          var _imageView = shiftImage({ root: root });\n          pushImage({\n            root: root,\n            props: props,\n            image: cloneCanvas(_imageView.image)\n          });\n        }\n        // if not, we can update the current image\n        else {\n          updateImage({ root: root, props: props });\n        }\n      }\n    };\n\n    var canCreateImageBitmap = function canCreateImageBitmap(file) {\n      // Firefox versions before 58 will freeze when running createImageBitmap\n      // in a Web Worker so we detect those versions and return false for support\n      var userAgent = window.navigator.userAgent;\n      var isFirefox = userAgent.match(/Firefox\\/([0-9]+)\\./);\n      var firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;\n      if (firefoxVersion !== null && firefoxVersion <= 58) return false;\n\n      return 'createImageBitmap' in window && isBitmap(file);\n    };\n\n    /**\n     * Write handler for when preview container has been created\n     */\n    var didCreatePreviewContainer = function didCreatePreviewContainer(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // determine image size of this item\n      getImageSize(fileURL, function(width, height) {\n        // we can now scale the panel to the final size\n        root.dispatch('DID_IMAGE_PREVIEW_CALCULATE_SIZE', {\n          id: id,\n          width: width,\n          height: height\n        });\n      });\n    };\n\n    var drawPreview = function drawPreview(_ref6) {\n      var root = _ref6.root,\n        props = _ref6.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // fallback\n      var loadPreviewFallback = function loadPreviewFallback() {\n        // let's scale the image in the main thread :(\n        loadImage(fileURL).then(previewImageLoaded);\n      };\n\n      // image is now ready\n      var previewImageLoaded = function previewImageLoaded(imageData) {\n        // the file url is no longer needed\n        URL.revokeObjectURL(fileURL);\n\n        // draw the scaled down version here and use that as source so bitmapdata can be closed\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap if orientation is incorrect\n        var width = imageData.width,\n          height = imageData.height;\n\n        // if no width or height, just return early.\n        if (!width || !height) return;\n\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref7 = [height, width];\n          width = _ref7[0];\n          height = _ref7[1];\n        }\n\n        // scale canvas based on pixel density\n        // we multiply by .75 as that creates smaller but still clear images on screens with high res displays\n        var pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);\n\n        // we want as much pixels to work with as possible,\n        // this multiplies the minimum image resolution,\n        // so when zooming in it doesn't get too blurry\n        var zoomFactor = root.query('GET_IMAGE_PREVIEW_ZOOM_FACTOR');\n\n        // imaeg scale factor\n        var scaleFactor = zoomFactor * pixelDensityFactor;\n\n        // calculate scaled preview image size\n        var previewImageRatio = height / width;\n\n        // calculate image preview height and width\n        var previewContainerWidth = root.rect.element.width;\n        var previewContainerHeight = root.rect.element.height;\n\n        var imageWidth = previewContainerWidth;\n        var imageHeight = imageWidth * previewImageRatio;\n\n        if (previewImageRatio > 1) {\n          imageWidth = Math.min(width, previewContainerWidth * scaleFactor);\n          imageHeight = imageWidth * previewImageRatio;\n        } else {\n          imageHeight = Math.min(height, previewContainerHeight * scaleFactor);\n          imageWidth = imageHeight / previewImageRatio;\n        }\n\n        // transfer to image tag so no canvas memory wasted on iOS\n        var previewImage = createPreviewImage(\n          imageData,\n          imageWidth,\n          imageHeight,\n          orientation\n        );\n\n        // done\n        var done = function done() {\n          // calculate average image color, disabled for now\n          var averageColor = root.query(\n            'GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR'\n          )\n            ? calculateAverageColor(data)\n            : null;\n          item.setMetadata('color', averageColor, true);\n\n          // data has been transferred to canvas ( if was ImageBitmap )\n          if ('close' in imageData) {\n            imageData.close();\n          }\n\n          // show the overlay\n          root.ref.overlayShadow.opacity = 1;\n\n          // create the first image\n          pushImage({ root: root, props: props, image: previewImage });\n        };\n\n        // apply filter\n        var filter = item.getMetadata('filter');\n        if (filter) {\n          applyFilter(root, filter, previewImage).then(done);\n        } else {\n          done();\n        }\n      };\n\n      // if we support scaling using createImageBitmap we use a worker\n      if (canCreateImageBitmap(item.file)) {\n        // let's scale the image in a worker\n        var worker = createWorker(BitmapWorker);\n\n        worker.post(\n          {\n            file: item.file\n          },\n\n          function(imageBitmap) {\n            // destroy worker\n            worker.terminate();\n\n            // no bitmap returned, must be something wrong,\n            // try the oldschool way\n            if (!imageBitmap) {\n              loadPreviewFallback();\n              return;\n            }\n\n            // yay we got our bitmap, let's continue showing the preview\n            previewImageLoaded(imageBitmap);\n          }\n        );\n      } else {\n        // create fallback preview\n        loadPreviewFallback();\n      }\n    };\n\n    /**\n     * Write handler for when the preview image is ready to be animated\n     */\n    var didDrawPreview = function didDrawPreview(_ref8) {\n      var root = _ref8.root;\n      // get last added image\n      var image = root.ref.images[root.ref.images.length - 1];\n      image.translateY = 0;\n      image.scaleX = 1.0;\n      image.scaleY = 1.0;\n      image.opacity = 1;\n    };\n\n    /**\n     * Write handler for when the preview has been loaded\n     */\n    var restoreOverlay = function restoreOverlay(_ref9) {\n      var root = _ref9.root;\n      root.ref.overlayShadow.opacity = 1;\n      root.ref.overlayError.opacity = 0;\n      root.ref.overlaySuccess.opacity = 0;\n    };\n\n    var didThrowError = function didThrowError(_ref10) {\n      var root = _ref10.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlayError.opacity = 1;\n    };\n\n    var didCompleteProcessing = function didCompleteProcessing(_ref11) {\n      var root = _ref11.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlaySuccess.opacity = 1;\n    };\n\n    /**\n     * Constructor\n     */\n    var create = function create(_ref12) {\n      var root = _ref12.root;\n      // image view\n      root.ref.images = [];\n\n      // the preview image data (we need this to filter the image)\n      root.ref.imageData = null;\n\n      // image bin\n      root.ref.imageViewBin = [];\n\n      // image overlays\n      root.ref.overlayShadow = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'idle'\n        })\n      );\n\n      root.ref.overlaySuccess = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'success'\n        })\n      );\n\n      root.ref.overlayError = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'failure'\n        })\n      );\n    };\n\n    return _.utils.createView({\n      name: 'image-preview-wrapper',\n      create: create,\n      styles: ['height'],\n      apis: ['height'],\n      destroy: function destroy(_ref13) {\n        var root = _ref13.root;\n        // we resize the image so memory on iOS 12 is released more quickly (it seems)\n        root.ref.images.forEach(function(imageView) {\n          imageView.image.width = 1;\n          imageView.image.height = 1;\n        });\n      },\n      didWriteView: function didWriteView(_ref14) {\n        var root = _ref14.root;\n        root.ref.images.forEach(function(imageView) {\n          imageView.dirty = false;\n        });\n      },\n      write: _.utils.createRoute(\n        {\n          // image preview stated\n          DID_IMAGE_PREVIEW_DRAW: didDrawPreview,\n          DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,\n          DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,\n          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,\n\n          // file states\n          DID_THROW_ITEM_LOAD_ERROR: didThrowError,\n          DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,\n          DID_THROW_ITEM_INVALID: didThrowError,\n          DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,\n          DID_START_ITEM_PROCESSING: restoreOverlay,\n          DID_REVERT_ITEM_PROCESSING: restoreOverlay\n        },\n\n        function(_ref15) {\n          var root = _ref15.root;\n          // views on death row\n          var viewsToRemove = root.ref.imageViewBin.filter(function(imageView) {\n            return imageView.opacity === 0;\n          });\n\n          // views to retain\n          root.ref.imageViewBin = root.ref.imageViewBin.filter(function(\n            imageView\n          ) {\n            return imageView.opacity > 0;\n          });\n\n          // remove these views\n          viewsToRemove.forEach(function(imageView) {\n            return removeImageView(root, imageView);\n          });\n          viewsToRemove.length = 0;\n        }\n      )\n    });\n  };\n\n  /**\n   * Image Preview Plugin\n   */\n  var plugin = function plugin(fpAPI) {\n    var addFilter = fpAPI.addFilter,\n      utils = fpAPI.utils;\n    var Type = utils.Type,\n      createRoute = utils.createRoute,\n      isFile = utils.isFile;\n\n    // imagePreviewView\n    var imagePreviewView = createImageWrapperView(fpAPI);\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      // only hook up to item view and only if is enabled for this cropper\n      if (!is('file') || !query('GET_ALLOW_IMAGE_PREVIEW')) return;\n\n      // create the image preview plugin, but only do so if the item is an image\n      var didLoadItem = function didLoadItem(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        var id = props.id;\n        var item = query('GET_ITEM', id);\n\n        // item could theoretically have been removed in the mean time\n        if (!item || !isFile(item.file) || item.archived) return;\n\n        // get the file object\n        var file = item.file;\n\n        // exit if this is not an image\n        if (!isPreviewableImage(file)) return;\n\n        // test if is filtered\n        if (!query('GET_IMAGE_PREVIEW_FILTER_ITEM')(item)) return;\n\n        // exit if image size is too high and no createImageBitmap support\n        // this would simply bring the browser to its knees and that is not what we want\n        var supportsCreateImageBitmap = 'createImageBitmap' in (window || {});\n        var maxPreviewFileSize = query('GET_IMAGE_PREVIEW_MAX_FILE_SIZE');\n        if (\n          !supportsCreateImageBitmap &&\n          maxPreviewFileSize &&\n          file.size > maxPreviewFileSize\n        )\n          return;\n\n        // set preview view\n        root.ref.imagePreview = view.appendChildView(\n          view.createChildView(imagePreviewView, { id: id })\n        );\n\n        // update height if is fixed\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (fixedPreviewHeight) {\n          root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n            id: item.id,\n            height: fixedPreviewHeight\n          });\n        }\n\n        // now ready\n        var queue =\n          !supportsCreateImageBitmap &&\n          file.size > query('GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE');\n        root.dispatch('DID_IMAGE_PREVIEW_CONTAINER_CREATE', { id: id }, queue);\n      };\n\n      var rescaleItem = function rescaleItem(root, props) {\n        if (!root.ref.imagePreview) return;\n        var id = props.id;\n\n        // get item\n        var item = root.query('GET_ITEM', { id: id });\n        if (!item) return;\n\n        // if is fixed height or panel has aspect ratio, exit here, height has already been defined\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var itemPanelAspectRatio = root.query('GET_ITEM_PANEL_ASPECT_RATIO');\n        var fixedHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (panelAspectRatio || itemPanelAspectRatio || fixedHeight) return;\n\n        // no data!\n        var _root$ref = root.ref,\n          imageWidth = _root$ref.imageWidth,\n          imageHeight = _root$ref.imageHeight;\n        if (!imageWidth || !imageHeight) return;\n\n        // get height min and max\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap of orientation is incorrect\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref2 = [imageHeight, imageWidth];\n          imageWidth = _ref2[0];\n          imageHeight = _ref2[1];\n        }\n\n        // scale up width and height when we're dealing with an SVG\n        if (!isBitmap(item.file) || root.query('GET_IMAGE_PREVIEW_UPSCALE')) {\n          var scalar = 2048 / imageWidth;\n          imageWidth *= scalar;\n          imageHeight *= scalar;\n        }\n\n        // image aspect ratio\n        var imageAspectRatio = imageHeight / imageWidth;\n\n        // we need the item to get to the crop size\n        var previewAspectRatio =\n          (item.getMetadata('crop') || {}).aspectRatio || imageAspectRatio;\n\n        // preview height range\n        var previewHeightMax = Math.max(\n          minPreviewHeight,\n          Math.min(imageHeight, maxPreviewHeight)\n        );\n\n        var itemWidth = root.rect.element.width;\n        var previewHeight = Math.min(\n          itemWidth * previewAspectRatio,\n          previewHeightMax\n        );\n\n        // request update to panel height\n        root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n          id: item.id,\n          height: previewHeight\n        });\n      };\n\n      var didResizeView = function didResizeView(_ref3) {\n        var root = _ref3.root;\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n        var root = _ref4.root,\n          action = _ref4.action;\n        if (action.change.key !== 'crop') return;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didCalculatePreviewSize = function didCalculatePreviewSize(_ref5) {\n        var root = _ref5.root,\n          action = _ref5.action;\n        // remember dimensions\n        root.ref.imageWidth = action.width;\n        root.ref.imageHeight = action.height;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n        root.ref.shouldDrawPreview = true;\n\n        // as image load could take a while and fire when draw loop is resting we need to give it a kick\n        root.dispatch('KICK');\n      };\n\n      // start writing\n      view.registerWriter(\n        createRoute(\n          {\n            DID_RESIZE_ROOT: didResizeView,\n            DID_STOP_RESIZE: didResizeView,\n            DID_LOAD_ITEM: didLoadItem,\n            DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,\n            DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata\n          },\n\n          function(_ref6) {\n            var root = _ref6.root,\n              props = _ref6.props;\n            // no preview view attached\n            if (!root.ref.imagePreview) return;\n\n            // don't do anything while hidden\n            if (root.rect.element.hidden) return;\n\n            // resize the item panel\n            if (root.ref.shouldRescale) {\n              rescaleItem(root, props);\n              root.ref.shouldRescale = false;\n            }\n\n            if (root.ref.shouldDrawPreview) {\n              // queue till next frame so we're sure the height has been applied this forces the draw image call inside the wrapper view to use the correct height\n              requestAnimationFrame(function() {\n                // this requestAnimationFrame nesting is horrible but it fixes an issue with 100hz displays on Chrome\n                // https://github.com/pqina/filepond-plugin-image-preview/issues/57\n                requestAnimationFrame(function() {\n                  root.dispatch('DID_FINISH_CALCULATE_PREVIEWSIZE', {\n                    id: props.id\n                  });\n                });\n              });\n\n              root.ref.shouldDrawPreview = false;\n            }\n          }\n        )\n      );\n    });\n\n    // expose plugin\n    return {\n      options: {\n        // Enable or disable image preview\n        allowImagePreview: [true, Type.BOOLEAN],\n\n        // filters file items to determine which are shown as preview\n        imagePreviewFilterItem: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ],\n\n        // Fixed preview height\n        imagePreviewHeight: [null, Type.INT],\n\n        // Min image height\n        imagePreviewMinHeight: [44, Type.INT],\n\n        // Max image height\n        imagePreviewMaxHeight: [256, Type.INT],\n\n        // Max size of preview file for when createImageBitmap is not supported\n        imagePreviewMaxFileSize: [null, Type.INT],\n\n        // The amount of extra pixels added to the image preview to allow comfortable zooming\n        imagePreviewZoomFactor: [2, Type.INT],\n\n        // Should we upscale small images to fit the max bounding box of the preview area\n        imagePreviewUpscale: [false, Type.BOOLEAN],\n\n        // Max size of preview file that we allow to try to instant preview if createImageBitmap is not supported, else image is queued for loading\n        imagePreviewMaxInstantPreviewFileSize: [1000000, Type.INT],\n\n        // Style of the transparancy indicator used behind images\n        imagePreviewTransparencyIndicator: [null, Type.STRING],\n\n        // Enables or disables reading average image color\n        imagePreviewCalculateAverageImageColor: [false, Type.BOOLEAN],\n\n        // Enables or disables the previewing of markup\n        imagePreviewMarkupShow: [true, Type.BOOLEAN],\n\n        // Allows filtering of markup to only show certain shapes\n        imagePreviewMarkupFilter: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sQ0FHZ0Q7QUFDdEQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLHlCQUF5QjtBQUNyRCxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbUNBQW1DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuanM/YWM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3IDQuNi4xMlxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkltYWdlUHJldmlldyA9IGZhY3RvcnkoKSkpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB0ZXN0IGlmIGZpbGUgaXMgb2YgdHlwZSBpbWFnZSBhbmQgY2FuIGJlIHZpZXdlZCBpbiBjYW52YXNcbiAgdmFyIGlzUHJldmlld2FibGVJbWFnZSA9IGZ1bmN0aW9uIGlzUHJldmlld2FibGVJbWFnZShmaWxlKSB7XG4gICAgcmV0dXJuIC9eaW1hZ2UvLnRlc3QoZmlsZS50eXBlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgPyAnc3ltYm9sJ1xuICAgICAgICAgIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbiAgZnVuY3Rpb24gX2pzeCh0eXBlLCBwcm9wcywga2V5LCBjaGlsZHJlbikge1xuICAgIGlmICghUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuICAgICAgICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIFN5bWJvbC5mb3IgJiZcbiAgICAgICAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgICAgIDB4ZWFjNztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMztcblxuICAgIGlmICghcHJvcHMgJiYgY2hpbGRyZW5MZW5ndGggIT09IDApIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBjaGlsZHJlbjogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAmJiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gZGVmYXVsdFByb3BzIHx8IHt9O1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGNoaWxkQXJyYXkgPSBuZXcgQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgM107XG4gICAgICB9XG5cbiAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsga2V5LFxuICAgICAgcmVmOiBudWxsLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgX293bmVyOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY0l0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgdmFyIG1ldGhvZDtcblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bd2FpdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gICAgdmFyIGZyb250LCBiYWNrO1xuXG4gICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHdyYXBwZWRBd2FpdCA/IHZhbHVlLndyYXBwZWQgOiB2YWx1ZSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgcmVzdW1lKCduZXh0JywgYXJnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyAncmV0dXJuJyA6ICdub3JtYWwnLCBhcmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0dGxlKCd0aHJvdycsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZnJvbnQgPSBmcm9udC5uZXh0O1xuXG4gICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IHNlbmQ7XG5cbiAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgfTtcblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndGhyb3cnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgncmV0dXJuJywgYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gICAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbm5lcltrZXldKHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcCgnbmV4dCcsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBpbm5lci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci50aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcHVtcCgncmV0dXJuJywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoXG4gICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgX25leHQsXG4gICAgICAgICAgICBfdGhyb3csXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAndGhyb3cnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMob2JqLCBkZXNjcykge1xuICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgb2JqZWN0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVzY3MpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IG9iamVjdFN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID1cbiAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICAgICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbicpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cbiAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICByaWdodCAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXVxuICAgICkge1xuICAgICAgcmV0dXJuIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0obGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlXG4gICAgICA/IG9ialxuICAgICAgOiB7XG4gICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID1cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpXG4gICAgICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX25ld0Fycm93Q2hlY2soaW5uZXJUaGlzLCBib3VuZFRoaXMpIHtcbiAgICBpZiAoaW5uZXJUaGlzICE9PSBib3VuZFRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbnN0YW50aWF0ZSBhbiBhcnJvdyBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3REZXN0cnVjdHVyaW5nRW1wdHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZGVzdHJ1Y3R1cmUgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgIHZhciBrZXksIGk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjYWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LnNldCkge1xuICAgICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICB2YXIgZGVzYztcblxuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgZGVzYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2RlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICAgIHZhciBzID0gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciB8fCB0YXJnZXQpO1xuXG4gICAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzZXQgcHJvcGVydHknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywge1xuICAgICAgICByYXc6IHtcbiAgICAgICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShzdHJpbmdzLCByYXcpIHtcbiAgICBpZiAoIXJhdykge1xuICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICB9XG5cbiAgICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZW1wb3JhbFJlZih2YWwsIG5hbWUpIHtcbiAgICBpZiAodmFsID09PSBfdGVtcG9yYWxVbmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihuYW1lICsgJyBpcyBub3QgZGVmaW5lZCAtIHRlbXBvcmFsIGRlYWQgem9uZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZWFkT25seUVycm9yKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgaXMgcmVhZC1vbmx5Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NOYW1lVERaRXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDbGFzcyBcIicgKyBuYW1lICsgJ1wiIGNhbm5vdCBiZSByZWZlcmVuY2VkIGluIGNvbXB1dGVkIHByb3BlcnR5IGtleXMuJ1xuICAgICk7XG4gIH1cblxuICB2YXIgX3RlbXBvcmFsVW5kZWZpbmVkID0ge307XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8XG4gICAgICBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fFxuICAgICAgX25vbkl0ZXJhYmxlUmVzdCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5TG9vc2UoYXJyLCBpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8XG4gICAgICBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKFxuICAgICAgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSAnW29iamVjdCBBcmd1bWVudHNdJ1xuICAgIClcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7XG4gICAgICAgICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpO1xuICAgICAgICBfbiA9IHRydWVcbiAgICAgICkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSAhPSBudWxsKSBfaVsncmV0dXJuJ10oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuXG4gICAgZm9yIChcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDtcbiAgICAgICEoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lO1xuXG4gICAgKSB7XG4gICAgICBfYXJyLnB1c2goX3N0ZXAudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NraXBGaXJzdEdlbmVyYXRvck5leHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaXQubmV4dCgpO1xuICAgICAgcmV0dXJuIGl0O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblxuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgJ2RlZmF1bHQnKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAnb2JqZWN0JykgcmV0dXJuIHJlcztcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0BAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChoaW50ID09PSAnc3RyaW5nJyA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsICdzdHJpbmcnKTtcblxuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArXG4gICAgICAgICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHNldCB0byB1c2UgbG9vc2UgbW9kZS4gJyArXG4gICAgICAgICdUbyB1c2UgcHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpbiBzcGVjIG1vZGUgd2l0aCBkZWNvcmF0b3JzLCB3YWl0IGZvciAnICtcbiAgICAgICAgJ3RoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgZGVjb3JhdG9ycyBpbiBzdGFnZSAyLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgIGlmICghZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7XG4gICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplclxuICAgICAgICA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KVxuICAgICAgICA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihcbiAgICB0YXJnZXQsXG4gICAgcHJvcGVydHksXG4gICAgZGVjb3JhdG9ycyxcbiAgICBkZXNjcmlwdG9yLFxuICAgIGNvbnRleHRcbiAgKSB7XG4gICAgdmFyIGRlc2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICAgIH0pO1xuICAgIGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlO1xuICAgIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICAgIGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikge1xuICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZGVzYyA9IGRlY29yYXRvcnNcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKGRlc2MsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7XG4gICAgICB9LCBkZXNjKTtcblxuICAgIGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkge1xuICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgIGRlc2MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9XG5cbiAgdmFyIGlkID0gMDtcblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUtleShuYW1lKSB7XG4gICAgcmV0dXJuICdfX3ByaXZhdGVfJyArIGlkKysgKyAnXycgKyBuYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VCYXNlKHJlY2VpdmVyLCBwcml2YXRlS2V5KSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVjZWl2ZXIsIHByaXZhdGVLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gdXNlIHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY2VpdmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgIH1cblxuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNHZXQoXG4gICAgcmVjZWl2ZXIsXG4gICAgY2xhc3NDb25zdHJ1Y3RvcixcbiAgICBkZXNjcmlwdG9yXG4gICkge1xuICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNTZXQoXG4gICAgcmVjZWl2ZXIsXG4gICAgY2xhc3NDb25zdHJ1Y3RvcixcbiAgICBkZXNjcmlwdG9yLFxuICAgIHZhbHVlXG4gICkge1xuICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2Q7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kU2V0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHN0YXRpYyBwcml2YXRlIGZpZWxkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7XG4gICAgdmFyIGFwaSA9IF9nZXREZWNvcmF0b3JzQXBpKCk7XG5cbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcGkgPSBtaXhpbnNbaV0oYXBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7XG4gICAgICBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICB9LCBzdXBlckNsYXNzKTtcbiAgICB2YXIgZGVjb3JhdGVkID0gYXBpLmRlY29yYXRlQ2xhc3MoXG4gICAgICBfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksXG4gICAgICBkZWNvcmF0b3JzXG4gICAgKTtcbiAgICBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIHJldHVybiBhcGkucnVuQ2xhc3NGaW5pc2hlcnMoci5GLCBkZWNvcmF0ZWQuZmluaXNoZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXREZWNvcmF0b3JzQXBpKCkge1xuICAgIF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbJ21ldGhvZCddLCBbJ2ZpZWxkJ11dLFxuICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uKE8sIGVsZW1lbnRzKSB7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSAnb3duJykge1xuICAgICAgICAgICAgICB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHM6IGZ1bmN0aW9uKEYsIGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwcm90byA9IEYucHJvdG90eXBlO1xuICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IGVsZW1lbnQucGxhY2VtZW50O1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVsZW1lbnQua2luZCA9PT0ga2luZCAmJlxuICAgICAgICAgICAgICAocGxhY2VtZW50ID09PSAnc3RhdGljJyB8fCBwbGFjZW1lbnQgPT09ICdwcm90b3R5cGUnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHBsYWNlbWVudCA9PT0gJ3N0YXRpYycgPyBGIDogcHJvdG87XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgZGVmaW5lQ2xhc3NFbGVtZW50OiBmdW5jdGlvbihyZWNlaXZlciwgZWxlbWVudCkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcblxuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSB7XG4gICAgICAgICAgdmFyIGluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjtcbiAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICB2YXIgbmV3RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuICAgICAgICB2YXIgcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICBzdGF0aWM6IFtdLFxuICAgICAgICAgIHByb3RvdHlwZTogW10sXG4gICAgICAgICAgb3duOiBbXVxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoIV9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSByZXR1cm4gbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHBsYWNlbWVudHNcbiAgICAgICAgICApO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5lbGVtZW50KTtcbiAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoLmFwcGx5KG5ld0VsZW1lbnRzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmV4dHJhcyk7XG4gICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghZGVjb3JhdG9ycykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50czogbmV3RWxlbWVudHMsXG4gICAgICAgICAgICBmaW5pc2hlcnM6IGZpbmlzaGVyc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kZWNvcmF0ZUNvbnN0cnVjdG9yKG5ld0VsZW1lbnRzLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCByZXN1bHQuZmluaXNoZXJzKTtcbiAgICAgICAgcmVzdWx0LmZpbmlzaGVycyA9IGZpbmlzaGVycztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbihlbGVtZW50LCBwbGFjZW1lbnRzLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcblxuICAgICAgICBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnQua2V5ICsgJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChlbGVtZW50LmtleSk7XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBwbGFjZW1lbnRzKSB7XG4gICAgICAgIHZhciBleHRyYXMgPSBbXTtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaSA+PSAwO1xuICAgICAgICAgIGktLVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuICAgICAgICAgIGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpO1xuICAgICAgICAgIHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRGaW5pc2hlckV4dHJhcyA9IHRoaXMudG9FbGVtZW50RmluaXNoZXJFeHRyYXMoXG4gICAgICAgICAgICAoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdFxuICAgICAgICAgICk7XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7XG5cbiAgICAgICAgICBpZiAobmV3RXh0cmFzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0V4dHJhcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcnM6IGZpbmlzaGVycyxcbiAgICAgICAgICBleHRyYXM6IGV4dHJhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpO1xuICAgICAgICAgIHZhciBlbGVtZW50c0FuZEZpbmlzaGVyID0gdGhpcy50b0NsYXNzRGVzY3JpcHRvcihcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9ialxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmaW5pc2hlcnMucHVzaChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ua2V5ID09PSBlbGVtZW50c1trXS5rZXkgJiZcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLnBsYWNlbWVudCA9PT0gZWxlbWVudHNba10ucGxhY2VtZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudHNbal0ua2V5ICsgJyknXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAga2luZDogZWxlbWVudC5raW5kLFxuICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBlbGVtZW50LnBsYWNlbWVudCxcbiAgICAgICAgICBkZXNjcmlwdG9yOiBlbGVtZW50LmRlc2NyaXB0b3JcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykgb2JqLmluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24oZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24oZWxlbWVudE9iamVjdCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnRPYmplY3QpO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnZmluaXNoZXInLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnZXh0cmFzJyxcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24oZWxlbWVudE9iamVjdCkge1xuICAgICAgICB2YXIga2luZCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LmtpbmQpO1xuXG4gICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyAmJiBraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICtcbiAgICAgICAgICAgICAgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArXG4gICAgICAgICAgICAgICcgLmtpbmQgXCInICtcbiAgICAgICAgICAgICAga2luZCArXG4gICAgICAgICAgICAgICdcIidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IF90b1Byb3BlcnR5S2V5KGVsZW1lbnRPYmplY3Qua2V5KTtcblxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gU3RyaW5nKGVsZW1lbnRPYmplY3QucGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAnc3RhdGljJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ3Byb3RvdHlwZScgJiZcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdvd24nXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArXG4gICAgICAgICAgICAgICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICtcbiAgICAgICAgICAgICAgJyB3aXRoIC5wbGFjZW1lbnQgXCInICtcbiAgICAgICAgICAgICAgcGxhY2VtZW50ICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgJ2VsZW1lbnRzJyxcbiAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICApO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBlbGVtZW50T2JqZWN0LFxuICAgICAgICAgICAgJ2luaXRpYWxpemVyJyxcbiAgICAgICAgICAgICdBIG1ldGhvZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAnc2V0JyxcbiAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnRPYmplY3QpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2ZpbmlzaGVyJyk7XG5cbiAgICAgICAgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZnJvbUNsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiAnY2xhc3MnLFxuICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LFxuICAgICAgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0EgY2xhc3MgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBcImNsYXNzXCIsIGJ1dCBhIGRlY29yYXRvcicgK1xuICAgICAgICAgICAgICAnIGNyZWF0ZWQgYSBjbGFzcyBkZXNjcmlwdG9yIHdpdGggLmtpbmQgXCInICtcbiAgICAgICAgICAgICAga2luZCArXG4gICAgICAgICAgICAgICdcIidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2tleScsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ3BsYWNlbWVudCcsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2Rlc2NyaXB0b3InLCAnQSBjbGFzcyBkZXNjcmlwdG9yJyk7XG4gICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdpbml0aWFsaXplcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2V4dHJhcycsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcblxuICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgJ2ZpbmlzaGVyJyk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24oY29uc3RydWN0b3IsIGZpbmlzaGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTtcblxuICAgICAgICAgIGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpbmlzaGVycyBtdXN0IHJldHVybiBhIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgIH0sXG4gICAgICBkaXNhbGxvd1Byb3BlcnR5OiBmdW5jdGlvbihvYmosIG5hbWUsIG9iamVjdFR5cGUpIHtcbiAgICAgICAgaWYgKG9ialtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArICcgcHJvcGVydHkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcGk7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IoZGVmKSB7XG4gICAgdmFyIGtleSA9IF90b1Byb3BlcnR5S2V5KGRlZi5rZXkpO1xuXG4gICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICBpZiAoZGVmLmtpbmQgPT09ICdtZXRob2QnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogZGVmLnZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnZ2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgZ2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHNldDogZGVmLnZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICBraW5kOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdmaWVsZCcgOiAnbWV0aG9kJyxcbiAgICAgIGtleToga2V5LFxuICAgICAgcGxhY2VtZW50OiBkZWYuc3RhdGljXG4gICAgICAgID8gJ3N0YXRpYydcbiAgICAgICAgOiBkZWYua2luZCA9PT0gJ2ZpZWxkJ1xuICAgICAgICA/ICdvd24nXG4gICAgICAgIDogJ3Byb3RvdHlwZScsXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yXG4gICAgfTtcbiAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykgZWxlbWVudC5pbml0aWFsaXplciA9IGRlZi52YWx1ZTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikge1xuICAgIGlmIChlbGVtZW50LmRlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG90aGVyLmRlc2NyaXB0b3IuZ2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5zZXQgPSBlbGVtZW50LmRlc2NyaXB0b3Iuc2V0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSBbXTtcblxuICAgIHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG90aGVyLmtpbmQgPT09ICdtZXRob2QnICYmXG4gICAgICAgIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBvdGhlcjtcblxuICAgICAgaWYgKFxuICAgICAgICBlbGVtZW50LmtpbmQgPT09ICdtZXRob2QnICYmXG4gICAgICAgIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKGVsZW1lbnQuZGVzY3JpcHRvcikgfHxcbiAgICAgICAgICBfaXNEYXRhRGVzY3JpcHRvcihvdGhlci5kZXNjcmlwdG9yKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkgfHwgX2hhc0RlY29yYXRvcnMob3RoZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICdEdXBsaWNhdGVkIG1ldGhvZHMgKCcgKyBlbGVtZW50LmtleSArIFwiKSBjYW4ndCBiZSBkZWNvcmF0ZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAndGhlIHNhbWUgcHJvcGVydHkgKCcgK1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5rZXkgK1xuICAgICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdGhlci5kZWNvcmF0b3JzID0gZWxlbWVudC5kZWNvcmF0b3JzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc0RlY29yYXRvcnMoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmRlY29yYXRvcnMgJiYgZWxlbWVudC5kZWNvcmF0b3JzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZGVzYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQocmVjZWl2ZXIsIHByaXZhdGVTZXQsIGZuKSB7XG4gICAgaWYgKCFwcml2YXRlU2V0LmhhcyhyZWNlaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kU2V0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byByZWFzc2lnbiBwcml2YXRlIG1ldGhvZCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3dyYXBSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgIF93cmFwUmVnRXhwID0gZnVuY3Rpb24ocmUsIGdyb3Vwcykge1xuICAgICAgcmV0dXJuIG5ldyBCYWJlbFJlZ0V4cChyZSwgZ3JvdXBzKTtcbiAgICB9O1xuXG4gICAgdmFyIF9SZWdFeHAgPSBfd3JhcE5hdGl2ZVN1cGVyKFJlZ0V4cCk7XG5cbiAgICB2YXIgX3N1cGVyID0gUmVnRXhwLnByb3RvdHlwZTtcblxuICAgIHZhciBfZ3JvdXBzID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBncm91cHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IF9SZWdFeHAuY2FsbCh0aGlzLCByZSk7XG5cbiAgICAgIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2luaGVyaXRzKEJhYmVsUmVnRXhwLCBfUmVnRXhwKTtcblxuICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQuZ3JvdXBzID0gYnVpbGRHcm91cHMocmVzdWx0LCB0aGlzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZVtTeW1ib2wucmVwbGFjZV0gPSBmdW5jdGlvbihzdHIsIHN1YnN0aXR1dGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBfZ3JvdXBzLmdldCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIHN1YnN0aXR1dGlvbi5yZXBsYWNlKC9cXCQ8KFtePl0rKT4vZywgZnVuY3Rpb24oXywgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICckJyArIGdyb3Vwc1tuYW1lXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9zdXBlcltTeW1ib2wucmVwbGFjZV0uY2FsbCh0aGlzLCBzdHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChidWlsZEdyb3VwcyhhcmdzLCBfdGhpcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlcltTeW1ib2wucmVwbGFjZV0uY2FsbCh0aGlzLCBzdHIsIHN1YnN0aXR1dGlvbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcbiAgICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZykucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgbmFtZSkge1xuICAgICAgICBncm91cHNbbmFtZV0gPSByZXN1bHRbZ1tuYW1lXV07XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHZhciB2ZWN0b3JNdWx0aXBseSA9IGZ1bmN0aW9uIHZlY3Rvck11bHRpcGx5KHYsIGFtb3VudCkge1xuICAgIHJldHVybiBjcmVhdGVWZWN0b3Iodi54ICogYW1vdW50LCB2LnkgKiBhbW91bnQpO1xuICB9O1xuXG4gIHZhciB2ZWN0b3JBZGQgPSBmdW5jdGlvbiB2ZWN0b3JBZGQoYSwgYikge1xuICAgIHJldHVybiBjcmVhdGVWZWN0b3IoYS54ICsgYi54LCBhLnkgKyBiLnkpO1xuICB9O1xuXG4gIHZhciB2ZWN0b3JOb3JtYWxpemUgPSBmdW5jdGlvbiB2ZWN0b3JOb3JtYWxpemUodikge1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSk7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWZWN0b3Iodi54IC8gbCwgdi55IC8gbCk7XG4gIH07XG5cbiAgdmFyIHZlY3RvclJvdGF0ZSA9IGZ1bmN0aW9uIHZlY3RvclJvdGF0ZSh2LCByYWRpYW5zLCBvcmlnaW4pIHtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgIHZhciB0ID0gY3JlYXRlVmVjdG9yKHYueCAtIG9yaWdpbi54LCB2LnkgLSBvcmlnaW4ueSk7XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3RvcihcbiAgICAgIG9yaWdpbi54ICsgY29zICogdC54IC0gc2luICogdC55LFxuICAgICAgb3JpZ2luLnkgKyBzaW4gKiB0LnggKyBjb3MgKiB0LnlcbiAgICApO1xuICB9O1xuXG4gIHZhciBjcmVhdGVWZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVWZWN0b3IoKSB7XG4gICAgdmFyIHggPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciB5ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gIH07XG5cbiAgdmFyIGdldE1hcmt1cFZhbHVlID0gZnVuY3Rpb24gZ2V0TWFya3VwVmFsdWUodmFsdWUsIHNpemUpIHtcbiAgICB2YXIgc2NhbGFyID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgYXhpcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgKiBzY2FsYXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdmFsdWUgKiAoYXhpcyA/IHNpemVbYXhpc10gOiBNYXRoLm1pbihzaXplLndpZHRoLCBzaXplLmhlaWdodCkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG5cbiAgdmFyIGdldE1hcmt1cFN0eWxlcyA9IGZ1bmN0aW9uIGdldE1hcmt1cFN0eWxlcyhtYXJrdXAsIHNpemUsIHNjYWxlKSB7XG4gICAgdmFyIGxpbmVTdHlsZSA9IG1hcmt1cC5ib3JkZXJTdHlsZSB8fCBtYXJrdXAubGluZVN0eWxlIHx8ICdzb2xpZCc7XG4gICAgdmFyIGZpbGwgPSBtYXJrdXAuYmFja2dyb3VuZENvbG9yIHx8IG1hcmt1cC5mb250Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICB2YXIgc3Ryb2tlID0gbWFya3VwLmJvcmRlckNvbG9yIHx8IG1hcmt1cC5saW5lQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSBnZXRNYXJrdXBWYWx1ZShcbiAgICAgIG1hcmt1cC5ib3JkZXJXaWR0aCB8fCBtYXJrdXAubGluZVdpZHRoLFxuICAgICAgc2l6ZSxcbiAgICAgIHNjYWxlXG4gICAgKTtcbiAgICB2YXIgbGluZUNhcCA9IG1hcmt1cC5saW5lQ2FwIHx8ICdyb3VuZCc7XG4gICAgdmFyIGxpbmVKb2luID0gbWFya3VwLmxpbmVKb2luIHx8ICdyb3VuZCc7XG4gICAgdmFyIGRhc2hlcyA9XG4gICAgICB0eXBlb2YgbGluZVN0eWxlID09PSAnc3RyaW5nJ1xuICAgICAgICA/ICcnXG4gICAgICAgIDogbGluZVN0eWxlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcmt1cFZhbHVlKHYsIHNpemUsIHNjYWxlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgIHZhciBvcGFjaXR5ID0gbWFya3VwLm9wYWNpdHkgfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgJ3N0cm9rZS1saW5lY2FwJzogbGluZUNhcCxcbiAgICAgICdzdHJva2UtbGluZWpvaW4nOiBsaW5lSm9pbixcbiAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCB8fCAwLFxuICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBkYXNoZXMsXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIGZpbGw6IGZpbGwsXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH07XG5cbiAgdmFyIGdldE1hcmt1cFJlY3QgPSBmdW5jdGlvbiBnZXRNYXJrdXBSZWN0KHJlY3QsIHNpemUpIHtcbiAgICB2YXIgc2NhbGFyID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICAgIHZhciBsZWZ0ID1cbiAgICAgIGdldE1hcmt1cFZhbHVlKHJlY3QueCwgc2l6ZSwgc2NhbGFyLCAnd2lkdGgnKSB8fFxuICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC5sZWZ0LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpO1xuICAgIHZhciB0b3AgPVxuICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC55LCBzaXplLCBzY2FsYXIsICdoZWlnaHQnKSB8fFxuICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC50b3AsIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuICAgIHZhciB3aWR0aCA9IGdldE1hcmt1cFZhbHVlKHJlY3Qud2lkdGgsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgdmFyIGhlaWdodCA9IGdldE1hcmt1cFZhbHVlKHJlY3QuaGVpZ2h0LCBzaXplLCBzY2FsYXIsICdoZWlnaHQnKTtcbiAgICB2YXIgcmlnaHQgPSBnZXRNYXJrdXBWYWx1ZShyZWN0LnJpZ2h0LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpO1xuICAgIHZhciBib3R0b20gPSBnZXRNYXJrdXBWYWx1ZShyZWN0LmJvdHRvbSwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoIWlzRGVmaW5lZCh0b3ApKSB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkgJiYgaXNEZWZpbmVkKGJvdHRvbSkpIHtcbiAgICAgICAgdG9wID0gc2l6ZS5oZWlnaHQgLSBoZWlnaHQgLSBib3R0b207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBib3R0b207XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0RlZmluZWQobGVmdCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQod2lkdGgpICYmIGlzRGVmaW5lZChyaWdodCkpIHtcbiAgICAgICAgbGVmdCA9IHNpemUud2lkdGggLSB3aWR0aCAtIHJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0KSAmJiBpc0RlZmluZWQocmlnaHQpKSB7XG4gICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCAtIGxlZnQgLSByaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChoZWlnaHQpKSB7XG4gICAgICBpZiAoaXNEZWZpbmVkKHRvcCkgJiYgaXNEZWZpbmVkKGJvdHRvbSkpIHtcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSB0b3AgLSBib3R0b207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiBsZWZ0IHx8IDAsXG4gICAgICB5OiB0b3AgfHwgMCxcbiAgICAgIHdpZHRoOiB3aWR0aCB8fCAwLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgMFxuICAgIH07XG4gIH07XG5cbiAgdmFyIHBvaW50c1RvUGF0aFNoYXBlID0gZnVuY3Rpb24gcG9pbnRzVG9QYXRoU2hhcGUocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50c1xuICAgICAgLm1hcChmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgLmNvbmNhdChpbmRleCA9PT0gMCA/ICdNJyA6ICdMJywgJyAnKVxuICAgICAgICAgIC5jb25jYXQocG9pbnQueCwgJyAnKVxuICAgICAgICAgIC5jb25jYXQocG9pbnQueSk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfTtcblxuICB2YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cltrZXldKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICB2YXIgc3ZnID0gZnVuY3Rpb24gc3ZnKHRhZywgYXR0cikge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHIpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgdXBkYXRlUmVjdCA9IGZ1bmN0aW9uIHVwZGF0ZVJlY3QoZWxlbWVudCkge1xuICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQucmVjdCwgZWxlbWVudC5zdHlsZXMpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRWxsaXBzZSA9IGZ1bmN0aW9uIHVwZGF0ZUVsbGlwc2UoZWxlbWVudCkge1xuICAgIHZhciBjeCA9IGVsZW1lbnQucmVjdC54ICsgZWxlbWVudC5yZWN0LndpZHRoICogMC41O1xuICAgIHZhciBjeSA9IGVsZW1lbnQucmVjdC55ICsgZWxlbWVudC5yZWN0LmhlaWdodCAqIDAuNTtcbiAgICB2YXIgcnggPSBlbGVtZW50LnJlY3Qud2lkdGggKiAwLjU7XG4gICAgdmFyIHJ5ID0gZWxlbWVudC5yZWN0LmhlaWdodCAqIDAuNTtcbiAgICByZXR1cm4gc2V0QXR0cmlidXRlcyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICByeDogcngsXG4gICAgICAgICAgcnk6IHJ5XG4gICAgICAgIH0sXG4gICAgICAgIGVsZW1lbnQuc3R5bGVzXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICB2YXIgSU1BR0VfRklUX1NUWUxFID0ge1xuICAgIGNvbnRhaW46ICd4TWlkWU1pZCBtZWV0JyxcbiAgICBjb3ZlcjogJ3hNaWRZTWlkIHNsaWNlJ1xuICB9O1xuXG4gIHZhciB1cGRhdGVJbWFnZSA9IGZ1bmN0aW9uIHVwZGF0ZUltYWdlKGVsZW1lbnQsIG1hcmt1cCkge1xuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBJTUFHRV9GSVRfU1RZTEVbbWFya3VwLmZpdF0gfHwgJ25vbmUnXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgdmFyIFRFWFRfQU5DSE9SID0ge1xuICAgIGxlZnQ6ICdzdGFydCcsXG4gICAgY2VudGVyOiAnbWlkZGxlJyxcbiAgICByaWdodDogJ2VuZCdcbiAgfTtcblxuICB2YXIgdXBkYXRlVGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZVRleHQoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgIHZhciBmb250U2l6ZSA9IGdldE1hcmt1cFZhbHVlKG1hcmt1cC5mb250U2l6ZSwgc2l6ZSwgc2NhbGUpO1xuICAgIHZhciBmb250RmFtaWx5ID0gbWFya3VwLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gbWFya3VwLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgdmFyIHRleHRBbGlnbiA9IFRFWFRfQU5DSE9SW21hcmt1cC50ZXh0QWxpZ25dIHx8ICdzdGFydCc7XG5cbiAgICBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQucmVjdCwgZWxlbWVudC5zdHlsZXMsIHtcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDAsXG4gICAgICAgICdmb250LXdlaWdodCc6IGZvbnRXZWlnaHQsXG4gICAgICAgICdmb250LXNpemUnOiBmb250U2l6ZSxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogdGV4dEFsaWduXG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyB1cGRhdGUgdGV4dFxuICAgIGlmIChlbGVtZW50LnRleHQgIT09IG1hcmt1cC50ZXh0KSB7XG4gICAgICBlbGVtZW50LnRleHQgPSBtYXJrdXAudGV4dDtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBtYXJrdXAudGV4dC5sZW5ndGggPyBtYXJrdXAudGV4dCA6ICcgJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUxpbmUgPSBmdW5jdGlvbiB1cGRhdGVMaW5lKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQucmVjdCwgZWxlbWVudC5zdHlsZXMsIHtcbiAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB2YXIgbGluZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1swXTtcbiAgICB2YXIgYmVnaW4gPSBlbGVtZW50LmNoaWxkTm9kZXNbMV07XG4gICAgdmFyIGVuZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1syXTtcblxuICAgIHZhciBvcmlnaW4gPSBlbGVtZW50LnJlY3Q7XG5cbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgeDogZWxlbWVudC5yZWN0LnggKyBlbGVtZW50LnJlY3Qud2lkdGgsXG4gICAgICB5OiBlbGVtZW50LnJlY3QueSArIGVsZW1lbnQucmVjdC5oZWlnaHRcbiAgICB9O1xuXG4gICAgc2V0QXR0cmlidXRlcyhsaW5lLCB7XG4gICAgICB4MTogb3JpZ2luLngsXG4gICAgICB5MTogb3JpZ2luLnksXG4gICAgICB4MjogdGFyZ2V0LngsXG4gICAgICB5MjogdGFyZ2V0LnlcbiAgICB9KTtcblxuICAgIGlmICghbWFya3VwLmxpbmVEZWNvcmF0aW9uKSByZXR1cm47XG5cbiAgICBiZWdpbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGVuZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgdmFyIHYgPSB2ZWN0b3JOb3JtYWxpemUoe1xuICAgICAgeDogdGFyZ2V0LnggLSBvcmlnaW4ueCxcbiAgICAgIHk6IHRhcmdldC55IC0gb3JpZ2luLnlcbiAgICB9KTtcblxuICAgIHZhciBsID0gZ2V0TWFya3VwVmFsdWUoMC4wNSwgc2l6ZSwgc2NhbGUpO1xuXG4gICAgaWYgKG1hcmt1cC5saW5lRGVjb3JhdGlvbi5pbmRleE9mKCdhcnJvdy1iZWdpbicpICE9PSAtMSkge1xuICAgICAgdmFyIGFycm93QmVnaW5Sb3RhdGlvblBvaW50ID0gdmVjdG9yTXVsdGlwbHkodiwgbCk7XG4gICAgICB2YXIgYXJyb3dCZWdpbkNlbnRlciA9IHZlY3RvckFkZChvcmlnaW4sIGFycm93QmVnaW5Sb3RhdGlvblBvaW50KTtcbiAgICAgIHZhciBhcnJvd0JlZ2luQSA9IHZlY3RvclJvdGF0ZShvcmlnaW4sIDIsIGFycm93QmVnaW5DZW50ZXIpO1xuICAgICAgdmFyIGFycm93QmVnaW5CID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgLTIsIGFycm93QmVnaW5DZW50ZXIpO1xuXG4gICAgICBzZXRBdHRyaWJ1dGVzKGJlZ2luLCB7XG4gICAgICAgIHN0eWxlOiAnZGlzcGxheTpibG9jazsnLFxuICAgICAgICBkOiAnTSdcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5BLngsICcsJylcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5BLnksICcgTCcpXG4gICAgICAgICAgLmNvbmNhdChvcmlnaW4ueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQob3JpZ2luLnksICcgTCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0JlZ2luQi54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0JlZ2luQi55KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmt1cC5saW5lRGVjb3JhdGlvbi5pbmRleE9mKCdhcnJvdy1lbmQnKSAhPT0gLTEpIHtcbiAgICAgIHZhciBhcnJvd0VuZFJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCAtbCk7XG4gICAgICB2YXIgYXJyb3dFbmRDZW50ZXIgPSB2ZWN0b3JBZGQodGFyZ2V0LCBhcnJvd0VuZFJvdGF0aW9uUG9pbnQpO1xuICAgICAgdmFyIGFycm93RW5kQSA9IHZlY3RvclJvdGF0ZSh0YXJnZXQsIDIsIGFycm93RW5kQ2VudGVyKTtcbiAgICAgIHZhciBhcnJvd0VuZEIgPSB2ZWN0b3JSb3RhdGUodGFyZ2V0LCAtMiwgYXJyb3dFbmRDZW50ZXIpO1xuXG4gICAgICBzZXRBdHRyaWJ1dGVzKGVuZCwge1xuICAgICAgICBzdHlsZTogJ2Rpc3BsYXk6YmxvY2s7JyxcbiAgICAgICAgZDogJ00nXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEEueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQoYXJyb3dFbmRBLnksICcgTCcpXG4gICAgICAgICAgLmNvbmNhdCh0YXJnZXQueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQodGFyZ2V0LnksICcgTCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEIueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQoYXJyb3dFbmRCLnkpXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBhdGggPSBmdW5jdGlvbiB1cGRhdGVQYXRoKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQuc3R5bGVzLCB7XG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgZDogcG9pbnRzVG9QYXRoU2hhcGUoXG4gICAgICAgICAgbWFya3VwLnBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IGdldE1hcmt1cFZhbHVlKHBvaW50LngsIHNpemUsIHNjYWxlLCAnd2lkdGgnKSxcbiAgICAgICAgICAgICAgeTogZ2V0TWFya3VwVmFsdWUocG9pbnQueSwgc2l6ZSwgc2NhbGUsICdoZWlnaHQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gY3JlYXRlU2hhcGUobm9kZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihtYXJrdXApIHtcbiAgICAgIHJldHVybiBzdmcobm9kZSwgeyBpZDogbWFya3VwLmlkIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUltYWdlID0gZnVuY3Rpb24gY3JlYXRlSW1hZ2UobWFya3VwKSB7XG4gICAgdmFyIHNoYXBlID0gc3ZnKCdpbWFnZScsIHtcbiAgICAgIGlkOiBtYXJrdXAuaWQsXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsXG4gICAgICBvcGFjaXR5OiAnMCdcbiAgICB9KTtcblxuICAgIHNoYXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgbWFya3VwLm9wYWNpdHkgfHwgMSk7XG4gICAgfTtcbiAgICBzaGFwZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAgICd4bGluazpocmVmJyxcbiAgICAgIG1hcmt1cC5zcmNcbiAgICApO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTGluZSA9IGZ1bmN0aW9uIGNyZWF0ZUxpbmUobWFya3VwKSB7XG4gICAgdmFyIHNoYXBlID0gc3ZnKCdnJywge1xuICAgICAgaWQ6IG1hcmt1cC5pZCxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJ1xuICAgIH0pO1xuXG4gICAgdmFyIGxpbmUgPSBzdmcoJ2xpbmUnKTtcbiAgICBzaGFwZS5hcHBlbmRDaGlsZChsaW5lKTtcblxuICAgIHZhciBiZWdpbiA9IHN2ZygncGF0aCcpO1xuICAgIHNoYXBlLmFwcGVuZENoaWxkKGJlZ2luKTtcblxuICAgIHZhciBlbmQgPSBzdmcoJ3BhdGgnKTtcbiAgICBzaGFwZS5hcHBlbmRDaGlsZChlbmQpO1xuXG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHZhciBDUkVBVEVfVFlQRV9ST1VURVMgPSB7XG4gICAgaW1hZ2U6IGNyZWF0ZUltYWdlLFxuICAgIHJlY3Q6IGNyZWF0ZVNoYXBlKCdyZWN0JyksXG4gICAgZWxsaXBzZTogY3JlYXRlU2hhcGUoJ2VsbGlwc2UnKSxcbiAgICB0ZXh0OiBjcmVhdGVTaGFwZSgndGV4dCcpLFxuICAgIHBhdGg6IGNyZWF0ZVNoYXBlKCdwYXRoJyksXG4gICAgbGluZTogY3JlYXRlTGluZVxuICB9O1xuXG4gIHZhciBVUERBVEVfVFlQRV9ST1VURVMgPSB7XG4gICAgcmVjdDogdXBkYXRlUmVjdCxcbiAgICBlbGxpcHNlOiB1cGRhdGVFbGxpcHNlLFxuICAgIGltYWdlOiB1cGRhdGVJbWFnZSxcbiAgICB0ZXh0OiB1cGRhdGVUZXh0LFxuICAgIHBhdGg6IHVwZGF0ZVBhdGgsXG4gICAgbGluZTogdXBkYXRlTGluZVxuICB9O1xuXG4gIHZhciBjcmVhdGVNYXJrdXBCeVR5cGUgPSBmdW5jdGlvbiBjcmVhdGVNYXJrdXBCeVR5cGUodHlwZSwgbWFya3VwKSB7XG4gICAgcmV0dXJuIENSRUFURV9UWVBFX1JPVVRFU1t0eXBlXShtYXJrdXApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVNYXJrdXBCeVR5cGUgPSBmdW5jdGlvbiB1cGRhdGVNYXJrdXBCeVR5cGUoXG4gICAgZWxlbWVudCxcbiAgICB0eXBlLFxuICAgIG1hcmt1cCxcbiAgICBzaXplLFxuICAgIHNjYWxlXG4gICkge1xuICAgIGlmICh0eXBlICE9PSAncGF0aCcpIHtcbiAgICAgIGVsZW1lbnQucmVjdCA9IGdldE1hcmt1cFJlY3QobWFya3VwLCBzaXplLCBzY2FsZSk7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVzID0gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xuICAgIFVQREFURV9UWVBFX1JPVVRFU1t0eXBlXShlbGVtZW50LCBtYXJrdXAsIHNpemUsIHNjYWxlKTtcbiAgfTtcblxuICB2YXIgTUFSS1VQX1JFQ1QgPSBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnbGVmdCcsXG4gICAgJ3RvcCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYm90dG9tJyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnXG4gIF07XG5cbiAgdmFyIHRvT3B0aW9uYWxGcmFjdGlvbiA9IGZ1bmN0aW9uIHRvT3B0aW9uYWxGcmFjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC8lLy50ZXN0KHZhbHVlKVxuICAgICAgPyBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgICAgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBhZGRzIGRlZmF1bHQgbWFya3VwIHByb3BlcnRpZXMsIGNsb25lcyBtYXJrdXBcbiAgdmFyIHByZXBhcmVNYXJrdXAgPSBmdW5jdGlvbiBwcmVwYXJlTWFya3VwKG1hcmt1cCkge1xuICAgIHZhciBfbWFya3VwID0gX3NsaWNlZFRvQXJyYXkobWFya3VwLCAyKSxcbiAgICAgIHR5cGUgPSBfbWFya3VwWzBdLFxuICAgICAgcHJvcHMgPSBfbWFya3VwWzFdO1xuXG4gICAgdmFyIHJlY3QgPSBwcm9wcy5wb2ludHNcbiAgICAgID8ge31cbiAgICAgIDogTUFSS1VQX1JFQ1QucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICBwcmV2W2N1cnJdID0gdG9PcHRpb25hbEZyYWN0aW9uKHByb3BzW2N1cnJdKTtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwge30pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgekluZGV4OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByZWN0XG4gICAgICApXG4gICAgXTtcbiAgfTtcblxuICB2YXIgc29ydE1hcmt1cEJ5WkluZGV4ID0gZnVuY3Rpb24gc29ydE1hcmt1cEJ5WkluZGV4KGEsIGIpIHtcbiAgICBpZiAoYVsxXS56SW5kZXggPiBiWzFdLnpJbmRleCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhWzFdLnpJbmRleCA8IGJbMV0uekluZGV4KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIHZhciBjcmVhdGVNYXJrdXBWaWV3ID0gZnVuY3Rpb24gY3JlYXRlTWFya3VwVmlldyhfKSB7XG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtcHJldmlldy1tYXJrdXAnLFxuICAgICAgdGFnOiAnc3ZnJyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWyd3aWR0aCcsICdoZWlnaHQnLCAnY3JvcCcsICdtYXJrdXAnLCAncmVzaXplJywgJ2RpcnR5J11cbiAgICAgIH0sXG5cbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICBpZiAoIXByb3BzLmRpcnR5KSByZXR1cm47XG4gICAgICAgIHZhciBjcm9wID0gcHJvcHMuY3JvcCxcbiAgICAgICAgICByZXNpemUgPSBwcm9wcy5yZXNpemUsXG4gICAgICAgICAgbWFya3VwID0gcHJvcHMubWFya3VwO1xuXG4gICAgICAgIHZhciB2aWV3V2lkdGggPSBwcm9wcy53aWR0aDtcbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGNyb3BXaWR0aCA9IGNyb3Aud2lkdGg7XG4gICAgICAgIHZhciBjcm9wSGVpZ2h0ID0gY3JvcC5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHJlc2l6ZSkge1xuICAgICAgICAgIHZhciBfc2l6ZSA9IHJlc2l6ZS5zaXplO1xuXG4gICAgICAgICAgdmFyIG91dHB1dFdpZHRoID0gX3NpemUgJiYgX3NpemUud2lkdGg7XG4gICAgICAgICAgdmFyIG91dHB1dEhlaWdodCA9IF9zaXplICYmIF9zaXplLmhlaWdodDtcbiAgICAgICAgICB2YXIgb3V0cHV0Rml0ID0gcmVzaXplLm1vZGU7XG4gICAgICAgICAgdmFyIG91dHB1dFVwc2NhbGUgPSByZXNpemUudXBzY2FsZTtcblxuICAgICAgICAgIGlmIChvdXRwdXRXaWR0aCAmJiAhb3V0cHV0SGVpZ2h0KSBvdXRwdXRIZWlnaHQgPSBvdXRwdXRXaWR0aDtcbiAgICAgICAgICBpZiAob3V0cHV0SGVpZ2h0ICYmICFvdXRwdXRXaWR0aCkgb3V0cHV0V2lkdGggPSBvdXRwdXRIZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgc2hvdWxkVXBzY2FsZSA9XG4gICAgICAgICAgICBjcm9wV2lkdGggPCBvdXRwdXRXaWR0aCAmJiBjcm9wSGVpZ2h0IDwgb3V0cHV0SGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKCFzaG91bGRVcHNjYWxlIHx8IChzaG91bGRVcHNjYWxlICYmIG91dHB1dFVwc2NhbGUpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFyV2lkdGggPSBvdXRwdXRXaWR0aCAvIGNyb3BXaWR0aDtcbiAgICAgICAgICAgIHZhciBzY2FsYXJIZWlnaHQgPSBvdXRwdXRIZWlnaHQgLyBjcm9wSGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAob3V0cHV0Rml0ID09PSAnZm9yY2UnKSB7XG4gICAgICAgICAgICAgIGNyb3BXaWR0aCA9IG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICBjcm9wSGVpZ2h0ID0gb3V0cHV0SGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxhcjtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dEZpdCA9PT0gJ2NvdmVyJykge1xuICAgICAgICAgICAgICAgIHNjYWxhciA9IE1hdGgubWF4KHNjYWxhcldpZHRoLCBzY2FsYXJIZWlnaHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dEZpdCA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgICAgICAgICAgc2NhbGFyID0gTWF0aC5taW4oc2NhbGFyV2lkdGgsIHNjYWxhckhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3JvcFdpZHRoID0gY3JvcFdpZHRoICogc2NhbGFyO1xuICAgICAgICAgICAgICBjcm9wSGVpZ2h0ID0gY3JvcEhlaWdodCAqIHNjYWxhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aDogdmlld1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlld0hlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS53aWR0aCk7XG4gICAgICAgIHJvb3QuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbih2aWV3V2lkdGggLyBjcm9wV2lkdGgsIHZpZXdIZWlnaHQgLyBjcm9wSGVpZ2h0KTtcblxuICAgICAgICAvLyBjbGVhclxuICAgICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgLy8gZ2V0IGZpbHRlclxuICAgICAgICB2YXIgbWFya3VwRmlsdGVyID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFSS1VQX0ZJTFRFUicpO1xuXG4gICAgICAgIC8vIGRyYXcgbmV3XG4gICAgICAgIG1hcmt1cFxuICAgICAgICAgIC5maWx0ZXIobWFya3VwRmlsdGVyKVxuICAgICAgICAgIC5tYXAocHJlcGFyZU1hcmt1cClcbiAgICAgICAgICAuc29ydChzb3J0TWFya3VwQnlaSW5kZXgpXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWFya3VwKSB7XG4gICAgICAgICAgICB2YXIgX21hcmt1cCA9IF9zbGljZWRUb0FycmF5KG1hcmt1cCwgMiksXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWFya3VwWzBdLFxuICAgICAgICAgICAgICBzZXR0aW5ncyA9IF9tYXJrdXBbMV07XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZVxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVNYXJrdXBCeVR5cGUodHlwZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgIHVwZGF0ZU1hcmt1cEJ5VHlwZShlbGVtZW50LCB0eXBlLCBzZXR0aW5ncywgc2l6ZSwgc2NhbGUpO1xuXG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlVmVjdG9yJDEgPSBmdW5jdGlvbiBjcmVhdGVWZWN0b3IoeCwgeSkge1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfTtcblxuICB2YXIgdmVjdG9yRG90ID0gZnVuY3Rpb24gdmVjdG9yRG90KGEsIGIpIHtcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55O1xuICB9O1xuXG4gIHZhciB2ZWN0b3JTdWJ0cmFjdCA9IGZ1bmN0aW9uIHZlY3RvclN1YnRyYWN0KGEsIGIpIHtcbiAgICByZXR1cm4gY3JlYXRlVmVjdG9yJDEoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xuICB9O1xuXG4gIHZhciB2ZWN0b3JEaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiB2ZWN0b3JEaXN0YW5jZVNxdWFyZWQoYSwgYikge1xuICAgIHJldHVybiB2ZWN0b3JEb3QodmVjdG9yU3VidHJhY3QoYSwgYiksIHZlY3RvclN1YnRyYWN0KGEsIGIpKTtcbiAgfTtcblxuICB2YXIgdmVjdG9yRGlzdGFuY2UgPSBmdW5jdGlvbiB2ZWN0b3JEaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWN0b3JEaXN0YW5jZVNxdWFyZWQoYSwgYikpO1xuICB9O1xuXG4gIHZhciBnZXRPZmZzZXRQb2ludE9uRWRnZSA9IGZ1bmN0aW9uIGdldE9mZnNldFBvaW50T25FZGdlKGxlbmd0aCwgcm90YXRpb24pIHtcbiAgICB2YXIgYSA9IGxlbmd0aDtcblxuICAgIHZhciBBID0gMS41NzA3OTYzMjY3OTQ4OTY2O1xuICAgIHZhciBCID0gcm90YXRpb247XG4gICAgdmFyIEMgPSAxLjU3MDc5NjMyNjc5NDg5NjYgLSByb3RhdGlvbjtcblxuICAgIHZhciBzaW5BID0gTWF0aC5zaW4oQSk7XG4gICAgdmFyIHNpbkIgPSBNYXRoLnNpbihCKTtcbiAgICB2YXIgc2luQyA9IE1hdGguc2luKEMpO1xuICAgIHZhciBjb3NDID0gTWF0aC5jb3MoQyk7XG4gICAgdmFyIHJhdGlvID0gYSAvIHNpbkE7XG4gICAgdmFyIGIgPSByYXRpbyAqIHNpbkI7XG4gICAgdmFyIGMgPSByYXRpbyAqIHNpbkM7XG5cbiAgICByZXR1cm4gY3JlYXRlVmVjdG9yJDEoY29zQyAqIGIsIGNvc0MgKiBjKTtcbiAgfTtcblxuICB2YXIgZ2V0Um90YXRlZFJlY3RTaXplID0gZnVuY3Rpb24gZ2V0Um90YXRlZFJlY3RTaXplKHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgdmFyIHcgPSByZWN0LndpZHRoO1xuICAgIHZhciBoID0gcmVjdC5oZWlnaHQ7XG5cbiAgICB2YXIgaG9yID0gZ2V0T2Zmc2V0UG9pbnRPbkVkZ2Uodywgcm90YXRpb24pO1xuICAgIHZhciB2ZXIgPSBnZXRPZmZzZXRQb2ludE9uRWRnZShoLCByb3RhdGlvbik7XG5cbiAgICB2YXIgdGwgPSBjcmVhdGVWZWN0b3IkMShyZWN0LnggKyBNYXRoLmFicyhob3IueCksIHJlY3QueSAtIE1hdGguYWJzKGhvci55KSk7XG5cbiAgICB2YXIgdHIgPSBjcmVhdGVWZWN0b3IkMShcbiAgICAgIHJlY3QueCArIHJlY3Qud2lkdGggKyBNYXRoLmFicyh2ZXIueSksXG4gICAgICByZWN0LnkgKyBNYXRoLmFicyh2ZXIueClcbiAgICApO1xuXG4gICAgdmFyIGJsID0gY3JlYXRlVmVjdG9yJDEoXG4gICAgICByZWN0LnggLSBNYXRoLmFicyh2ZXIueSksXG4gICAgICByZWN0LnkgKyByZWN0LmhlaWdodCAtIE1hdGguYWJzKHZlci54KVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHZlY3RvckRpc3RhbmNlKHRsLCB0ciksXG4gICAgICBoZWlnaHQ6IHZlY3RvckRpc3RhbmNlKHRsLCBibClcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVDYW52YXNTaXplID0gZnVuY3Rpb24gY2FsY3VsYXRlQ2FudmFzU2l6ZShcbiAgICBpbWFnZSxcbiAgICBjYW52YXNBc3BlY3RSYXRpb1xuICApIHtcbiAgICB2YXIgem9vbSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGFjdHVhbCBwaXhlbHMgb24geCBhbmQgeSBheGlzXG4gICAgdmFyIGNhbnZhc1dpZHRoID0gMTtcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY2FudmFzQXNwZWN0UmF0aW87XG4gICAgdmFyIGltZ1dpZHRoID0gMTtcbiAgICB2YXIgaW1nSGVpZ2h0ID0gaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBpZiAoaW1nSGVpZ2h0ID4gY2FudmFzSGVpZ2h0KSB7XG4gICAgICBpbWdIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBpbWdXaWR0aCA9IGltZ0hlaWdodCAvIGltYWdlQXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgdmFyIHNjYWxhciA9IE1hdGgubWF4KGNhbnZhc1dpZHRoIC8gaW1nV2lkdGgsIGNhbnZhc0hlaWdodCAvIGltZ0hlaWdodCk7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGggLyAoem9vbSAqIHNjYWxhciAqIGltZ1dpZHRoKTtcbiAgICB2YXIgaGVpZ2h0ID0gd2lkdGggKiBjYW52YXNBc3BlY3RSYXRpbztcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldEltYWdlUmVjdFpvb21GYWN0b3IgPSBmdW5jdGlvbiBnZXRJbWFnZVJlY3Rab29tRmFjdG9yKFxuICAgIGltYWdlUmVjdCxcbiAgICBjcm9wUmVjdCxcbiAgICByb3RhdGlvbixcbiAgICBjZW50ZXJcbiAgKSB7XG4gICAgLy8gY2FsY3VsYXRlIGF2YWlsYWJsZSBzcGFjZSByb3VuZCBpbWFnZSBjZW50ZXIgcG9zaXRpb25cbiAgICB2YXIgY3ggPSBjZW50ZXIueCA+IDAuNSA/IDEgLSBjZW50ZXIueCA6IGNlbnRlci54O1xuICAgIHZhciBjeSA9IGNlbnRlci55ID4gMC41ID8gMSAtIGNlbnRlci55IDogY2VudGVyLnk7XG4gICAgdmFyIGltYWdlV2lkdGggPSBjeCAqIDIgKiBpbWFnZVJlY3Qud2lkdGg7XG4gICAgdmFyIGltYWdlSGVpZ2h0ID0gY3kgKiAyICogaW1hZ2VSZWN0LmhlaWdodDtcblxuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGVkIGNyb3AgcmVjdGFuZ2xlIHNpemVcbiAgICB2YXIgcm90YXRlZENyb3BTaXplID0gZ2V0Um90YXRlZFJlY3RTaXplKGNyb3BSZWN0LCByb3RhdGlvbik7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2NhbGFyIHJlcXVpcmVkIHRvIGZpdCBpbWFnZVxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIHJvdGF0ZWRDcm9wU2l6ZS53aWR0aCAvIGltYWdlV2lkdGgsXG4gICAgICByb3RhdGVkQ3JvcFNpemUuaGVpZ2h0IC8gaW1hZ2VIZWlnaHRcbiAgICApO1xuICB9O1xuXG4gIHZhciBnZXRDZW50ZXJlZENyb3BSZWN0ID0gZnVuY3Rpb24gZ2V0Q2VudGVyZWRDcm9wUmVjdChcbiAgICBjb250YWluZXIsXG4gICAgYXNwZWN0UmF0aW9cbiAgKSB7XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB3aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgIGlmIChoZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgdmFyIHggPSAoY29udGFpbmVyLndpZHRoIC0gd2lkdGgpICogMC41O1xuICAgIHZhciB5ID0gKGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQpICogMC41O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRDdXJyZW50Q3JvcFNpemUgPSBmdW5jdGlvbiBnZXRDdXJyZW50Q3JvcFNpemUoaW1hZ2VTaXplKSB7XG4gICAgdmFyIGNyb3AgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgem9vbSA9IGNyb3Auem9vbSxcbiAgICAgIHJvdGF0aW9uID0gY3JvcC5yb3RhdGlvbixcbiAgICAgIGNlbnRlciA9IGNyb3AuY2VudGVyLFxuICAgICAgYXNwZWN0UmF0aW8gPSBjcm9wLmFzcGVjdFJhdGlvO1xuXG4gICAgaWYgKCFhc3BlY3RSYXRpbykgYXNwZWN0UmF0aW8gPSBpbWFnZVNpemUuaGVpZ2h0IC8gaW1hZ2VTaXplLndpZHRoO1xuXG4gICAgdmFyIGNhbnZhc1NpemUgPSBjYWxjdWxhdGVDYW52YXNTaXplKGltYWdlU2l6ZSwgYXNwZWN0UmF0aW8sIHpvb20pO1xuXG4gICAgdmFyIGNhbnZhc0NlbnRlciA9IHtcbiAgICAgIHg6IGNhbnZhc1NpemUud2lkdGggKiAwLjUsXG4gICAgICB5OiBjYW52YXNTaXplLmhlaWdodCAqIDAuNVxuICAgIH07XG5cbiAgICB2YXIgc3RhZ2UgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBjYW52YXNTaXplLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgIGNlbnRlcjogY2FudmFzQ2VudGVyXG4gICAgfTtcblxuICAgIHZhciBzaG91bGRMaW1pdCA9IHR5cGVvZiBjcm9wLnNjYWxlVG9GaXQgPT09ICd1bmRlZmluZWQnIHx8IGNyb3Auc2NhbGVUb0ZpdDtcblxuICAgIHZhciBzdGFnZVpvb21GYWN0b3IgPSBnZXRJbWFnZVJlY3Rab29tRmFjdG9yKFxuICAgICAgaW1hZ2VTaXplLFxuICAgICAgZ2V0Q2VudGVyZWRDcm9wUmVjdChzdGFnZSwgYXNwZWN0UmF0aW8pLFxuICAgICAgcm90YXRpb24sXG4gICAgICBzaG91bGRMaW1pdCA/IGNlbnRlciA6IHsgeDogMC41LCB5OiAwLjUgfVxuICAgICk7XG5cbiAgICB2YXIgc2NhbGUgPSB6b29tICogc3RhZ2Vab29tRmFjdG9yO1xuXG4gICAgLy8gc3RhcnQgZHJhd2luZ1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aEZsb2F0OiBjYW52YXNTaXplLndpZHRoIC8gc2NhbGUsXG4gICAgICBoZWlnaHRGbG9hdDogY2FudmFzU2l6ZS5oZWlnaHQgLyBzY2FsZSxcbiAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGNhbnZhc1NpemUud2lkdGggLyBzY2FsZSksXG4gICAgICBoZWlnaHQ6IE1hdGgucm91bmQoY2FudmFzU2l6ZS5oZWlnaHQgLyBzY2FsZSlcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMgPSB7XG4gICAgdHlwZTogJ3NwcmluZycsXG4gICAgc3RpZmZuZXNzOiAwLjUsXG4gICAgZGFtcGluZzogMC40NSxcbiAgICBtYXNzOiAxMFxuICB9O1xuXG4gIC8vIGRvZXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZmxpcHBpbmdcbiAgdmFyIGNyZWF0ZUJpdG1hcFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVCaXRtYXBWaWV3KF8pIHtcbiAgICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdpbWFnZS1iaXRtYXAnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIG1peGluczogeyBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWSddIH0sXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChwcm9wcy5pbWFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gc2hpZnRzIGFuZCByb3RhdGVzIGltYWdlXG4gIHZhciBjcmVhdGVJbWFnZUNhbnZhc1dyYXBwZXIgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZUNhbnZhc1dyYXBwZXIoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLWNhbnZhcy13cmFwcGVyJyxcbiAgICAgIHRhZzogJ2RpdicsXG4gICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnY3JvcCcsICd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgICAgICBzdHlsZXM6IFtcbiAgICAgICAgICAnb3JpZ2luWCcsXG4gICAgICAgICAgJ29yaWdpblknLFxuICAgICAgICAgICd0cmFuc2xhdGVYJyxcbiAgICAgICAgICAndHJhbnNsYXRlWScsXG4gICAgICAgICAgJ3NjYWxlWCcsXG4gICAgICAgICAgJ3NjYWxlWScsXG4gICAgICAgICAgJ3JvdGF0ZVonXG4gICAgICAgIF0sXG5cbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgIG9yaWdpblg6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBvcmlnaW5ZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgc2NhbGVYOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgc2NhbGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgdHJhbnNsYXRlWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICByb3RhdGVaOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFNcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICAgIHByb3BzLndpZHRoID0gcHJvcHMuaW1hZ2Uud2lkdGg7XG4gICAgICAgIHByb3BzLmhlaWdodCA9IHByb3BzLmltYWdlLmhlaWdodDtcbiAgICAgICAgcm9vdC5yZWYuYml0bWFwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoY3JlYXRlQml0bWFwVmlldyhfKSwgeyBpbWFnZTogcHJvcHMuaW1hZ2UgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIHZhciBmbGlwID0gcHJvcHMuY3JvcC5mbGlwO1xuICAgICAgICB2YXIgYml0bWFwID0gcm9vdC5yZWYuYml0bWFwO1xuICAgICAgICBiaXRtYXAuc2NhbGVYID0gZmxpcC5ob3Jpem9udGFsID8gLTEgOiAxO1xuICAgICAgICBiaXRtYXAuc2NhbGVZID0gZmxpcC52ZXJ0aWNhbCA/IC0xIDogMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBjbGlwcyBjYW52YXMgdG8gY29ycmVjdCBhc3BlY3QgcmF0aW9cbiAgdmFyIGNyZWF0ZUNsaXBWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2xpcFZpZXcoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLWNsaXAnLFxuICAgICAgdGFnOiAnZGl2JyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogW1xuICAgICAgICAgICdjcm9wJyxcbiAgICAgICAgICAnbWFya3VwJyxcbiAgICAgICAgICAncmVzaXplJyxcbiAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICdkaXJ0eScsXG4gICAgICAgICAgJ2JhY2tncm91bmQnXG4gICAgICAgIF0sXG5cbiAgICAgICAgc3R5bGVzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uIGRpZFdyaXRlVmlldyhfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcztcbiAgICAgICAgaWYgKCFwcm9wcy5iYWNrZ3JvdW5kKSByZXR1cm47XG4gICAgICAgIHJvb3QuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwcm9wcy5iYWNrZ3JvdW5kO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuXG4gICAgICAgIHJvb3QucmVmLmltYWdlID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgICBjcmVhdGVJbWFnZUNhbnZhc1dyYXBwZXIoXyksXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcylcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5yZWYuY3JlYXRlTWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHJvb3QucmVmLm1hcmt1cCkgcmV0dXJuO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoY3JlYXRlTWFya3VwVmlldyhfKSwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5yZWYuZGVzdHJveU1hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghcm9vdC5yZWYubWFya3VwKSByZXR1cm47XG4gICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYubWFya3VwKTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BhcmVuY3kgZ3JpZFxuICAgICAgICB2YXIgdHJhbnNwYXJlbmN5SW5kaWNhdG9yID0gcm9vdC5xdWVyeShcbiAgICAgICAgICAnR0VUX0lNQUdFX1BSRVZJRVdfVFJBTlNQQVJFTkNZX0lORElDQVRPUidcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRyYW5zcGFyZW5jeUluZGljYXRvciA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdyaWQgcGF0dGVyblxuICAgICAgICBpZiAodHJhbnNwYXJlbmN5SW5kaWNhdG9yID09PSAnZ3JpZCcpIHtcbiAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC50cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSB0cmFuc3BhcmVuY3lJbmRpY2F0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmFzaWMgY29sb3JcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQudHJhbnNwYXJlbmN5SW5kaWNhdG9yID0gJ2NvbG9yJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShfcmVmNikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmNi5wcm9wcyxcbiAgICAgICAgICBzaG91bGRPcHRpbWl6ZSA9IF9yZWY2LnNob3VsZE9wdGltaXplO1xuICAgICAgICB2YXIgY3JvcCA9IHByb3BzLmNyb3AsXG4gICAgICAgICAgbWFya3VwID0gcHJvcHMubWFya3VwLFxuICAgICAgICAgIHJlc2l6ZSA9IHByb3BzLnJlc2l6ZSxcbiAgICAgICAgICBkaXJ0eSA9IHByb3BzLmRpcnR5LFxuICAgICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0O1xuXG4gICAgICAgIHJvb3QucmVmLmltYWdlLmNyb3AgPSBjcm9wO1xuXG4gICAgICAgIHZhciBzdGFnZSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgeDogd2lkdGggKiAwLjUsXG4gICAgICAgICAgICB5OiBoZWlnaHQgKiAwLjVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGltYWdlID0ge1xuICAgICAgICAgIHdpZHRoOiByb290LnJlZi5pbWFnZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHJvb3QucmVmLmltYWdlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB7XG4gICAgICAgICAgeDogY3JvcC5jZW50ZXIueCAqIGltYWdlLndpZHRoLFxuICAgICAgICAgIHk6IGNyb3AuY2VudGVyLnkgKiBpbWFnZS5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogc3RhZ2UuY2VudGVyLnggLSBpbWFnZS53aWR0aCAqIGNyb3AuY2VudGVyLngsXG4gICAgICAgICAgeTogc3RhZ2UuY2VudGVyLnkgLSBpbWFnZS5oZWlnaHQgKiBjcm9wLmNlbnRlci55XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5QSSAqIDIgKyAoY3JvcC5yb3RhdGlvbiAlIChNYXRoLlBJICogMikpO1xuXG4gICAgICAgIHZhciBjcm9wQXNwZWN0UmF0aW8gPSBjcm9wLmFzcGVjdFJhdGlvIHx8IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuXG4gICAgICAgIHZhciBzaG91bGRMaW1pdCA9XG4gICAgICAgICAgdHlwZW9mIGNyb3Auc2NhbGVUb0ZpdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY3JvcC5zY2FsZVRvRml0O1xuXG4gICAgICAgIHZhciBzdGFnZVpvb21GYWN0b3IgPSBnZXRJbWFnZVJlY3Rab29tRmFjdG9yKFxuICAgICAgICAgIGltYWdlLFxuICAgICAgICAgIGdldENlbnRlcmVkQ3JvcFJlY3Qoc3RhZ2UsIGNyb3BBc3BlY3RSYXRpbyksXG5cbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBzaG91bGRMaW1pdCA/IGNyb3AuY2VudGVyIDogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gY3JvcC56b29tICogc3RhZ2Vab29tRmFjdG9yO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBtYXJrdXAgdmlld1xuICAgICAgICBpZiAobWFya3VwICYmIG1hcmt1cC5sZW5ndGgpIHtcbiAgICAgICAgICByb290LnJlZi5jcmVhdGVNYXJrdXAoKTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC5yZXNpemUgPSByZXNpemU7XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwLmRpcnR5ID0gZGlydHk7XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwLm1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAuY3JvcCA9IGdldEN1cnJlbnRDcm9wU2l6ZShpbWFnZSwgY3JvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5yZWYubWFya3VwKSB7XG4gICAgICAgICAgcm9vdC5yZWYuZGVzdHJveU1hcmt1cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGltYWdlIHZpZXdcbiAgICAgICAgdmFyIGltYWdlVmlldyA9IHJvb3QucmVmLmltYWdlO1xuXG4gICAgICAgIC8vIGRvbid0IHVwZGF0ZSBjbGlwIGxheW91dFxuICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICBpbWFnZVZpZXcub3JpZ2luWCA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblkgPSBudWxsO1xuICAgICAgICAgIGltYWdlVmlldy50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICBpbWFnZVZpZXcudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnJvdGF0ZVogPSBudWxsO1xuICAgICAgICAgIGltYWdlVmlldy5zY2FsZVggPSBudWxsO1xuICAgICAgICAgIGltYWdlVmlldy5zY2FsZVkgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlVmlldy5vcmlnaW5YID0gb3JpZ2luLng7XG4gICAgICAgIGltYWdlVmlldy5vcmlnaW5ZID0gb3JpZ2luLnk7XG4gICAgICAgIGltYWdlVmlldy50cmFuc2xhdGVYID0gdHJhbnNsYXRpb24ueDtcbiAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGlvbi55O1xuICAgICAgICBpbWFnZVZpZXcucm90YXRlWiA9IHJvdGF0aW9uO1xuICAgICAgICBpbWFnZVZpZXcuc2NhbGVYID0gc2NhbGU7XG4gICAgICAgIGltYWdlVmlldy5zY2FsZVkgPSBzY2FsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSW1hZ2VWaWV3ID0gZnVuY3Rpb24gY3JlYXRlSW1hZ2VWaWV3KF8pIHtcbiAgICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3JyxcbiAgICAgIHRhZzogJ2RpdicsXG4gICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnaW1hZ2UnLCAnY3JvcCcsICdtYXJrdXAnLCAncmVzaXplJywgJ2RpcnR5JywgJ2JhY2tncm91bmQnXSxcblxuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcblxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgc2NhbGVYOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgc2NhbGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgdHJhbnNsYXRlWTogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDQwMCB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY3LnByb3BzO1xuICAgICAgICByb290LnJlZi5jbGlwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoY3JlYXRlQ2xpcFZpZXcoXyksIHtcbiAgICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICAgIGltYWdlOiBwcm9wcy5pbWFnZSxcbiAgICAgICAgICAgIGNyb3A6IHByb3BzLmNyb3AsXG4gICAgICAgICAgICBtYXJrdXA6IHByb3BzLm1hcmt1cCxcbiAgICAgICAgICAgIHJlc2l6ZTogcHJvcHMucmVzaXplLFxuICAgICAgICAgICAgZGlydHk6IHByb3BzLmRpcnR5LFxuICAgICAgICAgICAgYmFja2dyb3VuZDogcHJvcHMuYmFja2dyb3VuZFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY4LnByb3BzLFxuICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjguc2hvdWxkT3B0aW1pemU7XG4gICAgICAgIHZhciBjbGlwID0gcm9vdC5yZWYuY2xpcDtcbiAgICAgICAgdmFyIGltYWdlID0gcHJvcHMuaW1hZ2UsXG4gICAgICAgICAgY3JvcCA9IHByb3BzLmNyb3AsXG4gICAgICAgICAgbWFya3VwID0gcHJvcHMubWFya3VwLFxuICAgICAgICAgIHJlc2l6ZSA9IHByb3BzLnJlc2l6ZSxcbiAgICAgICAgICBkaXJ0eSA9IHByb3BzLmRpcnR5O1xuXG4gICAgICAgIGNsaXAuY3JvcCA9IGNyb3A7XG4gICAgICAgIGNsaXAubWFya3VwID0gbWFya3VwO1xuICAgICAgICBjbGlwLnJlc2l6ZSA9IHJlc2l6ZTtcbiAgICAgICAgY2xpcC5kaXJ0eSA9IGRpcnR5O1xuXG4gICAgICAgIC8vIGRvbid0IHVwZGF0ZSBjbGlwIGxheW91dFxuICAgICAgICBjbGlwLm9wYWNpdHkgPSBzaG91bGRPcHRpbWl6ZSA/IDAgOiAxO1xuXG4gICAgICAgIC8vIGRvbid0IHJlLXJlbmRlciBpZiBvcHRpbWl6aW5nIG9yIGhpZGRlbiAod2lkdGggd2lsbCBiZSB6ZXJvIHJlc3VsdGluZyBpbiB3ZWlyZCBhbmltYXRpb25zKVxuICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUgfHwgcm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNjYWxlZCBwcmV2aWV3IGltYWdlIHNpemVcbiAgICAgICAgdmFyIGltYWdlQXNwZWN0UmF0aW8gPSBpbWFnZS5oZWlnaHQgLyBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gY3JvcC5hc3BlY3RSYXRpbyB8fCBpbWFnZUFzcGVjdFJhdGlvO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBjb250YWluZXIgc2l6ZVxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSByb290LnJlY3QuaW5uZXIud2lkdGg7XG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSByb290LnJlY3QuaW5uZXIuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBmaXhlZFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19IRUlHSFQnKTtcbiAgICAgICAgdmFyIG1pblByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NSU5fSEVJR0hUJyk7XG4gICAgICAgIHZhciBtYXhQcmV2aWV3SGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFYX0hFSUdIVCcpO1xuXG4gICAgICAgIHZhciBwYW5lbEFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICB2YXIgYWxsb3dNdWx0aXBsZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuXG4gICAgICAgIGlmIChwYW5lbEFzcGVjdFJhdGlvICYmICFhbGxvd011bHRpcGxlKSB7XG4gICAgICAgICAgZml4ZWRQcmV2aWV3SGVpZ2h0ID0gY29udGFpbmVyV2lkdGggKiBwYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgICAgIGFzcGVjdFJhdGlvID0gcGFuZWxBc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVybWluZSBjbGlwIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgdmFyIGNsaXBIZWlnaHQgPVxuICAgICAgICAgIGZpeGVkUHJldmlld0hlaWdodCAhPT0gbnVsbFxuICAgICAgICAgICAgPyBmaXhlZFByZXZpZXdIZWlnaHRcbiAgICAgICAgICAgIDogTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgbWluUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihjb250YWluZXJXaWR0aCAqIGFzcGVjdFJhdGlvLCBtYXhQcmV2aWV3SGVpZ2h0KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciBjbGlwV2lkdGggPSBjbGlwSGVpZ2h0IC8gYXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChjbGlwV2lkdGggPiBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgIGNsaXBXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgIGNsaXBIZWlnaHQgPSBjbGlwV2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGlwSGVpZ2h0ID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgY2xpcEhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBjbGlwV2lkdGggPSBjb250YWluZXJIZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaXAud2lkdGggPSBjbGlwV2lkdGg7XG4gICAgICAgIGNsaXAuaGVpZ2h0ID0gY2xpcEhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgU1ZHX01BU0sgPVxuICAgICc8c3ZnIHdpZHRoPVwiNTAwXCIgaGVpZ2h0PVwiMjAwXCIgdmlld0JveD1cIjAgMCA1MDAgMjAwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIj5cXG4gICAgPGRlZnM+XFxuICAgICAgICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJncmFkaWVudC1fX1VJRF9fXCIgY3g9XCIuNVwiIGN5PVwiMS4yNVwiIHI9XCIxLjE1XCI+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzUwJVxcJyBzdG9wLWNvbG9yPVxcJyMwMDAwMDBcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc1NiVcXCcgc3RvcC1jb2xvcj1cXCcjMGEwYTBhXFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnNjMlXFwnIHN0b3AtY29sb3I9XFwnIzI2MjYyNlxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzY5JVxcJyBzdG9wLWNvbG9yPVxcJyM0ZjRmNGZcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc3NSVcXCcgc3RvcC1jb2xvcj1cXCcjODA4MDgwXFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnODElXFwnIHN0b3AtY29sb3I9XFwnI2IxYjFiMVxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzg4JVxcJyBzdG9wLWNvbG9yPVxcJyNkYWRhZGFcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc5NCVcXCcgc3RvcC1jb2xvcj1cXCcjZjZmNmY2XFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnMTAwJVxcJyBzdG9wLWNvbG9yPVxcJyNmZmZmZmZcXCcvPlxcbiAgICAgICAgPC9yYWRpYWxHcmFkaWVudD5cXG4gICAgICAgIDxtYXNrIGlkPVwibWFzay1fX1VJRF9fXCI+XFxuICAgICAgICAgICAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiNTAwXCIgaGVpZ2h0PVwiMjAwXCIgZmlsbD1cInVybCgjZ3JhZGllbnQtX19VSURfXylcIj48L3JlY3Q+XFxuICAgICAgICA8L21hc2s+XFxuICAgIDwvZGVmcz5cXG4gICAgPHJlY3QgeD1cIjBcIiB3aWR0aD1cIjUwMFwiIGhlaWdodD1cIjIwMFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBtYXNrPVwidXJsKCNtYXNrLV9fVUlEX18pXCI+PC9yZWN0Plxcbjwvc3ZnPic7XG5cbiAgdmFyIFNWR01hc2tVbmlxdWVJZCA9IDA7XG5cbiAgdmFyIGNyZWF0ZUltYWdlT3ZlcmxheVZpZXcgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZU92ZXJsYXlWaWV3KGZwQVBJKSB7XG4gICAgcmV0dXJuIGZwQVBJLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLXByZXZpZXctb3ZlcmxheScsXG4gICAgICB0YWc6ICdkaXYnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICB2YXIgbWFzayA9IFNWR19NQVNLO1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpKSB7XG4gICAgICAgICAgdmFyIHVybCA9IG5ldyBVUkwoXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5oYXNoLCAnJylcbiAgICAgICAgICApLmhyZWY7XG4gICAgICAgICAgbWFzayA9IG1hc2sucmVwbGFjZSgvdXJsXFwoXFwjL2csICd1cmwoJyArIHVybCArICcjJyk7XG4gICAgICAgIH1cblxuICAgICAgICBTVkdNYXNrVW5pcXVlSWQrKztcbiAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXG4gICAgICAgICAgJ2ZpbGVwb25kLS1pbWFnZS1wcmV2aWV3LW92ZXJsYXktJy5jb25jYXQocHJvcHMuc3RhdHVzKVxuICAgICAgICApO1xuXG4gICAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSBtYXNrLnJlcGxhY2UoL19fVUlEX18vZywgU1ZHTWFza1VuaXF1ZUlkKTtcbiAgICAgIH0sXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3NwcmluZycsIG1hc3M6IDI1IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaXRtYXAgV29ya2VyXG4gICAqL1xuICB2YXIgQml0bWFwV29ya2VyID0gZnVuY3Rpb24gQml0bWFwV29ya2VyKCkge1xuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoZS5kYXRhLm1lc3NhZ2UuZmlsZSkudGhlbihmdW5jdGlvbihiaXRtYXApIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQsIG1lc3NhZ2U6IGJpdG1hcCB9LCBbYml0bWFwXSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb2xvck1hdHJpeCBXb3JrZXJcbiAgICovXG4gIHZhciBDb2xvck1hdHJpeFdvcmtlciA9IGZ1bmN0aW9uIENvbG9yTWF0cml4V29ya2VyKCkge1xuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGUuZGF0YS5tZXNzYWdlLmltYWdlRGF0YTtcbiAgICAgIHZhciBtYXRyaXggPSBlLmRhdGEubWVzc2FnZS5jb2xvck1hdHJpeDtcblxuICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgIHZhciBsID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIHZhciBtMTEgPSBtYXRyaXhbMF07XG4gICAgICB2YXIgbTEyID0gbWF0cml4WzFdO1xuICAgICAgdmFyIG0xMyA9IG1hdHJpeFsyXTtcbiAgICAgIHZhciBtMTQgPSBtYXRyaXhbM107XG4gICAgICB2YXIgbTE1ID0gbWF0cml4WzRdO1xuXG4gICAgICB2YXIgbTIxID0gbWF0cml4WzVdO1xuICAgICAgdmFyIG0yMiA9IG1hdHJpeFs2XTtcbiAgICAgIHZhciBtMjMgPSBtYXRyaXhbN107XG4gICAgICB2YXIgbTI0ID0gbWF0cml4WzhdO1xuICAgICAgdmFyIG0yNSA9IG1hdHJpeFs5XTtcblxuICAgICAgdmFyIG0zMSA9IG1hdHJpeFsxMF07XG4gICAgICB2YXIgbTMyID0gbWF0cml4WzExXTtcbiAgICAgIHZhciBtMzMgPSBtYXRyaXhbMTJdO1xuICAgICAgdmFyIG0zNCA9IG1hdHJpeFsxM107XG4gICAgICB2YXIgbTM1ID0gbWF0cml4WzE0XTtcblxuICAgICAgdmFyIG00MSA9IG1hdHJpeFsxNV07XG4gICAgICB2YXIgbTQyID0gbWF0cml4WzE2XTtcbiAgICAgIHZhciBtNDMgPSBtYXRyaXhbMTddO1xuICAgICAgdmFyIG00NCA9IG1hdHJpeFsxOF07XG4gICAgICB2YXIgbTQ1ID0gbWF0cml4WzE5XTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgciA9IDAuMCxcbiAgICAgICAgZyA9IDAuMCxcbiAgICAgICAgYiA9IDAuMCxcbiAgICAgICAgYSA9IDAuMDtcblxuICAgICAgZm9yICg7IGluZGV4IDwgbDsgaW5kZXggKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpbmRleF0gLyAyNTU7XG4gICAgICAgIGcgPSBkYXRhW2luZGV4ICsgMV0gLyAyNTU7XG4gICAgICAgIGIgPSBkYXRhW2luZGV4ICsgMl0gLyAyNTU7XG4gICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM10gLyAyNTU7XG4gICAgICAgIGRhdGFbaW5kZXhdID0gTWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigociAqIG0xMSArIGcgKiBtMTIgKyBiICogbTEzICsgYSAqIG0xNCArIG0xNSkgKiAyNTUsIDI1NSlcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YVtpbmRleCArIDFdID0gTWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigociAqIG0yMSArIGcgKiBtMjIgKyBiICogbTIzICsgYSAqIG0yNCArIG0yNSkgKiAyNTUsIDI1NSlcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YVtpbmRleCArIDJdID0gTWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigociAqIG0zMSArIGcgKiBtMzIgKyBiICogbTMzICsgYSAqIG0zNCArIG0zNSkgKiAyNTUsIDI1NSlcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YVtpbmRleCArIDNdID0gTWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigociAqIG00MSArIGcgKiBtNDIgKyBiICogbTQzICsgYSAqIG00NCArIG00NSkgKiAyNTUsIDI1NSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQsIG1lc3NhZ2U6IGltYWdlRGF0YSB9LCBbXG4gICAgICAgIGltYWdlRGF0YS5kYXRhLmJ1ZmZlclxuICAgICAgXSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplKHVybCwgY2IpIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgaW1hZ2UgPSBudWxsO1xuICAgICAgY2Iod2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybXMgPSB7XG4gICAgMTogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfSxcbiAgICAyOiBmdW5jdGlvbiBfKHdpZHRoKSB7XG4gICAgICByZXR1cm4gWy0xLCAwLCAwLCAxLCB3aWR0aCwgMF07XG4gICAgfSxcbiAgICAzOiBmdW5jdGlvbiBfKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9LFxuICAgIDQ6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAtMSwgMCwgaGVpZ2h0XTtcbiAgICB9LFxuICAgIDU6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gWzAsIDEsIDEsIDAsIDAsIDBdO1xuICAgIH0sXG4gICAgNjogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gWzAsIDEsIC0xLCAwLCBoZWlnaHQsIDBdO1xuICAgIH0sXG4gICAgNzogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gWzAsIC0xLCAtMSwgMCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgfSxcbiAgICA4OiBmdW5jdGlvbiBfKHdpZHRoKSB7XG4gICAgICByZXR1cm4gWzAsIC0xLCAxLCAwLCAwLCB3aWR0aF07XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaXhJbWFnZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gZml4SW1hZ2VPcmllbnRhdGlvbihcbiAgICBjdHgsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9yaWVudGF0aW9uXG4gICkge1xuICAgIC8vIG5vIG9yaWVudGF0aW9uIHN1cHBsaWVkXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0cmFuc2Zvcm1zW29yaWVudGF0aW9uXSh3aWR0aCwgaGVpZ2h0KSk7XG4gIH07XG5cbiAgLy8gZHJhd3MgdGhlIHByZXZpZXcgaW1hZ2UgdG8gY2FudmFzXG4gIHZhciBjcmVhdGVQcmV2aWV3SW1hZ2UgPSBmdW5jdGlvbiBjcmVhdGVQcmV2aWV3SW1hZ2UoXG4gICAgZGF0YSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgb3JpZW50YXRpb25cbiAgKSB7XG4gICAgLy8gY2FuJ3QgZHJhdyBvbiBoYWxmIHBpeGVsc1xuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuXG4gICAgLy8gZHJhdyBpbWFnZVxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGlmIGlzIHJvdGF0ZWQgaW5jb3JyZWN0bHkgc3dhcCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgaWYgKG9yaWVudGF0aW9uID49IDUgJiYgb3JpZW50YXRpb24gPD0gOCkge1xuICAgICAgdmFyIF9yZWYgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICB3aWR0aCA9IF9yZWZbMF07XG4gICAgICBoZWlnaHQgPSBfcmVmWzFdO1xuICAgIH1cblxuICAgIC8vIGNvcnJlY3QgaW1hZ2Ugb3JpZW50YXRpb25cbiAgICBmaXhJbWFnZU9yaWVudGF0aW9uKGN0eCwgd2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICBjdHguZHJhd0ltYWdlKGRhdGEsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfTtcblxuICB2YXIgaXNCaXRtYXAgPSBmdW5jdGlvbiBpc0JpdG1hcChmaWxlKSB7XG4gICAgcmV0dXJuIC9eaW1hZ2UvLnRlc3QoZmlsZS50eXBlKSAmJiAhL3N2Zy8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIHZhciBNQVhfV0lEVEggPSAxMDtcbiAgdmFyIE1BWF9IRUlHSFQgPSAxMDtcblxuICB2YXIgY2FsY3VsYXRlQXZlcmFnZUNvbG9yID0gZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZUNvbG9yKGltYWdlKSB7XG4gICAgdmFyIHNjYWxhciA9IE1hdGgubWluKE1BWF9XSURUSCAvIGltYWdlLndpZHRoLCBNQVhfSEVJR0hUIC8gaW1hZ2UuaGVpZ2h0KTtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHdpZHRoID0gKGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChpbWFnZS53aWR0aCAqIHNjYWxhcikpO1xuICAgIHZhciBoZWlnaHQgPSAoY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChpbWFnZS5oZWlnaHQgKiBzY2FsYXIpKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsID0gZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGcgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgciArPSBkYXRhW2ldICogZGF0YVtpXTtcbiAgICAgIGcgKz0gZGF0YVtpICsgMV0gKiBkYXRhW2kgKyAxXTtcbiAgICAgIGIgKz0gZGF0YVtpICsgMl0gKiBkYXRhW2kgKyAyXTtcbiAgICB9XG5cbiAgICByID0gYXZlcmFnZUNvbG9yKHIsIGwpO1xuICAgIGcgPSBhdmVyYWdlQ29sb3IoZywgbCk7XG4gICAgYiA9IGF2ZXJhZ2VDb2xvcihiLCBsKTtcblxuICAgIHJldHVybiB7IHI6IHIsIGc6IGcsIGI6IGIgfTtcbiAgfTtcblxuICB2YXIgYXZlcmFnZUNvbG9yID0gZnVuY3Rpb24gYXZlcmFnZUNvbG9yKGMsIGwpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnNxcnQoYyAvIChsIC8gNCkpKTtcbiAgfTtcblxuICB2YXIgY2xvbmVDYW52YXMgPSBmdW5jdGlvbiBjbG9uZUNhbnZhcyhvcmlnaW4sIHRhcmdldCkge1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0YXJnZXQud2lkdGggPSBvcmlnaW4ud2lkdGg7XG4gICAgdGFyZ2V0LmhlaWdodCA9IG9yaWdpbi5oZWlnaHQ7XG4gICAgdmFyIGN0eCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5kcmF3SW1hZ2Uob3JpZ2luLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHZhciBjbG9uZUltYWdlRGF0YSA9IGZ1bmN0aW9uIGNsb25lSW1hZ2VEYXRhKGltYWdlRGF0YSkge1xuICAgIHZhciBpZDtcbiAgICB0cnkge1xuICAgICAgaWQgPSBuZXcgSW1hZ2VEYXRhKGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWQgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG4gICAgfVxuICAgIGlkLmRhdGEuc2V0KG5ldyBVaW50OENsYW1wZWRBcnJheShpbWFnZURhdGEuZGF0YSkpO1xuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICB9O1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH07XG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVJbWFnZVdyYXBwZXJWaWV3ID0gZnVuY3Rpb24gY3JlYXRlSW1hZ2VXcmFwcGVyVmlldyhfKSB7XG4gICAgLy8gY3JlYXRlIG92ZXJsYXkgdmlld1xuICAgIHZhciBPdmVybGF5VmlldyA9IGNyZWF0ZUltYWdlT3ZlcmxheVZpZXcoXyk7XG5cbiAgICB2YXIgSW1hZ2VWaWV3ID0gY3JlYXRlSW1hZ2VWaWV3KF8pO1xuICAgIHZhciBjcmVhdGVXb3JrZXIgPSBfLnV0aWxzLmNyZWF0ZVdvcmtlcjtcblxuICAgIHZhciBhcHBseUZpbHRlciA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVyKHJvb3QsIGZpbHRlciwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAvLyB3aWxsIHN0b3JlIGltYWdlIGRhdGEgZm9yIGZ1dHVyZSBmaWx0ZXIgdXBkYXRlc1xuICAgICAgICBpZiAoIXJvb3QucmVmLmltYWdlRGF0YSkge1xuICAgICAgICAgIHJvb3QucmVmLmltYWdlRGF0YSA9IHRhcmdldFxuICAgICAgICAgICAgLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBpbWFnZSBkYXRhIHJlZmVyZW5jZVxuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY2xvbmVJbWFnZURhdGEocm9vdC5yZWYuaW1hZ2VEYXRhKTtcblxuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICAgIHRhcmdldC5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VyID0gY3JlYXRlV29ya2VyKENvbG9yTWF0cml4V29ya2VyKTtcbiAgICAgICAgd29ya2VyLnBvc3QoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZURhdGEsXG4gICAgICAgICAgICBjb2xvck1hdHJpeDogZmlsdGVyXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJlZCBjb2xvcnNcbiAgICAgICAgICAgIHRhcmdldC5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShyZXNwb25zZSwgMCwgMCk7XG5cbiAgICAgICAgICAgIC8vIHN0b3Agd29ya2VyXG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbaW1hZ2VEYXRhLmRhdGEuYnVmZmVyXVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVJbWFnZVZpZXcgPSBmdW5jdGlvbiByZW1vdmVJbWFnZVZpZXcocm9vdCwgaW1hZ2VWaWV3KSB7XG4gICAgICByb290LnJlbW92ZUNoaWxkVmlldyhpbWFnZVZpZXcpO1xuICAgICAgaW1hZ2VWaWV3LmltYWdlLndpZHRoID0gMTtcbiAgICAgIGltYWdlVmlldy5pbWFnZS5oZWlnaHQgPSAxO1xuICAgICAgaW1hZ2VWaWV3Ll9kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIHJlbW92ZSBhbiBpbWFnZVxuICAgIHZhciBzaGlmdEltYWdlID0gZnVuY3Rpb24gc2hpZnRJbWFnZShfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgIHZhciBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZXMuc2hpZnQoKTtcbiAgICAgIGltYWdlVmlldy5vcGFjaXR5ID0gMDtcbiAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gLTE1O1xuICAgICAgcm9vdC5yZWYuaW1hZ2VWaWV3QmluLnB1c2goaW1hZ2VWaWV3KTtcbiAgICAgIHJldHVybiBpbWFnZVZpZXc7XG4gICAgfTtcblxuICAgIC8vIGFkZCBuZXcgaW1hZ2VcbiAgICB2YXIgcHVzaEltYWdlID0gZnVuY3Rpb24gcHVzaEltYWdlKF9yZWYyKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICAgIGltYWdlID0gX3JlZjIuaW1hZ2U7XG4gICAgICB2YXIgaWQgPSBwcm9wcy5pZDtcbiAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkOiBpZCB9KTtcbiAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKSB8fCB7XG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHg6IDAuNSxcbiAgICAgICAgICB5OiAwLjVcbiAgICAgICAgfSxcblxuICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgICAgdmVydGljYWw6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgem9vbTogMSxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBudWxsXG4gICAgICB9O1xuXG4gICAgICB2YXIgYmFja2dyb3VuZCA9IHJvb3QucXVlcnkoXG4gICAgICAgICdHRVRfSU1BR0VfVFJBTlNGT1JNX0NBTlZBU19CQUNLR1JPVU5EX0NPTE9SJ1xuICAgICAgKTtcblxuICAgICAgdmFyIG1hcmt1cDtcbiAgICAgIHZhciByZXNpemU7XG4gICAgICB2YXIgZGlydHkgPSBmYWxzZTtcbiAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVJLVVBfU0hPVycpKSB7XG4gICAgICAgIG1hcmt1cCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ21hcmt1cCcpIHx8IFtdO1xuICAgICAgICByZXNpemUgPSBpdGVtLmdldE1ldGFkYXRhKCdyZXNpemUnKTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgaW1hZ2UgcHJlc2VudGVyXG4gICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KEltYWdlVmlldywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgY3JvcDogY3JvcCxcbiAgICAgICAgICByZXNpemU6IHJlc2l6ZSxcbiAgICAgICAgICBtYXJrdXA6IG1hcmt1cCxcbiAgICAgICAgICBkaXJ0eTogZGlydHksXG4gICAgICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZCxcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHNjYWxlWDogMS4xNSxcbiAgICAgICAgICBzY2FsZVk6IDEuMTUsXG4gICAgICAgICAgdHJhbnNsYXRlWTogMTVcbiAgICAgICAgfSksXG5cbiAgICAgICAgcm9vdC5jaGlsZFZpZXdzLmxlbmd0aFxuICAgICAgKTtcblxuICAgICAgcm9vdC5yZWYuaW1hZ2VzLnB1c2goaW1hZ2VWaWV3KTtcblxuICAgICAgLy8gcmV2ZWFsIHRoZSBwcmV2aWV3IGltYWdlXG4gICAgICBpbWFnZVZpZXcub3BhY2l0eSA9IDE7XG4gICAgICBpbWFnZVZpZXcuc2NhbGVYID0gMTtcbiAgICAgIGltYWdlVmlldy5zY2FsZVkgPSAxO1xuICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVkgPSAwO1xuXG4gICAgICAvLyB0aGUgcHJldmlldyBpcyBub3cgcmVhZHkgdG8gYmUgZHJhd25cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9JTUFHRV9QUkVWSUVXX1NIT1cnLCB7IGlkOiBpZCB9KTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVJbWFnZSA9IGZ1bmN0aW9uIHVwZGF0ZUltYWdlKF9yZWYzKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogcHJvcHMuaWQgfSk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgIHZhciBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaW1hZ2VWaWV3LmNyb3AgPSBpdGVtLmdldE1ldGFkYXRhKCdjcm9wJyk7XG4gICAgICBpbWFnZVZpZXcuYmFja2dyb3VuZCA9IHJvb3QucXVlcnkoXG4gICAgICAgICdHRVRfSU1BR0VfVFJBTlNGT1JNX0NBTlZBU19CQUNLR1JPVU5EX0NPTE9SJ1xuICAgICAgKTtcblxuICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BUktVUF9TSE9XJykpIHtcbiAgICAgICAgaW1hZ2VWaWV3LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaW1hZ2VWaWV3LnJlc2l6ZSA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ3Jlc2l6ZScpO1xuICAgICAgICBpbWFnZVZpZXcubWFya3VwID0gaXRlbS5nZXRNZXRhZGF0YSgnbWFya3VwJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlcGxhY2UgaW1hZ2UgcHJldmlld1xuICAgIHZhciBkaWRVcGRhdGVJdGVtTWV0YWRhdGEgPSBmdW5jdGlvbiBkaWRVcGRhdGVJdGVtTWV0YWRhdGEoX3JlZjQpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgLy8gb25seSBmaWx0ZXIgYW5kIGNyb3AgdHJpZ2dlciByZWRyYXdcbiAgICAgIGlmICghL2Nyb3B8ZmlsdGVyfG1hcmt1cHxyZXNpemUvLnRlc3QoYWN0aW9uLmNoYW5nZS5rZXkpKSByZXR1cm47XG5cbiAgICAgIC8vIG5vIGltYWdlcyB0byB1cGRhdGUsIGV4aXRcbiAgICAgIGlmICghcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAvLyBubyBpdGVtIGZvdW5kLCBleGl0XG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogcHJvcHMuaWQgfSk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgLy8gZm9yIG5vdywgdXBkYXRlIGV4aXN0aW5nIGltYWdlIHdoZW4gZmlsdGVyaW5nXG4gICAgICBpZiAoL2ZpbHRlci8udGVzdChhY3Rpb24uY2hhbmdlLmtleSkpIHtcbiAgICAgICAgdmFyIGltYWdlVmlldyA9IHJvb3QucmVmLmltYWdlc1tyb290LnJlZi5pbWFnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGFwcGx5RmlsdGVyKHJvb3QsIGFjdGlvbi5jaGFuZ2UudmFsdWUsIGltYWdlVmlldy5pbWFnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKC9jcm9wfG1hcmt1cHxyZXNpemUvLnRlc3QoYWN0aW9uLmNoYW5nZS5rZXkpKSB7XG4gICAgICAgIHZhciBjcm9wID0gaXRlbS5nZXRNZXRhZGF0YSgnY3JvcCcpO1xuICAgICAgICB2YXIgaW1hZ2UgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIGlmIGFzcGVjdCByYXRpbyBoYXMgY2hhbmdlZCwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNyb3AgJiZcbiAgICAgICAgICBjcm9wLmFzcGVjdFJhdGlvICYmXG4gICAgICAgICAgaW1hZ2UuY3JvcCAmJlxuICAgICAgICAgIGltYWdlLmNyb3AuYXNwZWN0UmF0aW8gJiZcbiAgICAgICAgICBNYXRoLmFicyhjcm9wLmFzcGVjdFJhdGlvIC0gaW1hZ2UuY3JvcC5hc3BlY3RSYXRpbykgPiAwLjAwMDAxXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBfaW1hZ2VWaWV3ID0gc2hpZnRJbWFnZSh7IHJvb3Q6IHJvb3QgfSk7XG4gICAgICAgICAgcHVzaEltYWdlKHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICBpbWFnZTogY2xvbmVDYW52YXMoX2ltYWdlVmlldy5pbWFnZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBub3QsIHdlIGNhbiB1cGRhdGUgdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdXBkYXRlSW1hZ2UoeyByb290OiByb290LCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhbkNyZWF0ZUltYWdlQml0bWFwID0gZnVuY3Rpb24gY2FuQ3JlYXRlSW1hZ2VCaXRtYXAoZmlsZSkge1xuICAgICAgLy8gRmlyZWZveCB2ZXJzaW9ucyBiZWZvcmUgNTggd2lsbCBmcmVlemUgd2hlbiBydW5uaW5nIGNyZWF0ZUltYWdlQml0bWFwXG4gICAgICAvLyBpbiBhIFdlYiBXb3JrZXIgc28gd2UgZGV0ZWN0IHRob3NlIHZlcnNpb25zIGFuZCByZXR1cm4gZmFsc2UgZm9yIHN1cHBvcnRcbiAgICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgIHZhciBpc0ZpcmVmb3ggPSB1c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pO1xuICAgICAgdmFyIGZpcmVmb3hWZXJzaW9uID0gaXNGaXJlZm94ID8gcGFyc2VJbnQoaXNGaXJlZm94WzFdKSA6IG51bGw7XG4gICAgICBpZiAoZmlyZWZveFZlcnNpb24gIT09IG51bGwgJiYgZmlyZWZveFZlcnNpb24gPD0gNTgpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuICdjcmVhdGVJbWFnZUJpdG1hcCcgaW4gd2luZG93ICYmIGlzQml0bWFwKGZpbGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBoYW5kbGVyIGZvciB3aGVuIHByZXZpZXcgY29udGFpbmVyIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKi9cbiAgICB2YXIgZGlkQ3JlYXRlUHJldmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uIGRpZENyZWF0ZVByZXZpZXdDb250YWluZXIoX3JlZjUpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGdldCB0aGUgZmlsZSBkYXRhIHRvIGRldGVybWluZSB0aGUgZXZlbnR1YWwgaW1hZ2Ugc2l6ZVxuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGlkKTtcbiAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICAvLyBnZXQgdXJsIHRvIGZpbGUgKHdlJ2xsIHJldm9rZSBpdCBsYXRlciBvbiB3aGVuIGRvbmUpXG4gICAgICB2YXIgZmlsZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaXRlbS5maWxlKTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIGltYWdlIHNpemUgb2YgdGhpcyBpdGVtXG4gICAgICBnZXRJbWFnZVNpemUoZmlsZVVSTCwgZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyB3ZSBjYW4gbm93IHNjYWxlIHRoZSBwYW5lbCB0byB0aGUgZmluYWwgc2l6ZVxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfSU1BR0VfUFJFVklFV19DQUxDVUxBVEVfU0laRScsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3UHJldmlldyA9IGZ1bmN0aW9uIGRyYXdQcmV2aWV3KF9yZWY2KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjYucHJvcHM7XG4gICAgICB2YXIgaWQgPSBwcm9wcy5pZDtcblxuICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIGZpbGUgZGF0YSB0byBkZXRlcm1pbmUgdGhlIGV2ZW50dWFsIGltYWdlIHNpemVcbiAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBpZCk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgLy8gZ2V0IHVybCB0byBmaWxlICh3ZSdsbCByZXZva2UgaXQgbGF0ZXIgb24gd2hlbiBkb25lKVxuICAgICAgdmFyIGZpbGVVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGl0ZW0uZmlsZSk7XG5cbiAgICAgIC8vIGZhbGxiYWNrXG4gICAgICB2YXIgbG9hZFByZXZpZXdGYWxsYmFjayA9IGZ1bmN0aW9uIGxvYWRQcmV2aWV3RmFsbGJhY2soKSB7XG4gICAgICAgIC8vIGxldCdzIHNjYWxlIHRoZSBpbWFnZSBpbiB0aGUgbWFpbiB0aHJlYWQgOihcbiAgICAgICAgbG9hZEltYWdlKGZpbGVVUkwpLnRoZW4ocHJldmlld0ltYWdlTG9hZGVkKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGltYWdlIGlzIG5vdyByZWFkeVxuICAgICAgdmFyIHByZXZpZXdJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uIHByZXZpZXdJbWFnZUxvYWRlZChpbWFnZURhdGEpIHtcbiAgICAgICAgLy8gdGhlIGZpbGUgdXJsIGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChmaWxlVVJMKTtcblxuICAgICAgICAvLyBkcmF3IHRoZSBzY2FsZWQgZG93biB2ZXJzaW9uIGhlcmUgYW5kIHVzZSB0aGF0IGFzIHNvdXJjZSBzbyBiaXRtYXBkYXRhIGNhbiBiZSBjbG9zZWRcbiAgICAgICAgLy8gb3JpZW50YXRpb24gaW5mb1xuICAgICAgICB2YXIgZXhpZiA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2V4aWYnKSB8fCB7fTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gZXhpZi5vcmllbnRhdGlvbiB8fCAtMTtcblxuICAgICAgICAvLyBnZXQgd2lkdGggYW5kIGhlaWdodCBmcm9tIGFjdGlvbiwgYW5kIHN3YXAgaWYgb3JpZW50YXRpb24gaXMgaW5jb3JyZWN0XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGlmIG5vIHdpZHRoIG9yIGhlaWdodCwganVzdCByZXR1cm4gZWFybHkuXG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA+PSA1ICYmIG9yaWVudGF0aW9uIDw9IDgpIHtcbiAgICAgICAgICB2YXIgX3JlZjcgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgICAgd2lkdGggPSBfcmVmN1swXTtcbiAgICAgICAgICBoZWlnaHQgPSBfcmVmN1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlIGNhbnZhcyBiYXNlZCBvbiBwaXhlbCBkZW5zaXR5XG4gICAgICAgIC8vIHdlIG11bHRpcGx5IGJ5IC43NSBhcyB0aGF0IGNyZWF0ZXMgc21hbGxlciBidXQgc3RpbGwgY2xlYXIgaW1hZ2VzIG9uIHNjcmVlbnMgd2l0aCBoaWdoIHJlcyBkaXNwbGF5c1xuICAgICAgICB2YXIgcGl4ZWxEZW5zaXR5RmFjdG9yID0gTWF0aC5tYXgoMSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gKiAwLjc1KTtcblxuICAgICAgICAvLyB3ZSB3YW50IGFzIG11Y2ggcGl4ZWxzIHRvIHdvcmsgd2l0aCBhcyBwb3NzaWJsZSxcbiAgICAgICAgLy8gdGhpcyBtdWx0aXBsaWVzIHRoZSBtaW5pbXVtIGltYWdlIHJlc29sdXRpb24sXG4gICAgICAgIC8vIHNvIHdoZW4gem9vbWluZyBpbiBpdCBkb2Vzbid0IGdldCB0b28gYmx1cnJ5XG4gICAgICAgIHZhciB6b29tRmFjdG9yID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfWk9PTV9GQUNUT1InKTtcblxuICAgICAgICAvLyBpbWFlZyBzY2FsZSBmYWN0b3JcbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gem9vbUZhY3RvciAqIHBpeGVsRGVuc2l0eUZhY3RvcjtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVkIHByZXZpZXcgaW1hZ2Ugc2l6ZVxuICAgICAgICB2YXIgcHJldmlld0ltYWdlUmF0aW8gPSBoZWlnaHQgLyB3aWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaW1hZ2UgcHJldmlldyBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgIHZhciBwcmV2aWV3Q29udGFpbmVyV2lkdGggPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIHByZXZpZXdDb250YWluZXJIZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSBwcmV2aWV3Q29udGFpbmVyV2lkdGg7XG4gICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGltYWdlV2lkdGggKiBwcmV2aWV3SW1hZ2VSYXRpbztcblxuICAgICAgICBpZiAocHJldmlld0ltYWdlUmF0aW8gPiAxKSB7XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IE1hdGgubWluKHdpZHRoLCBwcmV2aWV3Q29udGFpbmVyV2lkdGggKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBpbWFnZVdpZHRoICogcHJldmlld0ltYWdlUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIHByZXZpZXdDb250YWluZXJIZWlnaHQgKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IGltYWdlSGVpZ2h0IC8gcHJldmlld0ltYWdlUmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2ZlciB0byBpbWFnZSB0YWcgc28gbm8gY2FudmFzIG1lbW9yeSB3YXN0ZWQgb24gaU9TXG4gICAgICAgIHZhciBwcmV2aWV3SW1hZ2UgPSBjcmVhdGVQcmV2aWV3SW1hZ2UoXG4gICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgIGltYWdlV2lkdGgsXG4gICAgICAgICAgaW1hZ2VIZWlnaHQsXG4gICAgICAgICAgb3JpZW50YXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBkb25lXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgYXZlcmFnZSBpbWFnZSBjb2xvciwgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICAgIHZhciBhdmVyYWdlQ29sb3IgPSByb290LnF1ZXJ5KFxuICAgICAgICAgICAgJ0dFVF9JTUFHRV9QUkVWSUVXX0NBTENVTEFURV9BVkVSQUdFX0lNQUdFX0NPTE9SJ1xuICAgICAgICAgIClcbiAgICAgICAgICAgID8gY2FsY3VsYXRlQXZlcmFnZUNvbG9yKGRhdGEpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YSgnY29sb3InLCBhdmVyYWdlQ29sb3IsIHRydWUpO1xuXG4gICAgICAgICAgLy8gZGF0YSBoYXMgYmVlbiB0cmFuc2ZlcnJlZCB0byBjYW52YXMgKCBpZiB3YXMgSW1hZ2VCaXRtYXAgKVxuICAgICAgICAgIGlmICgnY2xvc2UnIGluIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhLmNsb3NlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2hvdyB0aGUgb3ZlcmxheVxuICAgICAgICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDE7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIGZpcnN0IGltYWdlXG4gICAgICAgICAgcHVzaEltYWdlKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBpbWFnZTogcHJldmlld0ltYWdlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFwcGx5IGZpbHRlclxuICAgICAgICB2YXIgZmlsdGVyID0gaXRlbS5nZXRNZXRhZGF0YSgnZmlsdGVyJyk7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICBhcHBseUZpbHRlcihyb290LCBmaWx0ZXIsIHByZXZpZXdJbWFnZSkudGhlbihkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIHdlIHN1cHBvcnQgc2NhbGluZyB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCB3ZSB1c2UgYSB3b3JrZXJcbiAgICAgIGlmIChjYW5DcmVhdGVJbWFnZUJpdG1hcChpdGVtLmZpbGUpKSB7XG4gICAgICAgIC8vIGxldCdzIHNjYWxlIHRoZSBpbWFnZSBpbiBhIHdvcmtlclxuICAgICAgICB2YXIgd29ya2VyID0gY3JlYXRlV29ya2VyKEJpdG1hcFdvcmtlcik7XG5cbiAgICAgICAgd29ya2VyLnBvc3QoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsZTogaXRlbS5maWxlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHdvcmtlclxuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBubyBiaXRtYXAgcmV0dXJuZWQsIG11c3QgYmUgc29tZXRoaW5nIHdyb25nLFxuICAgICAgICAgICAgLy8gdHJ5IHRoZSBvbGRzY2hvb2wgd2F5XG4gICAgICAgICAgICBpZiAoIWltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAgIGxvYWRQcmV2aWV3RmFsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB5YXkgd2UgZ290IG91ciBiaXRtYXAsIGxldCdzIGNvbnRpbnVlIHNob3dpbmcgdGhlIHByZXZpZXdcbiAgICAgICAgICAgIHByZXZpZXdJbWFnZUxvYWRlZChpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGZhbGxiYWNrIHByZXZpZXdcbiAgICAgICAgbG9hZFByZXZpZXdGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBoYW5kbGVyIGZvciB3aGVuIHRoZSBwcmV2aWV3IGltYWdlIGlzIHJlYWR5IHRvIGJlIGFuaW1hdGVkXG4gICAgICovXG4gICAgdmFyIGRpZERyYXdQcmV2aWV3ID0gZnVuY3Rpb24gZGlkRHJhd1ByZXZpZXcoX3JlZjgpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICAgIC8vIGdldCBsYXN0IGFkZGVkIGltYWdlXG4gICAgICB2YXIgaW1hZ2UgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaW1hZ2UudHJhbnNsYXRlWSA9IDA7XG4gICAgICBpbWFnZS5zY2FsZVggPSAxLjA7XG4gICAgICBpbWFnZS5zY2FsZVkgPSAxLjA7XG4gICAgICBpbWFnZS5vcGFjaXR5ID0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgaGFuZGxlciBmb3Igd2hlbiB0aGUgcHJldmlldyBoYXMgYmVlbiBsb2FkZWRcbiAgICAgKi9cbiAgICB2YXIgcmVzdG9yZU92ZXJsYXkgPSBmdW5jdGlvbiByZXN0b3JlT3ZlcmxheShfcmVmOSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMTtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvci5vcGFjaXR5ID0gMDtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTdWNjZXNzLm9wYWNpdHkgPSAwO1xuICAgIH07XG5cbiAgICB2YXIgZGlkVGhyb3dFcnJvciA9IGZ1bmN0aW9uIGRpZFRocm93RXJyb3IoX3JlZjEwKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMC4yNTtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvci5vcGFjaXR5ID0gMTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZENvbXBsZXRlUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlUHJvY2Vzc2luZyhfcmVmMTEpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjExLnJvb3Q7XG4gICAgICByb290LnJlZi5vdmVybGF5U2hhZG93Lm9wYWNpdHkgPSAwLjI1O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVN1Y2Nlc3Mub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMTIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEyLnJvb3Q7XG4gICAgICAvLyBpbWFnZSB2aWV3XG4gICAgICByb290LnJlZi5pbWFnZXMgPSBbXTtcblxuICAgICAgLy8gdGhlIHByZXZpZXcgaW1hZ2UgZGF0YSAod2UgbmVlZCB0aGlzIHRvIGZpbHRlciB0aGUgaW1hZ2UpXG4gICAgICByb290LnJlZi5pbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICAvLyBpbWFnZSBiaW5cbiAgICAgIHJvb3QucmVmLmltYWdlVmlld0JpbiA9IFtdO1xuXG4gICAgICAvLyBpbWFnZSBvdmVybGF5c1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhPdmVybGF5Vmlldywge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgc3RhdHVzOiAnaWRsZSdcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTdWNjZXNzID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KE92ZXJsYXlWaWV3LCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcm9vdC5yZWYub3ZlcmxheUVycm9yID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KE92ZXJsYXlWaWV3LCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBzdGF0dXM6ICdmYWlsdXJlJ1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtcHJldmlldy13cmFwcGVyJyxcbiAgICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgICAgc3R5bGVzOiBbJ2hlaWdodCddLFxuICAgICAgYXBpczogWydoZWlnaHQnXSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjEzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjEzLnJvb3Q7XG4gICAgICAgIC8vIHdlIHJlc2l6ZSB0aGUgaW1hZ2Ugc28gbWVtb3J5IG9uIGlPUyAxMiBpcyByZWxlYXNlZCBtb3JlIHF1aWNrbHkgKGl0IHNlZW1zKVxuICAgICAgICByb290LnJlZi5pbWFnZXMuZm9yRWFjaChmdW5jdGlvbihpbWFnZVZpZXcpIHtcbiAgICAgICAgICBpbWFnZVZpZXcuaW1hZ2Uud2lkdGggPSAxO1xuICAgICAgICAgIGltYWdlVmlldy5pbWFnZS5oZWlnaHQgPSAxO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uIGRpZFdyaXRlVmlldyhfcmVmMTQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTQucm9vdDtcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24oaW1hZ2VWaWV3KSB7XG4gICAgICAgICAgaW1hZ2VWaWV3LmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBfLnV0aWxzLmNyZWF0ZVJvdXRlKFxuICAgICAgICB7XG4gICAgICAgICAgLy8gaW1hZ2UgcHJldmlldyBzdGF0ZWRcbiAgICAgICAgICBESURfSU1BR0VfUFJFVklFV19EUkFXOiBkaWREcmF3UHJldmlldyxcbiAgICAgICAgICBESURfSU1BR0VfUFJFVklFV19DT05UQUlORVJfQ1JFQVRFOiBkaWRDcmVhdGVQcmV2aWV3Q29udGFpbmVyLFxuICAgICAgICAgIERJRF9GSU5JU0hfQ0FMQ1VMQVRFX1BSRVZJRVdTSVpFOiBkcmF3UHJldmlldyxcbiAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSxcblxuICAgICAgICAgIC8vIGZpbGUgc3RhdGVzXG4gICAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogZGlkVGhyb3dFcnJvcixcbiAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGRpZFRocm93RXJyb3IsXG4gICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVQcm9jZXNzaW5nLFxuICAgICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IHJlc3RvcmVPdmVybGF5LFxuICAgICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiByZXN0b3JlT3ZlcmxheVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKF9yZWYxNSkge1xuICAgICAgICAgIHZhciByb290ID0gX3JlZjE1LnJvb3Q7XG4gICAgICAgICAgLy8gdmlld3Mgb24gZGVhdGggcm93XG4gICAgICAgICAgdmFyIHZpZXdzVG9SZW1vdmUgPSByb290LnJlZi5pbWFnZVZpZXdCaW4uZmlsdGVyKGZ1bmN0aW9uKGltYWdlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVmlldy5vcGFjaXR5ID09PSAwO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdmlld3MgdG8gcmV0YWluXG4gICAgICAgICAgcm9vdC5yZWYuaW1hZ2VWaWV3QmluID0gcm9vdC5yZWYuaW1hZ2VWaWV3QmluLmZpbHRlcihmdW5jdGlvbihcbiAgICAgICAgICAgIGltYWdlVmlld1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVmlldy5vcGFjaXR5ID4gMDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSB0aGVzZSB2aWV3c1xuICAgICAgICAgIHZpZXdzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbihpbWFnZVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVJbWFnZVZpZXcocm9vdCwgaW1hZ2VWaWV3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2aWV3c1RvUmVtb3ZlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSW1hZ2UgUHJldmlldyBQbHVnaW5cbiAgICovXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oZnBBUEkpIHtcbiAgICB2YXIgYWRkRmlsdGVyID0gZnBBUEkuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBmcEFQSS51dGlscztcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICBjcmVhdGVSb3V0ZSA9IHV0aWxzLmNyZWF0ZVJvdXRlLFxuICAgICAgaXNGaWxlID0gdXRpbHMuaXNGaWxlO1xuXG4gICAgLy8gaW1hZ2VQcmV2aWV3Vmlld1xuICAgIHZhciBpbWFnZVByZXZpZXdWaWV3ID0gY3JlYXRlSW1hZ2VXcmFwcGVyVmlldyhmcEFQSSk7XG5cbiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggdmlldyB0aGF0IGlzIGNyZWF0ZWQgcmlnaHQgYWZ0ZXIgdGhlICdjcmVhdGUnIG1ldGhvZFxuICAgIGFkZEZpbHRlcignQ1JFQVRFX1ZJRVcnLCBmdW5jdGlvbih2aWV3QVBJKSB7XG4gICAgICAvLyBnZXQgcmVmZXJlbmNlIHRvIGNyZWF0ZWQgdmlld1xuICAgICAgdmFyIGlzID0gdmlld0FQSS5pcyxcbiAgICAgICAgdmlldyA9IHZpZXdBUEkudmlldyxcbiAgICAgICAgcXVlcnkgPSB2aWV3QVBJLnF1ZXJ5O1xuXG4gICAgICAvLyBvbmx5IGhvb2sgdXAgdG8gaXRlbSB2aWV3IGFuZCBvbmx5IGlmIGlzIGVuYWJsZWQgZm9yIHRoaXMgY3JvcHBlclxuICAgICAgaWYgKCFpcygnZmlsZScpIHx8ICFxdWVyeSgnR0VUX0FMTE9XX0lNQUdFX1BSRVZJRVcnKSkgcmV0dXJuO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGltYWdlIHByZXZpZXcgcGx1Z2luLCBidXQgb25seSBkbyBzbyBpZiB0aGUgaXRlbSBpcyBhbiBpbWFnZVxuICAgICAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXJ5KCdHRVRfSVRFTScsIGlkKTtcblxuICAgICAgICAvLyBpdGVtIGNvdWxkIHRoZW9yZXRpY2FsbHkgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gdGhlIG1lYW4gdGltZVxuICAgICAgICBpZiAoIWl0ZW0gfHwgIWlzRmlsZShpdGVtLmZpbGUpIHx8IGl0ZW0uYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBnZXQgdGhlIGZpbGUgb2JqZWN0XG4gICAgICAgIHZhciBmaWxlID0gaXRlbS5maWxlO1xuXG4gICAgICAgIC8vIGV4aXQgaWYgdGhpcyBpcyBub3QgYW4gaW1hZ2VcbiAgICAgICAgaWYgKCFpc1ByZXZpZXdhYmxlSW1hZ2UoZmlsZSkpIHJldHVybjtcblxuICAgICAgICAvLyB0ZXN0IGlmIGlzIGZpbHRlcmVkXG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0ZJTFRFUl9JVEVNJykoaXRlbSkpIHJldHVybjtcblxuICAgICAgICAvLyBleGl0IGlmIGltYWdlIHNpemUgaXMgdG9vIGhpZ2ggYW5kIG5vIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnRcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBzaW1wbHkgYnJpbmcgdGhlIGJyb3dzZXIgdG8gaXRzIGtuZWVzIGFuZCB0aGF0IGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgdmFyIHN1cHBvcnRzQ3JlYXRlSW1hZ2VCaXRtYXAgPSAnY3JlYXRlSW1hZ2VCaXRtYXAnIGluICh3aW5kb3cgfHwge30pO1xuICAgICAgICB2YXIgbWF4UHJldmlld0ZpbGVTaXplID0gcXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BWF9GSUxFX1NJWkUnKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFzdXBwb3J0c0NyZWF0ZUltYWdlQml0bWFwICYmXG4gICAgICAgICAgbWF4UHJldmlld0ZpbGVTaXplICYmXG4gICAgICAgICAgZmlsZS5zaXplID4gbWF4UHJldmlld0ZpbGVTaXplXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0IHByZXZpZXcgdmlld1xuICAgICAgICByb290LnJlZi5pbWFnZVByZXZpZXcgPSB2aWV3LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICB2aWV3LmNyZWF0ZUNoaWxkVmlldyhpbWFnZVByZXZpZXdWaWV3LCB7IGlkOiBpZCB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBoZWlnaHQgaWYgaXMgZml4ZWRcbiAgICAgICAgdmFyIGZpeGVkUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgICBpZiAoZml4ZWRQcmV2aWV3SGVpZ2h0KSB7XG4gICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1VQREFURV9QQU5FTF9IRUlHSFQnLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGhlaWdodDogZml4ZWRQcmV2aWV3SGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgcmVhZHlcbiAgICAgICAgdmFyIHF1ZXVlID1cbiAgICAgICAgICAhc3VwcG9ydHNDcmVhdGVJbWFnZUJpdG1hcCAmJlxuICAgICAgICAgIGZpbGUuc2l6ZSA+IHF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSU5TVEFOVF9QUkVWSUVXX0ZJTEVfU0laRScpO1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfSU1BR0VfUFJFVklFV19DT05UQUlORVJfQ1JFQVRFJywgeyBpZDogaWQgfSwgcXVldWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlc2NhbGVJdGVtID0gZnVuY3Rpb24gcmVzY2FsZUl0ZW0ocm9vdCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCFyb290LnJlZi5pbWFnZVByZXZpZXcpIHJldHVybjtcbiAgICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gZ2V0IGl0ZW1cbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgICAvLyBpZiBpcyBmaXhlZCBoZWlnaHQgb3IgcGFuZWwgaGFzIGFzcGVjdCByYXRpbywgZXhpdCBoZXJlLCBoZWlnaHQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkXG4gICAgICAgIHZhciBwYW5lbEFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICB2YXIgaXRlbVBhbmVsQXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgdmFyIGZpeGVkSGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfSEVJR0hUJyk7XG4gICAgICAgIGlmIChwYW5lbEFzcGVjdFJhdGlvIHx8IGl0ZW1QYW5lbEFzcGVjdFJhdGlvIHx8IGZpeGVkSGVpZ2h0KSByZXR1cm47XG5cbiAgICAgICAgLy8gbm8gZGF0YSFcbiAgICAgICAgdmFyIF9yb290JHJlZiA9IHJvb3QucmVmLFxuICAgICAgICAgIGltYWdlV2lkdGggPSBfcm9vdCRyZWYuaW1hZ2VXaWR0aCxcbiAgICAgICAgICBpbWFnZUhlaWdodCA9IF9yb290JHJlZi5pbWFnZUhlaWdodDtcbiAgICAgICAgaWYgKCFpbWFnZVdpZHRoIHx8ICFpbWFnZUhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBoZWlnaHQgbWluIGFuZCBtYXhcbiAgICAgICAgdmFyIG1pblByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NSU5fSEVJR0hUJyk7XG4gICAgICAgIHZhciBtYXhQcmV2aWV3SGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFYX0hFSUdIVCcpO1xuXG4gICAgICAgIC8vIG9yaWVudGF0aW9uIGluZm9cbiAgICAgICAgdmFyIGV4aWYgPSBpdGVtLmdldE1ldGFkYXRhKCdleGlmJykgfHwge307XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IGV4aWYub3JpZW50YXRpb24gfHwgLTE7XG5cbiAgICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBhY3Rpb24sIGFuZCBzd2FwIG9mIG9yaWVudGF0aW9uIGlzIGluY29ycmVjdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gW2ltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoXTtcbiAgICAgICAgICBpbWFnZVdpZHRoID0gX3JlZjJbMF07XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBfcmVmMlsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlIHVwIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gU1ZHXG4gICAgICAgIGlmICghaXNCaXRtYXAoaXRlbS5maWxlKSB8fCByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19VUFNDQUxFJykpIHtcbiAgICAgICAgICB2YXIgc2NhbGFyID0gMjA0OCAvIGltYWdlV2lkdGg7XG4gICAgICAgICAgaW1hZ2VXaWR0aCAqPSBzY2FsYXI7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgKj0gc2NhbGFyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW1hZ2UgYXNwZWN0IHJhdGlvXG4gICAgICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2VIZWlnaHQgLyBpbWFnZVdpZHRoO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdGhlIGl0ZW0gdG8gZ2V0IHRvIHRoZSBjcm9wIHNpemVcbiAgICAgICAgdmFyIHByZXZpZXdBc3BlY3RSYXRpbyA9XG4gICAgICAgICAgKGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKSB8fCB7fSkuYXNwZWN0UmF0aW8gfHwgaW1hZ2VBc3BlY3RSYXRpbztcblxuICAgICAgICAvLyBwcmV2aWV3IGhlaWdodCByYW5nZVxuICAgICAgICB2YXIgcHJldmlld0hlaWdodE1heCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1pblByZXZpZXdIZWlnaHQsXG4gICAgICAgICAgTWF0aC5taW4oaW1hZ2VIZWlnaHQsIG1heFByZXZpZXdIZWlnaHQpXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICB2YXIgcHJldmlld0hlaWdodCA9IE1hdGgubWluKFxuICAgICAgICAgIGl0ZW1XaWR0aCAqIHByZXZpZXdBc3BlY3RSYXRpbyxcbiAgICAgICAgICBwcmV2aWV3SGVpZ2h0TWF4XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCB1cGRhdGUgdG8gcGFuZWwgaGVpZ2h0XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9VUERBVEVfUEFORUxfSEVJR0hUJywge1xuICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgIGhlaWdodDogcHJldmlld0hlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaWRSZXNpemVWaWV3ID0gZnVuY3Rpb24gZGlkUmVzaXplVmlldyhfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3Q7XG4gICAgICAgIC8vIGFjdGlvbnMgaW4gbmV4dCB3cml0ZSBvcGVyYXRpb25cbiAgICAgICAgcm9vdC5yZWYuc2hvdWxkUmVzY2FsZSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlkVXBkYXRlSXRlbU1ldGFkYXRhID0gZnVuY3Rpb24gZGlkVXBkYXRlSXRlbU1ldGFkYXRhKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIGlmIChhY3Rpb24uY2hhbmdlLmtleSAhPT0gJ2Nyb3AnKSByZXR1cm47XG5cbiAgICAgICAgLy8gYWN0aW9ucyBpbiBuZXh0IHdyaXRlIG9wZXJhdGlvblxuICAgICAgICByb290LnJlZi5zaG91bGRSZXNjYWxlID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaWRDYWxjdWxhdGVQcmV2aWV3U2l6ZSA9IGZ1bmN0aW9uIGRpZENhbGN1bGF0ZVByZXZpZXdTaXplKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICAgIC8vIHJlbWVtYmVyIGRpbWVuc2lvbnNcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VXaWR0aCA9IGFjdGlvbi53aWR0aDtcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VIZWlnaHQgPSBhY3Rpb24uaGVpZ2h0O1xuXG4gICAgICAgIC8vIGFjdGlvbnMgaW4gbmV4dCB3cml0ZSBvcGVyYXRpb25cbiAgICAgICAgcm9vdC5yZWYuc2hvdWxkUmVzY2FsZSA9IHRydWU7XG4gICAgICAgIHJvb3QucmVmLnNob3VsZERyYXdQcmV2aWV3ID0gdHJ1ZTtcblxuICAgICAgICAvLyBhcyBpbWFnZSBsb2FkIGNvdWxkIHRha2UgYSB3aGlsZSBhbmQgZmlyZSB3aGVuIGRyYXcgbG9vcCBpcyByZXN0aW5nIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIGtpY2tcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnS0lDSycpO1xuICAgICAgfTtcblxuICAgICAgLy8gc3RhcnQgd3JpdGluZ1xuICAgICAgdmlldy5yZWdpc3RlcldyaXRlcihcbiAgICAgICAgY3JlYXRlUm91dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgRElEX1JFU0laRV9ST09UOiBkaWRSZXNpemVWaWV3LFxuICAgICAgICAgICAgRElEX1NUT1BfUkVTSVpFOiBkaWRSZXNpemVWaWV3LFxuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgICAgICAgICBESURfSU1BR0VfUFJFVklFV19DQUxDVUxBVEVfU0laRTogZGlkQ2FsY3VsYXRlUHJldmlld1NpemUsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzO1xuICAgICAgICAgICAgLy8gbm8gcHJldmlldyB2aWV3IGF0dGFjaGVkXG4gICAgICAgICAgICBpZiAoIXJvb3QucmVmLmltYWdlUHJldmlldykgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyB3aGlsZSBoaWRkZW5cbiAgICAgICAgICAgIGlmIChyb290LnJlY3QuZWxlbWVudC5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICAgICAgLy8gcmVzaXplIHRoZSBpdGVtIHBhbmVsXG4gICAgICAgICAgICBpZiAocm9vdC5yZWYuc2hvdWxkUmVzY2FsZSkge1xuICAgICAgICAgICAgICByZXNjYWxlSXRlbShyb290LCBwcm9wcyk7XG4gICAgICAgICAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvb3QucmVmLnNob3VsZERyYXdQcmV2aWV3KSB7XG4gICAgICAgICAgICAgIC8vIHF1ZXVlIHRpbGwgbmV4dCBmcmFtZSBzbyB3ZSdyZSBzdXJlIHRoZSBoZWlnaHQgaGFzIGJlZW4gYXBwbGllZCB0aGlzIGZvcmNlcyB0aGUgZHJhdyBpbWFnZSBjYWxsIGluc2lkZSB0aGUgd3JhcHBlciB2aWV3IHRvIHVzZSB0aGUgY29ycmVjdCBoZWlnaHRcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG5lc3RpbmcgaXMgaG9ycmlibGUgYnV0IGl0IGZpeGVzIGFuIGlzc3VlIHdpdGggMTAwaHogZGlzcGxheXMgb24gQ2hyb21lXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BxaW5hL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2lzc3Vlcy81N1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9GSU5JU0hfQ0FMQ1VMQVRFX1BSRVZJRVdTSVpFJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogcHJvcHMuaWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByb290LnJlZi5zaG91bGREcmF3UHJldmlldyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIGV4cG9zZSBwbHVnaW5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBpbWFnZSBwcmV2aWV3XG4gICAgICAgIGFsbG93SW1hZ2VQcmV2aWV3OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBmaWx0ZXJzIGZpbGUgaXRlbXMgdG8gZGV0ZXJtaW5lIHdoaWNoIGFyZSBzaG93biBhcyBwcmV2aWV3XG4gICAgICAgIGltYWdlUHJldmlld0ZpbHRlckl0ZW06IFtcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgVHlwZS5GVU5DVElPTlxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIEZpeGVkIHByZXZpZXcgaGVpZ2h0XG4gICAgICAgIGltYWdlUHJldmlld0hlaWdodDogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNaW4gaW1hZ2UgaGVpZ2h0XG4gICAgICAgIGltYWdlUHJldmlld01pbkhlaWdodDogWzQ0LCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWF4IGltYWdlIGhlaWdodFxuICAgICAgICBpbWFnZVByZXZpZXdNYXhIZWlnaHQ6IFsyNTYsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNYXggc2l6ZSBvZiBwcmV2aWV3IGZpbGUgZm9yIHdoZW4gY3JlYXRlSW1hZ2VCaXRtYXAgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICBpbWFnZVByZXZpZXdNYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIGV4dHJhIHBpeGVscyBhZGRlZCB0byB0aGUgaW1hZ2UgcHJldmlldyB0byBhbGxvdyBjb21mb3J0YWJsZSB6b29taW5nXG4gICAgICAgIGltYWdlUHJldmlld1pvb21GYWN0b3I6IFsyLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gU2hvdWxkIHdlIHVwc2NhbGUgc21hbGwgaW1hZ2VzIHRvIGZpdCB0aGUgbWF4IGJvdW5kaW5nIGJveCBvZiB0aGUgcHJldmlldyBhcmVhXG4gICAgICAgIGltYWdlUHJldmlld1Vwc2NhbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBNYXggc2l6ZSBvZiBwcmV2aWV3IGZpbGUgdGhhdCB3ZSBhbGxvdyB0byB0cnkgdG8gaW5zdGFudCBwcmV2aWV3IGlmIGNyZWF0ZUltYWdlQml0bWFwIGlzIG5vdCBzdXBwb3J0ZWQsIGVsc2UgaW1hZ2UgaXMgcXVldWVkIGZvciBsb2FkaW5nXG4gICAgICAgIGltYWdlUHJldmlld01heEluc3RhbnRQcmV2aWV3RmlsZVNpemU6IFsxMDAwMDAwLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gU3R5bGUgb2YgdGhlIHRyYW5zcGFyYW5jeSBpbmRpY2F0b3IgdXNlZCBiZWhpbmQgaW1hZ2VzXG4gICAgICAgIGltYWdlUHJldmlld1RyYW5zcGFyZW5jeUluZGljYXRvcjogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBFbmFibGVzIG9yIGRpc2FibGVzIHJlYWRpbmcgYXZlcmFnZSBpbWFnZSBjb2xvclxuICAgICAgICBpbWFnZVByZXZpZXdDYWxjdWxhdGVBdmVyYWdlSW1hZ2VDb2xvcjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHByZXZpZXdpbmcgb2YgbWFya3VwXG4gICAgICAgIGltYWdlUHJldmlld01hcmt1cFNob3c6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIEFsbG93cyBmaWx0ZXJpbmcgb2YgbWFya3VwIHRvIG9ubHkgc2hvdyBjZXJ0YWluIHNoYXBlc1xuICAgICAgICBpbWFnZVByZXZpZXdNYXJrdXBGaWx0ZXI6IFtcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgVHlwZS5GVU5DVElPTlxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBmaXJlIHBsdWdpbmxvYWRlZCBldmVudCBpZiBydW5uaW5nIGluIGJyb3dzZXIsIHRoaXMgYWxsb3dzIHJlZ2lzdGVyaW5nIHRoZSBwbHVnaW4gd2hlbiB1c2luZyBhc3luYyBzY3JpcHQgdGFnc1xuICB2YXIgaXNCcm93c2VyID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*!\n * FilePond 4.32.6\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n     true\n        ? factory(exports)\n        : 0;\n})(this, function(exports) {\n    'use strict';\n\n    var isNode = function isNode(value) {\n        return value instanceof HTMLElement;\n    };\n\n    var createStore = function createStore(initialState) {\n        var queries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        // internal state\n        var state = Object.assign({}, initialState);\n\n        // contains all actions for next frame, is clear when actions are requested\n        var actionQueue = [];\n        var dispatchQueue = [];\n\n        // returns a duplicate of the current state\n        var getState = function getState() {\n            return Object.assign({}, state);\n        };\n\n        // returns a duplicate of the actions array and clears the actions array\n        var processActionQueue = function processActionQueue() {\n            // create copy of actions queue\n            var queue = [].concat(actionQueue);\n\n            // clear actions queue (we don't want no double actions)\n            actionQueue.length = 0;\n\n            return queue;\n        };\n\n        // processes actions that might block the main UI thread\n        var processDispatchQueue = function processDispatchQueue() {\n            // create copy of actions queue\n            var queue = [].concat(dispatchQueue);\n\n            // clear actions queue (we don't want no double actions)\n            dispatchQueue.length = 0;\n\n            // now dispatch these actions\n            queue.forEach(function(_ref) {\n                var type = _ref.type,\n                    data = _ref.data;\n                dispatch(type, data);\n            });\n        };\n\n        // adds a new action, calls its handler and\n        var dispatch = function dispatch(type, data, isBlocking) {\n            // is blocking action (should never block if document is hidden)\n            if (isBlocking && !document.hidden) {\n                dispatchQueue.push({ type: type, data: data });\n                return;\n            }\n\n            // if this action has a handler, handle the action\n            if (actionHandlers[type]) {\n                actionHandlers[type](data);\n            }\n\n            // now add action\n            actionQueue.push({\n                type: type,\n                data: data,\n            });\n        };\n\n        var query = function query(str) {\n            var _queryHandles;\n            for (\n                var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                args[_key - 1] = arguments[_key];\n            }\n            return queryHandles[str]\n                ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n                : null;\n        };\n\n        var api = {\n            getState: getState,\n            processActionQueue: processActionQueue,\n            processDispatchQueue: processDispatchQueue,\n            dispatch: dispatch,\n            query: query,\n        };\n\n        var queryHandles = {};\n        queries.forEach(function(query) {\n            queryHandles = Object.assign({}, query(state), {}, queryHandles);\n        });\n\n        var actionHandlers = {};\n        actions.forEach(function(action) {\n            actionHandlers = Object.assign({}, action(dispatch, query, state), {}, actionHandlers);\n        });\n\n        return api;\n    };\n\n    var defineProperty = function defineProperty(obj, property, definition) {\n        if (typeof definition === 'function') {\n            obj[property] = definition;\n            return;\n        }\n        Object.defineProperty(obj, property, Object.assign({}, definition));\n    };\n\n    var forin = function forin(obj, cb) {\n        for (var key in obj) {\n            if (!obj.hasOwnProperty(key)) {\n                continue;\n            }\n\n            cb(key, obj[key]);\n        }\n    };\n\n    var createObject = function createObject(definition) {\n        var obj = {};\n        forin(definition, function(property) {\n            defineProperty(obj, property, definition[property]);\n        });\n        return obj;\n    };\n\n    var attr = function attr(node, name) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        if (value === null) {\n            return node.getAttribute(name) || node.hasAttribute(name);\n        }\n        node.setAttribute(name, value);\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var svgElements = ['svg', 'path']; // only svg elements used\n\n    var isSVGElement = function isSVGElement(tag) {\n        return svgElements.includes(tag);\n    };\n\n    var createElement = function createElement(tag, className) {\n        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (typeof className === 'object') {\n            attributes = className;\n            className = null;\n        }\n        var element = isSVGElement(tag)\n            ? document.createElementNS(ns, tag)\n            : document.createElement(tag);\n        if (className) {\n            if (isSVGElement(tag)) {\n                attr(element, 'class', className);\n            } else {\n                element.className = className;\n            }\n        }\n        forin(attributes, function(name, value) {\n            attr(element, name, value);\n        });\n        return element;\n    };\n\n    var appendChild = function appendChild(parent) {\n        return function(child, index) {\n            if (typeof index !== 'undefined' && parent.children[index]) {\n                parent.insertBefore(child, parent.children[index]);\n            } else {\n                parent.appendChild(child);\n            }\n        };\n    };\n\n    var appendChildView = function appendChildView(parent, childViews) {\n        return function(view, index) {\n            if (typeof index !== 'undefined') {\n                childViews.splice(index, 0, view);\n            } else {\n                childViews.push(view);\n            }\n\n            return view;\n        };\n    };\n\n    var removeChildView = function removeChildView(parent, childViews) {\n        return function(view) {\n            // remove from child views\n            childViews.splice(childViews.indexOf(view), 1);\n\n            // remove the element\n            if (view.element.parentNode) {\n                parent.removeChild(view.element);\n            }\n\n            return view;\n        };\n    };\n\n    var IS_BROWSER = (function() {\n        return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n    })();\n    var isBrowser = function isBrowser() {\n        return IS_BROWSER;\n    };\n\n    var testElement = isBrowser() ? createElement('svg') : {};\n    var getChildCount =\n        'children' in testElement\n            ? function(el) {\n                  return el.children.length;\n              }\n            : function(el) {\n                  return el.childNodes.length;\n              };\n\n    var getViewRect = function getViewRect(elementRect, childViews, offset, scale) {\n        var left = offset[0] || elementRect.left;\n        var top = offset[1] || elementRect.top;\n        var right = left + elementRect.width;\n        var bottom = top + elementRect.height * (scale[1] || 1);\n\n        var rect = {\n            // the rectangle of the element itself\n            element: Object.assign({}, elementRect),\n\n            // the rectangle of the element expanded to contain its children, does not include any margins\n            inner: {\n                left: elementRect.left,\n                top: elementRect.top,\n                right: elementRect.right,\n                bottom: elementRect.bottom,\n            },\n\n            // the rectangle of the element expanded to contain its children including own margin and child margins\n            // margins will be added after we've recalculated the size\n            outer: {\n                left: left,\n                top: top,\n                right: right,\n                bottom: bottom,\n            },\n        };\n\n        // expand rect to fit all child rectangles\n        childViews\n            .filter(function(childView) {\n                return !childView.isRectIgnored();\n            })\n            .map(function(childView) {\n                return childView.rect;\n            })\n            .forEach(function(childViewRect) {\n                expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n                expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n            });\n\n        // calculate inner width and height\n        calculateRectSize(rect.inner);\n\n        // append additional margin (top and left margins are included in top and left automatically)\n        rect.outer.bottom += rect.element.marginBottom;\n        rect.outer.right += rect.element.marginRight;\n\n        // calculate outer width and height\n        calculateRectSize(rect.outer);\n\n        return rect;\n    };\n\n    var expandRect = function expandRect(parent, child) {\n        // adjust for parent offset\n        child.top += parent.top;\n        child.right += parent.left;\n        child.bottom += parent.top;\n        child.left += parent.left;\n\n        if (child.bottom > parent.bottom) {\n            parent.bottom = child.bottom;\n        }\n\n        if (child.right > parent.right) {\n            parent.right = child.right;\n        }\n    };\n\n    var calculateRectSize = function calculateRectSize(rect) {\n        rect.width = rect.right - rect.left;\n        rect.height = rect.bottom - rect.top;\n    };\n\n    var isNumber = function isNumber(value) {\n        return typeof value === 'number';\n    };\n\n    /**\n     * Determines if position is at destination\n     * @param position\n     * @param destination\n     * @param velocity\n     * @param errorMargin\n     * @returns {boolean}\n     */\n    var thereYet = function thereYet(position, destination, velocity) {\n        var errorMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n        return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n    };\n\n    /**\n     * Spring animation\n     */\n    var spring =\n        // default options\n        function spring() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$stiffness = _ref.stiffness,\n                stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n                _ref$damping = _ref.damping,\n                damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n                _ref$mass = _ref.mass,\n                mass = _ref$mass === void 0 ? 10 : _ref$mass;\n            var target = null;\n            var position = null;\n            var velocity = 0;\n            var resting = false;\n\n            // updates spring state\n            var interpolate = function interpolate(ts, skipToEndState) {\n                // in rest, don't animate\n                if (resting) return;\n\n                // need at least a target or position to do springy things\n                if (!(isNumber(target) && isNumber(position))) {\n                    resting = true;\n                    velocity = 0;\n                    return;\n                }\n\n                // calculate spring force\n                var f = -(position - target) * stiffness;\n\n                // update velocity by adding force based on mass\n                velocity += f / mass;\n\n                // update position by adding velocity\n                position += velocity;\n\n                // slow down based on amount of damping\n                velocity *= damping;\n\n                // we've arrived if we're near target and our velocity is near zero\n                if (thereYet(position, target, velocity) || skipToEndState) {\n                    position = target;\n                    velocity = 0;\n                    resting = true;\n\n                    // we done\n                    api.onupdate(position);\n                    api.oncomplete(position);\n                } else {\n                    // progress update\n                    api.onupdate(position);\n                }\n            };\n\n            /**\n             * Set new target value\n             * @param value\n             */\n            var setTarget = function setTarget(value) {\n                // if currently has no position, set target and position to this value\n                if (isNumber(value) && !isNumber(position)) {\n                    position = value;\n                }\n\n                // next target value will not be animated to\n                if (target === null) {\n                    target = value;\n                    position = value;\n                }\n\n                // let start moving to target\n                target = value;\n\n                // already at target\n                if (position === target || typeof target === 'undefined') {\n                    // now resting as target is current position, stop moving\n                    resting = true;\n                    velocity = 0;\n\n                    // done!\n                    api.onupdate(position);\n                    api.oncomplete(position);\n\n                    return;\n                }\n\n                resting = false;\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    set: setTarget,\n                    get: function get() {\n                        return target;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var easeLinear = function easeLinear(t) {\n        return t;\n    };\n    var easeInOutQuad = function easeInOutQuad(t) {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    };\n\n    var tween =\n        // default values\n        function tween() // method definition\n        {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$duration = _ref.duration,\n                duration = _ref$duration === void 0 ? 500 : _ref$duration,\n                _ref$easing = _ref.easing,\n                easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n                _ref$delay = _ref.delay,\n                delay = _ref$delay === void 0 ? 0 : _ref$delay;\n            var start = null;\n            var t;\n            var p;\n            var resting = true;\n            var reverse = false;\n            var target = null;\n\n            var interpolate = function interpolate(ts, skipToEndState) {\n                if (resting || target === null) return;\n\n                if (start === null) {\n                    start = ts;\n                }\n\n                if (ts - start < delay) return;\n\n                t = ts - start - delay;\n\n                if (t >= duration || skipToEndState) {\n                    t = 1;\n                    p = reverse ? 0 : 1;\n                    api.onupdate(p * target);\n                    api.oncomplete(p * target);\n                    resting = true;\n                } else {\n                    p = t / duration;\n                    api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n                }\n            };\n\n            // need 'api' to call onupdate callback\n            var api = createObject({\n                interpolate: interpolate,\n                target: {\n                    get: function get() {\n                        return reverse ? 0 : target;\n                    },\n                    set: function set(value) {\n                        // is initial value\n                        if (target === null) {\n                            target = value;\n                            api.onupdate(value);\n                            api.oncomplete(value);\n                            return;\n                        }\n\n                        // want to tween to a smaller value and have a current value\n                        if (value < target) {\n                            target = 1;\n                            reverse = true;\n                        } else {\n                            // not tweening to a smaller value\n                            reverse = false;\n                            target = value;\n                        }\n\n                        // let's go!\n                        resting = false;\n                        start = null;\n                    },\n                },\n\n                resting: {\n                    get: function get() {\n                        return resting;\n                    },\n                },\n\n                onupdate: function onupdate(value) {},\n                oncomplete: function oncomplete(value) {},\n            });\n\n            return api;\n        };\n\n    var animator = {\n        spring: spring,\n        tween: tween,\n    };\n\n    /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n    var createAnimator = function createAnimator(definition, category, property) {\n        // default is single definition\n        // we check if transform is set, if so, we check if property is set\n        var def =\n            definition[category] && typeof definition[category][property] === 'object'\n                ? definition[category][property]\n                : definition[category] || definition;\n\n        var type = typeof def === 'string' ? def : def.type;\n        var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n        return animator[type] ? animator[type](props) : null;\n    };\n\n    var addGetSet = function addGetSet(keys, obj, props) {\n        var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        obj = Array.isArray(obj) ? obj : [obj];\n        obj.forEach(function(o) {\n            keys.forEach(function(key) {\n                var name = key;\n                var getter = function getter() {\n                    return props[key];\n                };\n                var setter = function setter(value) {\n                    return (props[key] = value);\n                };\n\n                if (typeof key === 'object') {\n                    name = key.key;\n                    getter = key.getter || getter;\n                    setter = key.setter || setter;\n                }\n\n                if (o[name] && !overwrite) {\n                    return;\n                }\n\n                o[name] = {\n                    get: getter,\n                    set: setter,\n                };\n            });\n        });\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // setup animators\n\n    var animations = function animations(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI;\n        // initial properties\n        var initialProps = Object.assign({}, viewProps);\n\n        // list of all active animations\n        var animations = [];\n\n        // setup animators\n        forin(mixinConfig, function(property, animation) {\n            var animator = createAnimator(animation);\n            if (!animator) {\n                return;\n            }\n\n            // when the animator updates, update the view state value\n            animator.onupdate = function(value) {\n                viewProps[property] = value;\n            };\n\n            // set animator target\n            animator.target = initialProps[property];\n\n            // when value is set, set the animator target value\n            var prop = {\n                key: property,\n                setter: function setter(value) {\n                    // if already at target, we done!\n                    if (animator.target === value) {\n                        return;\n                    }\n\n                    animator.target = value;\n                },\n                getter: function getter() {\n                    return viewProps[property];\n                },\n            };\n\n            // add getters and setters\n            addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n            // add it to the list for easy updating from the _write method\n            animations.push(animator);\n        });\n\n        // expose internal write api\n        return {\n            write: function write(ts) {\n                var skipToEndState = document.hidden;\n                var resting = true;\n                animations.forEach(function(animation) {\n                    if (!animation.resting) resting = false;\n                    animation.interpolate(ts, skipToEndState);\n                });\n                return resting;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var addEvent = function addEvent(element) {\n        return function(type, fn) {\n            element.addEventListener(type, fn);\n        };\n    };\n\n    var removeEvent = function removeEvent(element) {\n        return function(type, fn) {\n            element.removeEventListener(type, fn);\n        };\n    };\n\n    // mixin\n    var listeners = function listeners(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            viewState = _ref.viewState,\n            view = _ref.view;\n        var events = [];\n\n        var add = addEvent(view.element);\n        var remove = removeEvent(view.element);\n\n        viewExternalAPI.on = function(type, fn) {\n            events.push({\n                type: type,\n                fn: fn,\n            });\n\n            add(type, fn);\n        };\n\n        viewExternalAPI.off = function(type, fn) {\n            events.splice(\n                events.findIndex(function(event) {\n                    return event.type === type && event.fn === fn;\n                }),\n                1\n            );\n\n            remove(type, fn);\n        };\n\n        return {\n            write: function write() {\n                // not busy\n                return true;\n            },\n            destroy: function destroy() {\n                events.forEach(function(event) {\n                    remove(event.type, event.fn);\n                });\n            },\n        };\n    };\n\n    // add to external api and link to props\n\n    var apis = function apis(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewExternalAPI = _ref.viewExternalAPI;\n        addGetSet(mixinConfig, viewExternalAPI, viewProps);\n    };\n\n    var isDefined = function isDefined(value) {\n        return value != null;\n    };\n\n    // add to state,\n    // add getters and setters to internal and external api (if not set)\n    // set initial state based on props in viewProps\n    // apply as transforms each frame\n\n    var defaults = {\n        opacity: 1,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        rotateX: 0,\n        rotateY: 0,\n        rotateZ: 0,\n        originX: 0,\n        originY: 0,\n    };\n\n    var styles = function styles(_ref) {\n        var mixinConfig = _ref.mixinConfig,\n            viewProps = _ref.viewProps,\n            viewInternalAPI = _ref.viewInternalAPI,\n            viewExternalAPI = _ref.viewExternalAPI,\n            view = _ref.view;\n        // initial props\n        var initialProps = Object.assign({}, viewProps);\n\n        // current props\n        var currentProps = {};\n\n        // we will add those properties to the external API and link them to the viewState\n        addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n        // override rect on internal and external rect getter so it takes in account transforms\n        var getOffset = function getOffset() {\n            return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n        };\n\n        var getScale = function getScale() {\n            return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n        };\n        var getRect = function getRect() {\n            return view.rect\n                ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n                : null;\n        };\n        viewInternalAPI.rect = { get: getRect };\n        viewExternalAPI.rect = { get: getRect };\n\n        // apply view props\n        mixinConfig.forEach(function(key) {\n            viewProps[key] =\n                typeof initialProps[key] === 'undefined' ? defaults[key] : initialProps[key];\n        });\n\n        // expose api\n        return {\n            write: function write() {\n                // see if props have changed\n                if (!propsHaveChanged(currentProps, viewProps)) {\n                    return;\n                }\n\n                // moves element to correct position on screen\n                applyStyles(view.element, viewProps);\n\n                // store new transforms\n                Object.assign(currentProps, Object.assign({}, viewProps));\n\n                // no longer busy\n                return true;\n            },\n            destroy: function destroy() {},\n        };\n    };\n\n    var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n        // different amount of keys\n        if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n            return true;\n        }\n\n        // lets analyze the individual props\n        for (var prop in newProps) {\n            if (newProps[prop] !== currentProps[prop]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    var applyStyles = function applyStyles(element, _ref2) {\n        var opacity = _ref2.opacity,\n            perspective = _ref2.perspective,\n            translateX = _ref2.translateX,\n            translateY = _ref2.translateY,\n            scaleX = _ref2.scaleX,\n            scaleY = _ref2.scaleY,\n            rotateX = _ref2.rotateX,\n            rotateY = _ref2.rotateY,\n            rotateZ = _ref2.rotateZ,\n            originX = _ref2.originX,\n            originY = _ref2.originY,\n            width = _ref2.width,\n            height = _ref2.height;\n\n        var transforms = '';\n        var styles = '';\n\n        // handle transform origin\n        if (isDefined(originX) || isDefined(originY)) {\n            styles += 'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n        }\n\n        // transform order is relevant\n        // 0. perspective\n        if (isDefined(perspective)) {\n            transforms += 'perspective(' + perspective + 'px) ';\n        }\n\n        // 1. translate\n        if (isDefined(translateX) || isDefined(translateY)) {\n            transforms +=\n                'translate3d(' + (translateX || 0) + 'px, ' + (translateY || 0) + 'px, 0) ';\n        }\n\n        // 2. scale\n        if (isDefined(scaleX) || isDefined(scaleY)) {\n            transforms +=\n                'scale3d(' +\n                (isDefined(scaleX) ? scaleX : 1) +\n                ', ' +\n                (isDefined(scaleY) ? scaleY : 1) +\n                ', 1) ';\n        }\n\n        // 3. rotate\n        if (isDefined(rotateZ)) {\n            transforms += 'rotateZ(' + rotateZ + 'rad) ';\n        }\n\n        if (isDefined(rotateX)) {\n            transforms += 'rotateX(' + rotateX + 'rad) ';\n        }\n\n        if (isDefined(rotateY)) {\n            transforms += 'rotateY(' + rotateY + 'rad) ';\n        }\n\n        // add transforms\n        if (transforms.length) {\n            styles += 'transform:' + transforms + ';';\n        }\n\n        // add opacity\n        if (isDefined(opacity)) {\n            styles += 'opacity:' + opacity + ';';\n\n            // if we reach zero, we make the element inaccessible\n            if (opacity === 0) {\n                styles += 'visibility:hidden;';\n            }\n\n            // if we're below 100% opacity this element can't be clicked\n            if (opacity < 1) {\n                styles += 'pointer-events:none;';\n            }\n        }\n\n        // add height\n        if (isDefined(height)) {\n            styles += 'height:' + height + 'px;';\n        }\n\n        // add width\n        if (isDefined(width)) {\n            styles += 'width:' + width + 'px;';\n        }\n\n        // apply styles\n        var elementCurrentStyle = element.elementCurrentStyle || '';\n\n        // if new styles does not match current styles, lets update!\n        if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n            element.style.cssText = styles;\n            // store current styles so we can compare them to new styles later on\n            // _not_ getting the style value is faster\n            element.elementCurrentStyle = styles;\n        }\n    };\n\n    var Mixins = {\n        styles: styles,\n        listeners: listeners,\n        animations: animations,\n        apis: apis,\n    };\n\n    var updateRect = function updateRect() {\n        var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!element.layoutCalculated) {\n            rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n            rect.marginTop = parseInt(style.marginTop, 10) || 0;\n            rect.marginRight = parseInt(style.marginRight, 10) || 0;\n            rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n            rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n            element.layoutCalculated = true;\n        }\n\n        rect.left = element.offsetLeft || 0;\n        rect.top = element.offsetTop || 0;\n        rect.width = element.offsetWidth || 0;\n        rect.height = element.offsetHeight || 0;\n\n        rect.right = rect.left + rect.width;\n        rect.bottom = rect.top + rect.height;\n\n        rect.scrollTop = element.scrollTop;\n\n        rect.hidden = element.offsetParent === null;\n\n        return rect;\n    };\n\n    var createView =\n        // default view definition\n        function createView() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref$tag = _ref.tag,\n                tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n                _ref$name = _ref.name,\n                name = _ref$name === void 0 ? null : _ref$name,\n                _ref$attributes = _ref.attributes,\n                attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n                _ref$read = _ref.read,\n                read = _ref$read === void 0 ? function() {} : _ref$read,\n                _ref$write = _ref.write,\n                write = _ref$write === void 0 ? function() {} : _ref$write,\n                _ref$create = _ref.create,\n                create = _ref$create === void 0 ? function() {} : _ref$create,\n                _ref$destroy = _ref.destroy,\n                destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n                _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n                filterFrameActionsForChild =\n                    _ref$filterFrameActio === void 0\n                        ? function(child, actions) {\n                              return actions;\n                          }\n                        : _ref$filterFrameActio,\n                _ref$didCreateView = _ref.didCreateView,\n                didCreateView = _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n                _ref$didWriteView = _ref.didWriteView,\n                didWriteView = _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n                _ref$ignoreRect = _ref.ignoreRect,\n                ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n                _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n                ignoreRectUpdate = _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n                _ref$mixins = _ref.mixins,\n                mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n            return function(\n                // each view requires reference to store\n                store\n            ) {\n                var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                // root element should not be changed\n                var element = createElement(tag, 'filepond--' + name, attributes);\n\n                // style reference should also not be changed\n                var style = window.getComputedStyle(element, null);\n\n                // element rectangle\n                var rect = updateRect();\n                var frameRect = null;\n\n                // rest state\n                var isResting = false;\n\n                // pretty self explanatory\n                var childViews = [];\n\n                // loaded mixins\n                var activeMixins = [];\n\n                // references to created children\n                var ref = {};\n\n                // state used for each instance\n                var state = {};\n\n                // list of writers that will be called to update this view\n                var writers = [\n                    write, // default writer\n                ];\n\n                var readers = [\n                    read, // default reader\n                ];\n\n                var destroyers = [\n                    destroy, // default destroy\n                ];\n\n                // core view methods\n                var getElement = function getElement() {\n                    return element;\n                };\n                var getChildViews = function getChildViews() {\n                    return childViews.concat();\n                };\n                var getReference = function getReference() {\n                    return ref;\n                };\n                var createChildView = function createChildView(store) {\n                    return function(view, props) {\n                        return view(store, props);\n                    };\n                };\n                var getRect = function getRect() {\n                    if (frameRect) {\n                        return frameRect;\n                    }\n                    frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n                    return frameRect;\n                };\n                var getStyle = function getStyle() {\n                    return style;\n                };\n\n                /**\n                 * Read data from DOM\n                 * @private\n                 */\n                var _read = function _read() {\n                    frameRect = null;\n\n                    // read child views\n                    childViews.forEach(function(child) {\n                        return child._read();\n                    });\n\n                    var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n                    if (shouldUpdate) {\n                        updateRect(rect, element, style);\n                    }\n\n                    // readers\n                    var api = { root: internalAPI, props: props, rect: rect };\n                    readers.forEach(function(reader) {\n                        return reader(api);\n                    });\n                };\n\n                /**\n                 * Write data to DOM\n                 * @private\n                 */\n                var _write = function _write(ts, frameActions, shouldOptimize) {\n                    // if no actions, we assume that the view is resting\n                    var resting = frameActions.length === 0;\n\n                    // writers\n                    writers.forEach(function(writer) {\n                        var writerResting = writer({\n                            props: props,\n                            root: internalAPI,\n                            actions: frameActions,\n                            timestamp: ts,\n                            shouldOptimize: shouldOptimize,\n                        });\n\n                        if (writerResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // run mixins\n                    activeMixins.forEach(function(mixin) {\n                        // if one of the mixins is still busy after write operation, we are not resting\n                        var mixinResting = mixin.write(ts);\n                        if (mixinResting === false) {\n                            resting = false;\n                        }\n                    });\n\n                    // updates child views that are currently attached to the DOM\n                    childViews\n                        .filter(function(child) {\n                            return !!child.element.parentNode;\n                        })\n                        .forEach(function(child) {\n                            // if a child view is not resting, we are not resting\n                            var childResting = child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            if (!childResting) {\n                                resting = false;\n                            }\n                        });\n\n                    // append new elements to DOM and update those\n                    childViews\n                        //.filter(child => !child.element.parentNode)\n                        .forEach(function(child, index) {\n                            // skip\n                            if (child.element.parentNode) {\n                                return;\n                            }\n\n                            // append to DOM\n                            internalAPI.appendChild(child.element, index);\n\n                            // call read (need to know the size of these elements)\n                            child._read();\n\n                            // re-call write\n                            child._write(\n                                ts,\n                                filterFrameActionsForChild(child, frameActions),\n                                shouldOptimize\n                            );\n\n                            // we just added somthing to the dom, no rest\n                            resting = false;\n                        });\n\n                    // update resting state\n                    isResting = resting;\n\n                    didWriteView({\n                        props: props,\n                        root: internalAPI,\n                        actions: frameActions,\n                        timestamp: ts,\n                    });\n\n                    // let parent know if we are resting\n                    return resting;\n                };\n\n                var _destroy = function _destroy() {\n                    activeMixins.forEach(function(mixin) {\n                        return mixin.destroy();\n                    });\n                    destroyers.forEach(function(destroyer) {\n                        destroyer({ root: internalAPI, props: props });\n                    });\n                    childViews.forEach(function(child) {\n                        return child._destroy();\n                    });\n                };\n\n                // sharedAPI\n                var sharedAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    style: {\n                        get: getStyle,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n                };\n\n                // private API definition\n                var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: getRect,\n                    },\n\n                    // access to custom children references\n                    ref: {\n                        get: getReference,\n                    },\n\n                    // dom modifiers\n                    is: function is(needle) {\n                        return name === needle;\n                    },\n                    appendChild: appendChild(element),\n                    createChildView: createChildView(store),\n                    linkView: function linkView(view) {\n                        childViews.push(view);\n                        return view;\n                    },\n                    unlinkView: function unlinkView(view) {\n                        childViews.splice(childViews.indexOf(view), 1);\n                    },\n                    appendChildView: appendChildView(element, childViews),\n                    removeChildView: removeChildView(element, childViews),\n                    registerWriter: function registerWriter(writer) {\n                        return writers.push(writer);\n                    },\n                    registerReader: function registerReader(reader) {\n                        return readers.push(reader);\n                    },\n                    registerDestroyer: function registerDestroyer(destroyer) {\n                        return destroyers.push(destroyer);\n                    },\n                    invalidateLayout: function invalidateLayout() {\n                        return (element.layoutCalculated = false);\n                    },\n\n                    // access to data store\n                    dispatch: store.dispatch,\n                    query: store.query,\n                });\n\n                // public view API methods\n                var externalAPIDefinition = {\n                    element: {\n                        get: getElement,\n                    },\n\n                    childViews: {\n                        get: getChildViews,\n                    },\n\n                    rect: {\n                        get: getRect,\n                    },\n\n                    resting: {\n                        get: function get() {\n                            return isResting;\n                        },\n                    },\n\n                    isRectIgnored: function isRectIgnored() {\n                        return ignoreRect;\n                    },\n                    _read: _read,\n                    _write: _write,\n                    _destroy: _destroy,\n                };\n\n                // mixin API methods\n                var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n                    rect: {\n                        get: function get() {\n                            return rect;\n                        },\n                    },\n                });\n\n                // add mixin functionality\n                Object.keys(mixins)\n                    .sort(function(a, b) {\n                        // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n                        if (a === 'styles') {\n                            return 1;\n                        } else if (b === 'styles') {\n                            return -1;\n                        }\n                        return 0;\n                    })\n                    .forEach(function(key) {\n                        var mixinAPI = Mixins[key]({\n                            mixinConfig: mixins[key],\n                            viewProps: props,\n                            viewState: state,\n                            viewInternalAPI: internalAPIDefinition,\n                            viewExternalAPI: externalAPIDefinition,\n                            view: createObject(mixinAPIDefinition),\n                        });\n\n                        if (mixinAPI) {\n                            activeMixins.push(mixinAPI);\n                        }\n                    });\n\n                // construct private api\n                var internalAPI = createObject(internalAPIDefinition);\n\n                // create the view\n                create({\n                    root: internalAPI,\n                    props: props,\n                });\n\n                // append created child views to root node\n                var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n                childViews.forEach(function(child, index) {\n                    internalAPI.appendChild(child.element, childCount + index);\n                });\n\n                // call did create\n                didCreateView(internalAPI);\n\n                // expose public api\n                return createObject(externalAPIDefinition);\n            };\n        };\n\n    var createPainter = function createPainter(read, write) {\n        var fps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n        var name = '__framePainter';\n\n        // set global painter\n        if (window[name]) {\n            window[name].readers.push(read);\n            window[name].writers.push(write);\n            return;\n        }\n\n        window[name] = {\n            readers: [read],\n            writers: [write],\n        };\n\n        var painter = window[name];\n\n        var interval = 1000 / fps;\n        var last = null;\n        var id = null;\n        var requestTick = null;\n        var cancelTick = null;\n\n        var setTimerType = function setTimerType() {\n            if (document.hidden) {\n                requestTick = function requestTick() {\n                    return window.setTimeout(function() {\n                        return tick(performance.now());\n                    }, interval);\n                };\n                cancelTick = function cancelTick() {\n                    return window.clearTimeout(id);\n                };\n            } else {\n                requestTick = function requestTick() {\n                    return window.requestAnimationFrame(tick);\n                };\n                cancelTick = function cancelTick() {\n                    return window.cancelAnimationFrame(id);\n                };\n            }\n        };\n\n        document.addEventListener('visibilitychange', function() {\n            if (cancelTick) cancelTick();\n            setTimerType();\n            tick(performance.now());\n        });\n\n        var tick = function tick(ts) {\n            // queue next tick\n            id = requestTick(tick);\n\n            // limit fps\n            if (!last) {\n                last = ts;\n            }\n\n            var delta = ts - last;\n\n            if (delta <= interval) {\n                // skip frame\n                return;\n            }\n\n            // align next frame\n            last = ts - (delta % interval);\n\n            // update view\n            painter.readers.forEach(function(read) {\n                return read();\n            });\n            painter.writers.forEach(function(write) {\n                return write(ts);\n            });\n        };\n\n        setTimerType();\n        tick(performance.now());\n\n        return {\n            pause: function pause() {\n                cancelTick(id);\n            },\n        };\n    };\n\n    var createRoute = function createRoute(routes, fn) {\n        return function(_ref) {\n            var root = _ref.root,\n                props = _ref.props,\n                _ref$actions = _ref.actions,\n                actions = _ref$actions === void 0 ? [] : _ref$actions,\n                timestamp = _ref.timestamp,\n                shouldOptimize = _ref.shouldOptimize;\n            actions\n                .filter(function(action) {\n                    return routes[action.type];\n                })\n                .forEach(function(action) {\n                    return routes[action.type]({\n                        root: root,\n                        props: props,\n                        action: action.data,\n                        timestamp: timestamp,\n                        shouldOptimize: shouldOptimize,\n                    });\n                });\n\n            if (fn) {\n                fn({\n                    root: root,\n                    props: props,\n                    actions: actions,\n                    timestamp: timestamp,\n                    shouldOptimize: shouldOptimize,\n                });\n            }\n        };\n    };\n\n    var insertBefore = function insertBefore(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n    };\n\n    var insertAfter = function insertAfter(newNode, referenceNode) {\n        return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n    };\n\n    var isArray = function isArray(value) {\n        return Array.isArray(value);\n    };\n\n    var isEmpty = function isEmpty(value) {\n        return value == null;\n    };\n\n    var trim = function trim(str) {\n        return str.trim();\n    };\n\n    var toString = function toString(value) {\n        return '' + value;\n    };\n\n    var toArray = function toArray(value) {\n        var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n        if (isEmpty(value)) {\n            return [];\n        }\n        if (isArray(value)) {\n            return value;\n        }\n        return toString(value)\n            .split(splitter)\n            .map(trim)\n            .filter(function(str) {\n                return str.length;\n            });\n    };\n\n    var isBoolean = function isBoolean(value) {\n        return typeof value === 'boolean';\n    };\n\n    var toBoolean = function toBoolean(value) {\n        return isBoolean(value) ? value : value === 'true';\n    };\n\n    var isString = function isString(value) {\n        return typeof value === 'string';\n    };\n\n    var toNumber = function toNumber(value) {\n        return isNumber(value)\n            ? value\n            : isString(value)\n            ? toString(value).replace(/[a-z]+/gi, '')\n            : 0;\n    };\n\n    var toInt = function toInt(value) {\n        return parseInt(toNumber(value), 10);\n    };\n\n    var toFloat = function toFloat(value) {\n        return parseFloat(toNumber(value));\n    };\n\n    var isInt = function isInt(value) {\n        return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n    };\n\n    var toBytes = function toBytes(value) {\n        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        // is in bytes\n        if (isInt(value)) {\n            return value;\n        }\n\n        // is natural file size\n        var naturalFileSize = toString(value).trim();\n\n        // if is value in megabytes\n        if (/MB$/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n            return toInt(naturalFileSize) * base * base;\n        }\n\n        // if is value in kilobytes\n        if (/KB/i.test(naturalFileSize)) {\n            naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n            return toInt(naturalFileSize) * base;\n        }\n\n        return toInt(naturalFileSize);\n    };\n\n    var isFunction = function isFunction(value) {\n        return typeof value === 'function';\n    };\n\n    var toFunctionReference = function toFunctionReference(string) {\n        var ref = self;\n        var levels = string.split('.');\n        var level = null;\n        while ((level = levels.shift())) {\n            ref = ref[level];\n            if (!ref) {\n                return null;\n            }\n        }\n        return ref;\n    };\n\n    var methods = {\n        process: 'POST',\n        patch: 'PATCH',\n        revert: 'DELETE',\n        fetch: 'GET',\n        restore: 'GET',\n        load: 'GET',\n    };\n\n    var createServerAPI = function createServerAPI(outline) {\n        var api = {};\n\n        api.url = isString(outline) ? outline : outline.url || '';\n        api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n        api.headers = outline.headers ? outline.headers : {};\n\n        forin(methods, function(key) {\n            api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n        });\n\n        // remove process if no url or process on outline\n        api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n\n        // special treatment for remove\n        api.remove = outline.remove || null;\n\n        // remove generic headers from api object\n        delete api.headers;\n\n        return api;\n    };\n\n    var createAction = function createAction(name, outline, method, timeout, headers) {\n        // is explicitely set to null so disable\n        if (outline === null) {\n            return null;\n        }\n\n        // if is custom function, done! Dev handles everything.\n        if (typeof outline === 'function') {\n            return outline;\n        }\n\n        // build action object\n        var action = {\n            url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n            method: method,\n            headers: headers,\n            withCredentials: false,\n            timeout: timeout,\n            onload: null,\n            ondata: null,\n            onerror: null,\n        };\n\n        // is a single url\n        if (isString(outline)) {\n            action.url = outline;\n            return action;\n        }\n\n        // overwrite\n        Object.assign(action, outline);\n\n        // see if should reformat headers;\n        if (isString(action.headers)) {\n            var parts = action.headers.split(/:(.+)/);\n            action.headers = {\n                header: parts[0],\n                value: parts[1],\n            };\n        }\n\n        // if is bool withCredentials\n        action.withCredentials = toBoolean(action.withCredentials);\n\n        return action;\n    };\n\n    var toServerAPI = function toServerAPI(value) {\n        return createServerAPI(value);\n    };\n\n    var isNull = function isNull(value) {\n        return value === null;\n    };\n\n    var isObject = function isObject(value) {\n        return typeof value === 'object' && value !== null;\n    };\n\n    var isAPI = function isAPI(value) {\n        return (\n            isObject(value) &&\n            isString(value.url) &&\n            isObject(value.process) &&\n            isObject(value.revert) &&\n            isObject(value.restore) &&\n            isObject(value.fetch)\n        );\n    };\n\n    var getType = function getType(value) {\n        if (isArray(value)) {\n            return 'array';\n        }\n\n        if (isNull(value)) {\n            return 'null';\n        }\n\n        if (isInt(value)) {\n            return 'int';\n        }\n\n        if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n            return 'bytes';\n        }\n\n        if (isAPI(value)) {\n            return 'api';\n        }\n\n        return typeof value;\n    };\n\n    var replaceSingleQuotes = function replaceSingleQuotes(str) {\n        return str\n            .replace(/{\\s*'/g, '{\"')\n            .replace(/'\\s*}/g, '\"}')\n            .replace(/'\\s*:/g, '\":')\n            .replace(/:\\s*'/g, ':\"')\n            .replace(/,\\s*'/g, ',\"')\n            .replace(/'\\s*,/g, '\",');\n    };\n\n    var conversionTable = {\n        array: toArray,\n        boolean: toBoolean,\n        int: function int(value) {\n            return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n        },\n        number: toFloat,\n        float: toFloat,\n        bytes: toBytes,\n        string: function string(value) {\n            return isFunction(value) ? value : toString(value);\n        },\n        function: function _function(value) {\n            return toFunctionReference(value);\n        },\n        serverapi: toServerAPI,\n        object: function object(value) {\n            try {\n                return JSON.parse(replaceSingleQuotes(value));\n            } catch (e) {\n                return null;\n            }\n        },\n    };\n\n    var convertTo = function convertTo(value, type) {\n        return conversionTable[type](value);\n    };\n\n    var getValueByType = function getValueByType(newValue, defaultValue, valueType) {\n        // can always assign default value\n        if (newValue === defaultValue) {\n            return newValue;\n        }\n\n        // get the type of the new value\n        var newValueType = getType(newValue);\n\n        // is valid type?\n        if (newValueType !== valueType) {\n            // is string input, let's attempt to convert\n            var convertedValue = convertTo(newValue, valueType);\n\n            // what is the type now\n            newValueType = getType(convertedValue);\n\n            // no valid conversions found\n            if (convertedValue === null) {\n                throw 'Trying to assign value with incorrect type to \"' +\n                    option +\n                    '\", allowed type: \"' +\n                    valueType +\n                    '\"';\n            } else {\n                newValue = convertedValue;\n            }\n        }\n\n        // assign new value\n        return newValue;\n    };\n\n    var createOption = function createOption(defaultValue, valueType) {\n        var currentValue = defaultValue;\n        return {\n            enumerable: true,\n            get: function get() {\n                return currentValue;\n            },\n            set: function set(newValue) {\n                currentValue = getValueByType(newValue, defaultValue, valueType);\n            },\n        };\n    };\n\n    var createOptions = function createOptions(options) {\n        var obj = {};\n        forin(options, function(prop) {\n            var optionDefinition = options[prop];\n            obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n        });\n        return createObject(obj);\n    };\n\n    var createInitialState = function createInitialState(options) {\n        return {\n            // model\n            items: [],\n\n            // timeout used for calling update items\n            listUpdateTimeout: null,\n\n            // timeout used for stacking metadata updates\n            itemUpdateTimeout: null,\n\n            // queue of items waiting to be processed\n            processingQueue: [],\n\n            // options\n            options: createOptions(options),\n        };\n    };\n\n    var fromCamels = function fromCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string\n            .split(/(?=[A-Z])/)\n            .map(function(part) {\n                return part.toLowerCase();\n            })\n            .join(separator);\n    };\n\n    var createOptionAPI = function createOptionAPI(store, options) {\n        var obj = {};\n        forin(options, function(key) {\n            obj[key] = {\n                get: function get() {\n                    return store.getState().options[key];\n                },\n                set: function set(value) {\n                    store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n                        value: value,\n                    });\n                },\n            };\n        });\n        return obj;\n    };\n\n    var createOptionActions = function createOptionActions(options) {\n        return function(dispatch, query, state) {\n            var obj = {};\n            forin(options, function(key) {\n                var name = fromCamels(key, '_').toUpperCase();\n\n                obj['SET_' + name] = function(action) {\n                    try {\n                        state.options[key] = action.value;\n                    } catch (e) {} // nope, failed\n\n                    // we successfully set the value of this option\n                    dispatch('DID_SET_' + name, { value: state.options[key] });\n                };\n            });\n            return obj;\n        };\n    };\n\n    var createOptionQueries = function createOptionQueries(options) {\n        return function(state) {\n            var obj = {};\n            forin(options, function(key) {\n                obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n                    return state.options[key];\n                };\n            });\n            return obj;\n        };\n    };\n\n    var InteractionMethod = {\n        API: 1,\n        DROP: 2,\n        BROWSE: 3,\n        PASTE: 4,\n        NONE: 5,\n    };\n\n    var getUniqueId = function getUniqueId() {\n        return Math.random()\n            .toString(36)\n            .substring(2, 11);\n    };\n\n    function _typeof(obj) {\n        if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n            _typeof = function(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function(obj) {\n                return obj &&\n                    typeof Symbol === 'function' &&\n                    obj.constructor === Symbol &&\n                    obj !== Symbol.prototype\n                    ? 'symbol'\n                    : typeof obj;\n            };\n        }\n\n        return _typeof(obj);\n    }\n\n    var REACT_ELEMENT_TYPE;\n\n    function _jsx(type, props, key, children) {\n        if (!REACT_ELEMENT_TYPE) {\n            REACT_ELEMENT_TYPE =\n                (typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element')) ||\n                0xeac7;\n        }\n\n        var defaultProps = type && type.defaultProps;\n        var childrenLength = arguments.length - 3;\n\n        if (!props && childrenLength !== 0) {\n            props = {\n                children: void 0,\n            };\n        }\n\n        if (props && defaultProps) {\n            for (var propName in defaultProps) {\n                if (props[propName] === void 0) {\n                    props[propName] = defaultProps[propName];\n                }\n            }\n        } else if (!props) {\n            props = defaultProps || {};\n        }\n\n        if (childrenLength === 1) {\n            props.children = children;\n        } else if (childrenLength > 1) {\n            var childArray = new Array(childrenLength);\n\n            for (var i = 0; i < childrenLength; i++) {\n                childArray[i] = arguments[i + 3];\n            }\n\n            props.children = childArray;\n        }\n\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: type,\n            key: key === undefined ? null : '' + key,\n            ref: null,\n            props: props,\n            _owner: null,\n        };\n    }\n\n    function _asyncIterator(iterable) {\n        var method;\n\n        if (typeof Symbol !== 'undefined') {\n            if (Symbol.asyncIterator) {\n                method = iterable[Symbol.asyncIterator];\n                if (method != null) return method.call(iterable);\n            }\n\n            if (Symbol.iterator) {\n                method = iterable[Symbol.iterator];\n                if (method != null) return method.call(iterable);\n            }\n        }\n\n        throw new TypeError('Object is not async iterable');\n    }\n\n    function _AwaitValue(value) {\n        this.wrapped = value;\n    }\n\n    function _AsyncGenerator(gen) {\n        var front, back;\n\n        function send(key, arg) {\n            return new Promise(function(resolve, reject) {\n                var request = {\n                    key: key,\n                    arg: arg,\n                    resolve: resolve,\n                    reject: reject,\n                    next: null,\n                };\n\n                if (back) {\n                    back = back.next = request;\n                } else {\n                    front = back = request;\n                    resume(key, arg);\n                }\n            });\n        }\n\n        function resume(key, arg) {\n            try {\n                var result = gen[key](arg);\n                var value = result.value;\n                var wrappedAwait = value instanceof _AwaitValue;\n                Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n                    function(arg) {\n                        if (wrappedAwait) {\n                            resume('next', arg);\n                            return;\n                        }\n\n                        settle(result.done ? 'return' : 'normal', arg);\n                    },\n                    function(err) {\n                        resume('throw', err);\n                    }\n                );\n            } catch (err) {\n                settle('throw', err);\n            }\n        }\n\n        function settle(type, value) {\n            switch (type) {\n                case 'return':\n                    front.resolve({\n                        value: value,\n                        done: true,\n                    });\n                    break;\n\n                case 'throw':\n                    front.reject(value);\n                    break;\n\n                default:\n                    front.resolve({\n                        value: value,\n                        done: false,\n                    });\n                    break;\n            }\n\n            front = front.next;\n\n            if (front) {\n                resume(front.key, front.arg);\n            } else {\n                back = null;\n            }\n        }\n\n        this._invoke = send;\n\n        if (typeof gen.return !== 'function') {\n            this.return = undefined;\n        }\n    }\n\n    if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n\n    _AsyncGenerator.prototype.next = function(arg) {\n        return this._invoke('next', arg);\n    };\n\n    _AsyncGenerator.prototype.throw = function(arg) {\n        return this._invoke('throw', arg);\n    };\n\n    _AsyncGenerator.prototype.return = function(arg) {\n        return this._invoke('return', arg);\n    };\n\n    function _wrapAsyncGenerator(fn) {\n        return function() {\n            return new _AsyncGenerator(fn.apply(this, arguments));\n        };\n    }\n\n    function _awaitAsyncGenerator(value) {\n        return new _AwaitValue(value);\n    }\n\n    function _asyncGeneratorDelegate(inner, awaitWrap) {\n        var iter = {},\n            waiting = false;\n\n        function pump(key, value) {\n            waiting = true;\n            value = new Promise(function(resolve) {\n                resolve(inner[key](value));\n            });\n            return {\n                done: false,\n                value: awaitWrap(value),\n            };\n        }\n\n        if (typeof Symbol === 'function' && Symbol.iterator) {\n            iter[Symbol.iterator] = function() {\n                return this;\n            };\n        }\n\n        iter.next = function(value) {\n            if (waiting) {\n                waiting = false;\n                return value;\n            }\n\n            return pump('next', value);\n        };\n\n        if (typeof inner.throw === 'function') {\n            iter.throw = function(value) {\n                if (waiting) {\n                    waiting = false;\n                    throw value;\n                }\n\n                return pump('throw', value);\n            };\n        }\n\n        if (typeof inner.return === 'function') {\n            iter.return = function(value) {\n                return pump('return', value);\n            };\n        }\n\n        return iter;\n    }\n\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self = this,\n                args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self, args);\n\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n                }\n\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n                }\n\n                _next(undefined);\n            });\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError('Cannot call a class as a function');\n        }\n    }\n\n    function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if ('value' in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n    }\n\n    function _defineEnumerableProperties(obj, descs) {\n        for (var key in descs) {\n            var desc = descs[key];\n            desc.configurable = desc.enumerable = true;\n            if ('value' in desc) desc.writable = true;\n            Object.defineProperty(obj, key, desc);\n        }\n\n        if (Object.getOwnPropertySymbols) {\n            var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n            for (var i = 0; i < objectSymbols.length; i++) {\n                var sym = objectSymbols[i];\n                var desc = descs[sym];\n                desc.configurable = desc.enumerable = true;\n                if ('value' in desc) desc.writable = true;\n                Object.defineProperty(obj, sym, desc);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defaults(obj, defaults) {\n        var keys = Object.getOwnPropertyNames(defaults);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n            if (value && value.configurable && obj[key] === undefined) {\n                Object.defineProperty(obj, key, value);\n            }\n        }\n\n        return obj;\n    }\n\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true,\n            });\n        } else {\n            obj[key] = value;\n        }\n\n        return obj;\n    }\n\n    function _extends() {\n        _extends =\n            Object.assign ||\n            function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n\n                return target;\n            };\n\n        return _extends.apply(this, arguments);\n    }\n\n    function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n            var ownKeys = Object.keys(source);\n\n            if (typeof Object.getOwnPropertySymbols === 'function') {\n                ownKeys = ownKeys.concat(\n                    Object.getOwnPropertySymbols(source).filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                    })\n                );\n            }\n\n            ownKeys.forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        }\n\n        return target;\n    }\n\n    function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n            var symbols = Object.getOwnPropertySymbols(object);\n            if (enumerableOnly)\n                symbols = symbols.filter(function(sym) {\n                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                });\n            keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n    }\n\n    function _objectSpread2(target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i] != null ? arguments[i] : {};\n\n            if (i % 2) {\n                ownKeys(source, true).forEach(function(key) {\n                    _defineProperty(target, key, source[key]);\n                });\n            } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n            } else {\n                ownKeys(source).forEach(function(key) {\n                    Object.defineProperty(\n                        target,\n                        key,\n                        Object.getOwnPropertyDescriptor(source, key)\n                    );\n                });\n            }\n        }\n\n        return target;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== 'function' && superClass !== null) {\n            throw new TypeError('Super expression must either be null or a function');\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true,\n            },\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n    }\n\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf\n            ? Object.getPrototypeOf\n            : function _getPrototypeOf(o) {\n                  return o.__proto__ || Object.getPrototypeOf(o);\n              };\n        return _getPrototypeOf(o);\n    }\n\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf =\n            Object.setPrototypeOf ||\n            function _setPrototypeOf(o, p) {\n                o.__proto__ = p;\n                return o;\n            };\n\n        return _setPrototypeOf(o, p);\n    }\n\n    function isNativeReflectConstruct() {\n        if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === 'function') return true;\n\n        try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n            _construct = Reflect.construct;\n        } else {\n            _construct = function _construct(Parent, args, Class) {\n                var a = [null];\n                a.push.apply(a, args);\n                var Constructor = Function.bind.apply(Parent, a);\n                var instance = new Constructor();\n                if (Class) _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            };\n        }\n\n        return _construct.apply(null, arguments);\n    }\n\n    function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf('[native code]') !== -1;\n    }\n\n    function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n            if (Class === null || !_isNativeFunction(Class)) return Class;\n\n            if (typeof Class !== 'function') {\n                throw new TypeError('Super expression must either be null or a function');\n            }\n\n            if (typeof _cache !== 'undefined') {\n                if (_cache.has(Class)) return _cache.get(Class);\n\n                _cache.set(Class, Wrapper);\n            }\n\n            function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n            }\n\n            Wrapper.prototype = Object.create(Class.prototype, {\n                constructor: {\n                    value: Wrapper,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                },\n            });\n            return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n    }\n\n    function _instanceof(left, right) {\n        if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {\n            return !!right[Symbol.hasInstance](left);\n        } else {\n            return left instanceof right;\n        }\n    }\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule\n            ? obj\n            : {\n                  default: obj,\n              };\n    }\n\n    function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n            return obj;\n        } else {\n            var newObj = {};\n\n            if (obj != null) {\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc =\n                            Object.defineProperty && Object.getOwnPropertyDescriptor\n                                ? Object.getOwnPropertyDescriptor(obj, key)\n                                : {};\n\n                        if (desc.get || desc.set) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n            }\n\n            newObj.default = obj;\n            return newObj;\n        }\n    }\n\n    function _newArrowCheck(innerThis, boundThis) {\n        if (innerThis !== boundThis) {\n            throw new TypeError('Cannot instantiate an arrow function');\n        }\n    }\n\n    function _objectDestructuringEmpty(obj) {\n        if (obj == null) throw new TypeError('Cannot destructure undefined');\n    }\n\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n\n        return target;\n    }\n\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n            for (i = 0; i < sourceSymbolKeys.length; i++) {\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n\n        return target;\n    }\n\n    function _assertThisInitialized(self) {\n        if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n        if (call && (typeof call === 'object' || typeof call === 'function')) {\n            return call;\n        }\n\n        return _assertThisInitialized(self);\n    }\n\n    function _superPropBase(object, property) {\n        while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n\n        return object;\n    }\n\n    function _get(target, property, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.get) {\n            _get = Reflect.get;\n        } else {\n            _get = function _get(target, property, receiver) {\n                var base = _superPropBase(target, property);\n\n                if (!base) return;\n                var desc = Object.getOwnPropertyDescriptor(base, property);\n\n                if (desc.get) {\n                    return desc.get.call(receiver);\n                }\n\n                return desc.value;\n            };\n        }\n\n        return _get(target, property, receiver || target);\n    }\n\n    function set(target, property, value, receiver) {\n        if (typeof Reflect !== 'undefined' && Reflect.set) {\n            set = Reflect.set;\n        } else {\n            set = function set(target, property, value, receiver) {\n                var base = _superPropBase(target, property);\n\n                var desc;\n\n                if (base) {\n                    desc = Object.getOwnPropertyDescriptor(base, property);\n\n                    if (desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    } else if (!desc.writable) {\n                        return false;\n                    }\n                }\n\n                desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n                if (desc) {\n                    if (!desc.writable) {\n                        return false;\n                    }\n\n                    desc.value = value;\n                    Object.defineProperty(receiver, property, desc);\n                } else {\n                    _defineProperty(receiver, property, value);\n                }\n\n                return true;\n            };\n        }\n\n        return set(target, property, value, receiver);\n    }\n\n    function _set(target, property, value, receiver, isStrict) {\n        var s = set(target, property, value, receiver || target);\n\n        if (!s && isStrict) {\n            throw new Error('failed to set property');\n        }\n\n        return value;\n    }\n\n    function _taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        return Object.freeze(\n            Object.defineProperties(strings, {\n                raw: {\n                    value: Object.freeze(raw),\n                },\n            })\n        );\n    }\n\n    function _taggedTemplateLiteralLoose(strings, raw) {\n        if (!raw) {\n            raw = strings.slice(0);\n        }\n\n        strings.raw = raw;\n        return strings;\n    }\n\n    function _temporalRef(val, name) {\n        if (val === _temporalUndefined) {\n            throw new ReferenceError(name + ' is not defined - temporal dead zone');\n        } else {\n            return val;\n        }\n    }\n\n    function _readOnlyError(name) {\n        throw new Error('\"' + name + '\" is read-only');\n    }\n\n    function _classNameTDZError(name) {\n        throw new Error('Class \"' + name + '\" cannot be referenced in computed property keys.');\n    }\n\n    var _temporalUndefined = {};\n\n    function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n    }\n\n    function _slicedToArrayLoose(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _nonIterableRest();\n    }\n\n    function _toArray(arr) {\n        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n    }\n\n    function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n            return arr2;\n        }\n    }\n\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n\n    function _iterableToArray(iter) {\n        if (\n            Symbol.iterator in Object(iter) ||\n            Object.prototype.toString.call(iter) === '[object Arguments]'\n        )\n            return Array.from(iter);\n    }\n\n    function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally {\n            try {\n                if (!_n && _i['return'] != null) _i['return']();\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n\n        return _arr;\n    }\n\n    function _iterableToArrayLimitLoose(arr, i) {\n        var _arr = [];\n\n        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {\n            _arr.push(_step.value);\n\n            if (i && _arr.length === i) break;\n        }\n\n        return _arr;\n    }\n\n    function _nonIterableSpread() {\n        throw new TypeError('Invalid attempt to spread non-iterable instance');\n    }\n\n    function _nonIterableRest() {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n\n    function _skipFirstGeneratorNext(fn) {\n        return function() {\n            var it = fn.apply(this, arguments);\n            it.next();\n            return it;\n        };\n    }\n\n    function _toPrimitive(input, hint) {\n        if (typeof input !== 'object' || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || 'default');\n            if (typeof res !== 'object') return res;\n            throw new TypeError('@@toPrimitive must return a primitive value.');\n        }\n\n        return (hint === 'string' ? String : Number)(input);\n    }\n\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, 'string');\n\n        return typeof key === 'symbol' ? key : String(key);\n    }\n\n    function _initializerWarningHelper(descriptor, context) {\n        throw new Error(\n            'Decorating class property failed. Please ensure that ' +\n                'proposal-class-properties is enabled and set to use loose mode. ' +\n                'To use proposal-class-properties in spec mode with decorators, wait for ' +\n                'the next major version of decorators in stage 2.'\n        );\n    }\n\n    function _initializerDefineProperty(target, property, descriptor, context) {\n        if (!descriptor) return;\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n\n    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key) {\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n\n        if ('value' in desc || desc.initializer) {\n            desc.writable = true;\n        }\n\n        desc = decorators\n            .slice()\n            .reverse()\n            .reduce(function(desc, decorator) {\n                return decorator(target, property, desc) || desc;\n            }, desc);\n\n        if (context && desc.initializer !== void 0) {\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0) {\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n\n    var id = 0;\n\n    function _classPrivateFieldLooseKey(name) {\n        return '__private_' + id++ + '_' + name;\n    }\n\n    function _classPrivateFieldLooseBase(receiver, privateKey) {\n        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n            throw new TypeError('attempted to use private field on non-instance');\n        }\n\n        return receiver;\n    }\n\n    function _classPrivateFieldGet(receiver, privateMap) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        if (descriptor.get) {\n            return descriptor.get.call(receiver);\n        }\n\n        return descriptor.value;\n    }\n\n    function _classPrivateFieldSet(receiver, privateMap, value) {\n        var descriptor = privateMap.get(receiver);\n\n        if (!descriptor) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        if (descriptor.set) {\n            descriptor.set.call(receiver, value);\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            descriptor.value = value;\n        }\n\n        return value;\n    }\n\n    function _classPrivateFieldDestructureSet(receiver, privateMap) {\n        if (!privateMap.has(receiver)) {\n            throw new TypeError('attempted to set private field on non-instance');\n        }\n\n        var descriptor = privateMap.get(receiver);\n\n        if (descriptor.set) {\n            if (!('__destrObj' in descriptor)) {\n                descriptor.__destrObj = {\n                    set value(v) {\n                        descriptor.set.call(receiver, v);\n                    },\n                };\n            }\n\n            return descriptor.__destrObj;\n        } else {\n            if (!descriptor.writable) {\n                throw new TypeError('attempted to set read only private field');\n            }\n\n            return descriptor;\n        }\n    }\n\n    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return descriptor.value;\n    }\n\n    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        if (!descriptor.writable) {\n            throw new TypeError('attempted to set read only private field');\n        }\n\n        descriptor.value = value;\n        return value;\n    }\n\n    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n        if (receiver !== classConstructor) {\n            throw new TypeError('Private static access of wrong provenance');\n        }\n\n        return method;\n    }\n\n    function _classStaticPrivateMethodSet() {\n        throw new TypeError('attempted to set read only static private field');\n    }\n\n    function _decorate(decorators, factory, superClass, mixins) {\n        var api = _getDecoratorsApi();\n\n        if (mixins) {\n            for (var i = 0; i < mixins.length; i++) {\n                api = mixins[i](api);\n            }\n        }\n\n        var r = factory(function initialize(O) {\n            api.initializeInstanceElements(O, decorated.elements);\n        }, superClass);\n        var decorated = api.decorateClass(\n            _coalesceClassElements(r.d.map(_createElementDescriptor)),\n            decorators\n        );\n        api.initializeClassElements(r.F, decorated.elements);\n        return api.runClassFinishers(r.F, decorated.finishers);\n    }\n\n    function _getDecoratorsApi() {\n        _getDecoratorsApi = function() {\n            return api;\n        };\n\n        var api = {\n            elementsDefinitionOrder: [['method'], ['field']],\n            initializeInstanceElements: function(O, elements) {\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        if (element.kind === kind && element.placement === 'own') {\n                            this.defineClassElement(O, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            initializeClassElements: function(F, elements) {\n                var proto = F.prototype;\n                ['method', 'field'].forEach(function(kind) {\n                    elements.forEach(function(element) {\n                        var placement = element.placement;\n\n                        if (\n                            element.kind === kind &&\n                            (placement === 'static' || placement === 'prototype')\n                        ) {\n                            var receiver = placement === 'static' ? F : proto;\n                            this.defineClassElement(receiver, element);\n                        }\n                    }, this);\n                }, this);\n            },\n            defineClassElement: function(receiver, element) {\n                var descriptor = element.descriptor;\n\n                if (element.kind === 'field') {\n                    var initializer = element.initializer;\n                    descriptor = {\n                        enumerable: descriptor.enumerable,\n                        writable: descriptor.writable,\n                        configurable: descriptor.configurable,\n                        value: initializer === void 0 ? void 0 : initializer.call(receiver),\n                    };\n                }\n\n                Object.defineProperty(receiver, element.key, descriptor);\n            },\n            decorateClass: function(elements, decorators) {\n                var newElements = [];\n                var finishers = [];\n                var placements = {\n                    static: [],\n                    prototype: [],\n                    own: [],\n                };\n                elements.forEach(function(element) {\n                    this.addElementPlacement(element, placements);\n                }, this);\n                elements.forEach(function(element) {\n                    if (!_hasDecorators(element)) return newElements.push(element);\n                    var elementFinishersExtras = this.decorateElement(element, placements);\n                    newElements.push(elementFinishersExtras.element);\n                    newElements.push.apply(newElements, elementFinishersExtras.extras);\n                    finishers.push.apply(finishers, elementFinishersExtras.finishers);\n                }, this);\n\n                if (!decorators) {\n                    return {\n                        elements: newElements,\n                        finishers: finishers,\n                    };\n                }\n\n                var result = this.decorateConstructor(newElements, decorators);\n                finishers.push.apply(finishers, result.finishers);\n                result.finishers = finishers;\n                return result;\n            },\n            addElementPlacement: function(element, placements, silent) {\n                var keys = placements[element.placement];\n\n                if (!silent && keys.indexOf(element.key) !== -1) {\n                    throw new TypeError('Duplicated element (' + element.key + ')');\n                }\n\n                keys.push(element.key);\n            },\n            decorateElement: function(element, placements) {\n                var extras = [];\n                var finishers = [];\n\n                for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n                    var keys = placements[element.placement];\n                    keys.splice(keys.indexOf(element.key), 1);\n                    var elementObject = this.fromElementDescriptor(element);\n                    var elementFinisherExtras = this.toElementFinisherExtras(\n                        (0, decorators[i])(elementObject) || elementObject\n                    );\n                    element = elementFinisherExtras.element;\n                    this.addElementPlacement(element, placements);\n\n                    if (elementFinisherExtras.finisher) {\n                        finishers.push(elementFinisherExtras.finisher);\n                    }\n\n                    var newExtras = elementFinisherExtras.extras;\n\n                    if (newExtras) {\n                        for (var j = 0; j < newExtras.length; j++) {\n                            this.addElementPlacement(newExtras[j], placements);\n                        }\n\n                        extras.push.apply(extras, newExtras);\n                    }\n                }\n\n                return {\n                    element: element,\n                    finishers: finishers,\n                    extras: extras,\n                };\n            },\n            decorateConstructor: function(elements, decorators) {\n                var finishers = [];\n\n                for (var i = decorators.length - 1; i >= 0; i--) {\n                    var obj = this.fromClassDescriptor(elements);\n                    var elementsAndFinisher = this.toClassDescriptor(\n                        (0, decorators[i])(obj) || obj\n                    );\n\n                    if (elementsAndFinisher.finisher !== undefined) {\n                        finishers.push(elementsAndFinisher.finisher);\n                    }\n\n                    if (elementsAndFinisher.elements !== undefined) {\n                        elements = elementsAndFinisher.elements;\n\n                        for (var j = 0; j < elements.length - 1; j++) {\n                            for (var k = j + 1; k < elements.length; k++) {\n                                if (\n                                    elements[j].key === elements[k].key &&\n                                    elements[j].placement === elements[k].placement\n                                ) {\n                                    throw new TypeError(\n                                        'Duplicated element (' + elements[j].key + ')'\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return {\n                    elements: elements,\n                    finishers: finishers,\n                };\n            },\n            fromElementDescriptor: function(element) {\n                var obj = {\n                    kind: element.kind,\n                    key: element.key,\n                    placement: element.placement,\n                    descriptor: element.descriptor,\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                if (element.kind === 'field') obj.initializer = element.initializer;\n                return obj;\n            },\n            toElementDescriptors: function(elementObjects) {\n                if (elementObjects === undefined) return;\n                return _toArray(elementObjects).map(function(elementObject) {\n                    var element = this.toElementDescriptor(elementObject);\n                    this.disallowProperty(elementObject, 'finisher', 'An element descriptor');\n                    this.disallowProperty(elementObject, 'extras', 'An element descriptor');\n                    return element;\n                }, this);\n            },\n            toElementDescriptor: function(elementObject) {\n                var kind = String(elementObject.kind);\n\n                if (kind !== 'method' && kind !== 'field') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .kind property must be either \"method\" or' +\n                            ' \"field\", but a decorator created an element descriptor with' +\n                            ' .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                var key = _toPropertyKey(elementObject.key);\n\n                var placement = String(elementObject.placement);\n\n                if (placement !== 'static' && placement !== 'prototype' && placement !== 'own') {\n                    throw new TypeError(\n                        'An element descriptor\\'s .placement property must be one of \"static\",' +\n                            ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n                            ' with .placement \"' +\n                            placement +\n                            '\"'\n                    );\n                }\n\n                var descriptor = elementObject.descriptor;\n                this.disallowProperty(elementObject, 'elements', 'An element descriptor');\n                var element = {\n                    kind: kind,\n                    key: key,\n                    placement: placement,\n                    descriptor: Object.assign({}, descriptor),\n                };\n\n                if (kind !== 'field') {\n                    this.disallowProperty(elementObject, 'initializer', 'A method descriptor');\n                } else {\n                    this.disallowProperty(\n                        descriptor,\n                        'get',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'set',\n                        'The property descriptor of a field descriptor'\n                    );\n                    this.disallowProperty(\n                        descriptor,\n                        'value',\n                        'The property descriptor of a field descriptor'\n                    );\n                    element.initializer = elementObject.initializer;\n                }\n\n                return element;\n            },\n            toElementFinisherExtras: function(elementObject) {\n                var element = this.toElementDescriptor(elementObject);\n\n                var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n                var extras = this.toElementDescriptors(elementObject.extras);\n                return {\n                    element: element,\n                    finisher: finisher,\n                    extras: extras,\n                };\n            },\n            fromClassDescriptor: function(elements) {\n                var obj = {\n                    kind: 'class',\n                    elements: elements.map(this.fromElementDescriptor, this),\n                };\n                var desc = {\n                    value: 'Descriptor',\n                    configurable: true,\n                };\n                Object.defineProperty(obj, Symbol.toStringTag, desc);\n                return obj;\n            },\n            toClassDescriptor: function(obj) {\n                var kind = String(obj.kind);\n\n                if (kind !== 'class') {\n                    throw new TypeError(\n                        'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n                            ' created a class descriptor with .kind \"' +\n                            kind +\n                            '\"'\n                    );\n                }\n\n                this.disallowProperty(obj, 'key', 'A class descriptor');\n                this.disallowProperty(obj, 'placement', 'A class descriptor');\n                this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n                this.disallowProperty(obj, 'initializer', 'A class descriptor');\n                this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n                var finisher = _optionalCallableProperty(obj, 'finisher');\n\n                var elements = this.toElementDescriptors(obj.elements);\n                return {\n                    elements: elements,\n                    finisher: finisher,\n                };\n            },\n            runClassFinishers: function(constructor, finishers) {\n                for (var i = 0; i < finishers.length; i++) {\n                    var newConstructor = (0, finishers[i])(constructor);\n\n                    if (newConstructor !== undefined) {\n                        if (typeof newConstructor !== 'function') {\n                            throw new TypeError('Finishers must return a constructor.');\n                        }\n\n                        constructor = newConstructor;\n                    }\n                }\n\n                return constructor;\n            },\n            disallowProperty: function(obj, name, objectType) {\n                if (obj[name] !== undefined) {\n                    throw new TypeError(objectType + \" can't have a .\" + name + ' property.');\n                }\n            },\n        };\n        return api;\n    }\n\n    function _createElementDescriptor(def) {\n        var key = _toPropertyKey(def.key);\n\n        var descriptor;\n\n        if (def.kind === 'method') {\n            descriptor = {\n                value: def.value,\n                writable: true,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'get') {\n            descriptor = {\n                get: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'set') {\n            descriptor = {\n                set: def.value,\n                configurable: true,\n                enumerable: false,\n            };\n        } else if (def.kind === 'field') {\n            descriptor = {\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            };\n        }\n\n        var element = {\n            kind: def.kind === 'field' ? 'field' : 'method',\n            key: key,\n            placement: def.static ? 'static' : def.kind === 'field' ? 'own' : 'prototype',\n            descriptor: descriptor,\n        };\n        if (def.decorators) element.decorators = def.decorators;\n        if (def.kind === 'field') element.initializer = def.value;\n        return element;\n    }\n\n    function _coalesceGetterSetter(element, other) {\n        if (element.descriptor.get !== undefined) {\n            other.descriptor.get = element.descriptor.get;\n        } else {\n            other.descriptor.set = element.descriptor.set;\n        }\n    }\n\n    function _coalesceClassElements(elements) {\n        var newElements = [];\n\n        var isSameElement = function(other) {\n            return (\n                other.kind === 'method' &&\n                other.key === element.key &&\n                other.placement === element.placement\n            );\n        };\n\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var other;\n\n            if (element.kind === 'method' && (other = newElements.find(isSameElement))) {\n                if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n                    if (_hasDecorators(element) || _hasDecorators(other)) {\n                        throw new ReferenceError(\n                            'Duplicated methods (' + element.key + \") can't be decorated.\"\n                        );\n                    }\n\n                    other.descriptor = element.descriptor;\n                } else {\n                    if (_hasDecorators(element)) {\n                        if (_hasDecorators(other)) {\n                            throw new ReferenceError(\n                                \"Decorators can't be placed on different accessors with for \" +\n                                    'the same property (' +\n                                    element.key +\n                                    ').'\n                            );\n                        }\n\n                        other.decorators = element.decorators;\n                    }\n\n                    _coalesceGetterSetter(element, other);\n                }\n            } else {\n                newElements.push(element);\n            }\n        }\n\n        return newElements;\n    }\n\n    function _hasDecorators(element) {\n        return element.decorators && element.decorators.length;\n    }\n\n    function _isDataDescriptor(desc) {\n        return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n    }\n\n    function _optionalCallableProperty(obj, name) {\n        var value = obj[name];\n\n        if (value !== undefined && typeof value !== 'function') {\n            throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n        }\n\n        return value;\n    }\n\n    function _classPrivateMethodGet(receiver, privateSet, fn) {\n        if (!privateSet.has(receiver)) {\n            throw new TypeError('attempted to get private field on non-instance');\n        }\n\n        return fn;\n    }\n\n    function _classPrivateMethodSet() {\n        throw new TypeError('attempted to reassign private method');\n    }\n\n    function _wrapRegExp(re, groups) {\n        _wrapRegExp = function(re, groups) {\n            return new BabelRegExp(re, groups);\n        };\n\n        var _RegExp = _wrapNativeSuper(RegExp);\n\n        var _super = RegExp.prototype;\n\n        var _groups = new WeakMap();\n\n        function BabelRegExp(re, groups) {\n            var _this = _RegExp.call(this, re);\n\n            _groups.set(_this, groups);\n\n            return _this;\n        }\n\n        _inherits(BabelRegExp, _RegExp);\n\n        BabelRegExp.prototype.exec = function(str) {\n            var result = _super.exec.call(this, str);\n\n            if (result) result.groups = buildGroups(result, this);\n            return result;\n        };\n\n        BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n            if (typeof substitution === 'string') {\n                var groups = _groups.get(this);\n\n                return _super[Symbol.replace].call(\n                    this,\n                    str,\n                    substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n                        return '$' + groups[name];\n                    })\n                );\n            } else if (typeof substitution === 'function') {\n                var _this = this;\n\n                return _super[Symbol.replace].call(this, str, function() {\n                    var args = [];\n                    args.push.apply(args, arguments);\n\n                    if (typeof args[args.length - 1] !== 'object') {\n                        args.push(buildGroups(args, _this));\n                    }\n\n                    return substitution.apply(this, args);\n                });\n            } else {\n                return _super[Symbol.replace].call(this, str, substitution);\n            }\n        };\n\n        function buildGroups(result, re) {\n            var g = _groups.get(re);\n\n            return Object.keys(g).reduce(function(groups, name) {\n                groups[name] = result[g[name]];\n                return groups;\n            }, Object.create(null));\n        }\n\n        return _wrapRegExp.apply(this, arguments);\n    }\n\n    var arrayRemove = function arrayRemove(arr, index) {\n        return arr.splice(index, 1);\n    };\n\n    var run = function run(cb, sync) {\n        if (sync) {\n            cb();\n        } else if (document.hidden) {\n            Promise.resolve(1).then(cb);\n        } else {\n            setTimeout(cb, 0);\n        }\n    };\n\n    var on = function on() {\n        var listeners = [];\n        var off = function off(event, cb) {\n            arrayRemove(\n                listeners,\n                listeners.findIndex(function(listener) {\n                    return listener.event === event && (listener.cb === cb || !cb);\n                })\n            );\n        };\n        var _fire = function fire(event, args, sync) {\n            listeners\n                .filter(function(listener) {\n                    return listener.event === event;\n                })\n                .map(function(listener) {\n                    return listener.cb;\n                })\n                .forEach(function(cb) {\n                    return run(function() {\n                        return cb.apply(void 0, _toConsumableArray(args));\n                    }, sync);\n                });\n        };\n        return {\n            fireSync: function fireSync(event) {\n                for (\n                    var _len = arguments.length,\n                        args = new Array(_len > 1 ? _len - 1 : 0),\n                        _key = 1;\n                    _key < _len;\n                    _key++\n                ) {\n                    args[_key - 1] = arguments[_key];\n                }\n                _fire(event, args, true);\n            },\n            fire: function fire(event) {\n                for (\n                    var _len2 = arguments.length,\n                        args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n                        _key2 = 1;\n                    _key2 < _len2;\n                    _key2++\n                ) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _fire(event, args, false);\n            },\n            on: function on(event, cb) {\n                listeners.push({ event: event, cb: cb });\n            },\n            onOnce: function onOnce(event, _cb) {\n                listeners.push({\n                    event: event,\n                    cb: function cb() {\n                        off(event, _cb);\n                        _cb.apply(void 0, arguments);\n                    },\n                });\n            },\n            off: off,\n        };\n    };\n\n    var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n        src,\n        target,\n        excluded\n    ) {\n        Object.getOwnPropertyNames(src)\n            .filter(function(property) {\n                return !excluded.includes(property);\n            })\n            .forEach(function(key) {\n                return Object.defineProperty(\n                    target,\n                    key,\n                    Object.getOwnPropertyDescriptor(src, key)\n                );\n            });\n    };\n\n    var PRIVATE = [\n        'fire',\n        'process',\n        'revert',\n        'load',\n        'on',\n        'off',\n        'onOnce',\n        'retryLoad',\n        'extend',\n        'archive',\n        'archived',\n        'release',\n        'released',\n        'requestProcessing',\n        'freeze',\n    ];\n\n    var createItemAPI = function createItemAPI(item) {\n        var api = {};\n        copyObjectPropertiesToObject(item, api, PRIVATE);\n        return api;\n    };\n\n    var removeReleasedItems = function removeReleasedItems(items) {\n        items.forEach(function(item, index) {\n            if (item.released) {\n                arrayRemove(items, index);\n            }\n        });\n    };\n\n    var ItemStatus = {\n        INIT: 1,\n        IDLE: 2,\n        PROCESSING_QUEUED: 9,\n        PROCESSING: 3,\n        PROCESSING_COMPLETE: 5,\n        PROCESSING_ERROR: 6,\n        PROCESSING_REVERT_ERROR: 10,\n        LOADING: 7,\n        LOAD_ERROR: 8,\n    };\n\n    var FileOrigin = {\n        INPUT: 1,\n        LIMBO: 2,\n        LOCAL: 3,\n    };\n\n    var getNonNumeric = function getNonNumeric(str) {\n        return /[^0-9]+/.exec(str);\n    };\n\n    var getDecimalSeparator = function getDecimalSeparator() {\n        return getNonNumeric((1.1).toLocaleString())[0];\n    };\n\n    var getThousandsSeparator = function getThousandsSeparator() {\n        // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n        // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n        var decimalSeparator = getDecimalSeparator();\n        var thousandsStringWithSeparator = (1000.0).toLocaleString();\n        var thousandsStringWithoutSeparator = (1000.0).toString();\n        if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n            return getNonNumeric(thousandsStringWithSeparator)[0];\n        }\n        return decimalSeparator === '.' ? ',' : '.';\n    };\n\n    var Type = {\n        BOOLEAN: 'boolean',\n        INT: 'int',\n        NUMBER: 'number',\n        STRING: 'string',\n        ARRAY: 'array',\n        OBJECT: 'object',\n        FUNCTION: 'function',\n        ACTION: 'action',\n        SERVER_API: 'serverapi',\n        REGEX: 'regex',\n    };\n\n    // all registered filters\n    var filters = [];\n\n    // loops over matching filters and passes options to each filter, returning the mapped results\n    var applyFilterChain = function applyFilterChain(key, value, utils) {\n        return new Promise(function(resolve, reject) {\n            // find matching filters for this key\n            var matchingFilters = filters\n                .filter(function(f) {\n                    return f.key === key;\n                })\n                .map(function(f) {\n                    return f.cb;\n                });\n\n            // resolve now\n            if (matchingFilters.length === 0) {\n                resolve(value);\n                return;\n            }\n\n            // first filter to kick things of\n            var initialFilter = matchingFilters.shift();\n\n            // chain filters\n            matchingFilters\n                .reduce(\n                    // loop over promises passing value to next promise\n                    function(current, next) {\n                        return current.then(function(value) {\n                            return next(value, utils);\n                        });\n                    },\n\n                    // call initial filter, will return a promise\n                    initialFilter(value, utils)\n\n                    // all executed\n                )\n                .then(function(value) {\n                    return resolve(value);\n                })\n                .catch(function(error) {\n                    return reject(error);\n                });\n        });\n    };\n\n    var applyFilters = function applyFilters(key, value, utils) {\n        return filters\n            .filter(function(f) {\n                return f.key === key;\n            })\n            .map(function(f) {\n                return f.cb(value, utils);\n            });\n    };\n\n    // adds a new filter to the list\n    var addFilter = function addFilter(key, cb) {\n        return filters.push({ key: key, cb: cb });\n    };\n\n    var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n        return Object.assign(defaultOptions, additionalOptions);\n    };\n\n    var getOptions = function getOptions() {\n        return Object.assign({}, defaultOptions);\n    };\n\n    var setOptions = function setOptions(opts) {\n        forin(opts, function(key, value) {\n            // key does not exist, so this option cannot be set\n            if (!defaultOptions[key]) {\n                return;\n            }\n            defaultOptions[key][0] = getValueByType(\n                value,\n                defaultOptions[key][0],\n                defaultOptions[key][1]\n            );\n        });\n    };\n\n    // default options on app\n    var defaultOptions = {\n        // the id to add to the root element\n        id: [null, Type.STRING],\n\n        // input field name to use\n        name: ['filepond', Type.STRING],\n\n        // disable the field\n        disabled: [false, Type.BOOLEAN],\n\n        // classname to put on wrapper\n        className: [null, Type.STRING],\n\n        // is the field required\n        required: [false, Type.BOOLEAN],\n\n        // Allow media capture when value is set\n        captureMethod: [null, Type.STRING],\n        // - \"camera\", \"microphone\" or \"camcorder\",\n        // - Does not work with multiple on apple devices\n        // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n        // sync `acceptedFileTypes` property with `accept` attribute\n        allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n        // Feature toggles\n        allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n        allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n        allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n        allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n        allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n        allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n        allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n        allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n        allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n        allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n        // Try store file if `server` not set\n        storeAsFile: [false, Type.BOOLEAN],\n\n        // Revert mode\n        forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n        // Input requirements\n        maxFiles: [null, Type.INT], // Max number of files\n        checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n        // Where to put file\n        itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n        itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n        itemInsertInterval: [75, Type.INT],\n\n        // Drag 'n Drop related\n        dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n        dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n        dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n        ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n        // Upload related\n        instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n        maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n        allowMinimumUploadDuration: [true, Type.BOOLEAN], // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened\n\n        // Chunks\n        chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n        chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n        chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n        chunkRetryDelays: [[500, 1000, 3000], Type.ARRAY], // Amount of times to retry upload of a chunk when it fails\n\n        // The server api end points to use for uploading (see docs)\n        server: [null, Type.SERVER_API],\n\n        // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n        fileSizeBase: [1000, Type.INT],\n\n        // Labels and status messages\n        labelFileSizeBytes: ['bytes', Type.STRING],\n        labelFileSizeKilobytes: ['KB', Type.STRING],\n        labelFileSizeMegabytes: ['MB', Type.STRING],\n        labelFileSizeGigabytes: ['GB', Type.STRING],\n\n        labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n        labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n        labelIdle: [\n            'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n            Type.STRING,\n        ],\n\n        labelInvalidField: ['Field contains invalid files', Type.STRING],\n        labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n        labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n        labelFileCountSingular: ['file in list', Type.STRING],\n        labelFileCountPlural: ['files in list', Type.STRING],\n        labelFileLoading: ['Loading', Type.STRING],\n        labelFileAdded: ['Added', Type.STRING], // assistive only\n        labelFileLoadError: ['Error during load', Type.STRING],\n        labelFileRemoved: ['Removed', Type.STRING], // assistive only\n        labelFileRemoveError: ['Error during remove', Type.STRING],\n        labelFileProcessing: ['Uploading', Type.STRING],\n        labelFileProcessingComplete: ['Upload complete', Type.STRING],\n        labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n        labelFileProcessingError: ['Error during upload', Type.STRING],\n        labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n        labelTapToCancel: ['tap to cancel', Type.STRING],\n        labelTapToRetry: ['tap to retry', Type.STRING],\n        labelTapToUndo: ['tap to undo', Type.STRING],\n\n        labelButtonRemoveItem: ['Remove', Type.STRING],\n        labelButtonAbortItemLoad: ['Abort', Type.STRING],\n        labelButtonRetryItemLoad: ['Retry', Type.STRING],\n        labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n        labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n        labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n        labelButtonProcessItem: ['Upload', Type.STRING],\n\n        // make sure width and height plus viewpox are even numbers so icons are nicely centered\n        iconRemove: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconProcess: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconRetry: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconUndo: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        iconDone: [\n            '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n            Type.STRING,\n        ],\n\n        // event handlers\n        oninit: [null, Type.FUNCTION],\n        onwarning: [null, Type.FUNCTION],\n        onerror: [null, Type.FUNCTION],\n        onactivatefile: [null, Type.FUNCTION],\n        oninitfile: [null, Type.FUNCTION],\n        onaddfilestart: [null, Type.FUNCTION],\n        onaddfileprogress: [null, Type.FUNCTION],\n        onaddfile: [null, Type.FUNCTION],\n        onprocessfilestart: [null, Type.FUNCTION],\n        onprocessfileprogress: [null, Type.FUNCTION],\n        onprocessfileabort: [null, Type.FUNCTION],\n        onprocessfilerevert: [null, Type.FUNCTION],\n        onprocessfile: [null, Type.FUNCTION],\n        onprocessfiles: [null, Type.FUNCTION],\n        onremovefile: [null, Type.FUNCTION],\n        onpreparefile: [null, Type.FUNCTION],\n        onupdatefiles: [null, Type.FUNCTION],\n        onreorderfiles: [null, Type.FUNCTION],\n\n        // hooks\n        beforeDropFile: [null, Type.FUNCTION],\n        beforeAddFile: [null, Type.FUNCTION],\n        beforeRemoveFile: [null, Type.FUNCTION],\n        beforePrepareFile: [null, Type.FUNCTION],\n\n        // styles\n        stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n        stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n        styleItemPanelAspectRatio: [null, Type.STRING],\n        styleButtonRemoveItemPosition: ['left', Type.STRING],\n        styleButtonProcessItemPosition: ['right', Type.STRING],\n        styleLoadIndicatorPosition: ['right', Type.STRING],\n        styleProgressIndicatorPosition: ['right', Type.STRING],\n        styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n        // custom initial files array\n        files: [[], Type.ARRAY],\n\n        // show support by displaying credits\n        credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY],\n    };\n\n    var getItemByQuery = function getItemByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return items[0] || null;\n        }\n\n        // query is index\n        if (isInt(query)) {\n            return items[query] || null;\n        }\n\n        // if query is item, get the id\n        if (typeof query === 'object') {\n            query = query.id;\n        }\n\n        // assume query is a string and return item by id\n        return (\n            items.find(function(item) {\n                return item.id === query;\n            }) || null\n        );\n    };\n\n    var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(aspectRatio) {\n        if (isEmpty(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (/:/.test(aspectRatio)) {\n            var parts = aspectRatio.split(':');\n            return parts[1] / parts[0];\n        }\n        return parseFloat(aspectRatio);\n    };\n\n    var getActiveItems = function getActiveItems(items) {\n        return items.filter(function(item) {\n            return !item.archived;\n        });\n    };\n\n    var Status = {\n        EMPTY: 0,\n        IDLE: 1, // waiting\n        ERROR: 2, // a file is in error state\n        BUSY: 3, // busy processing or loading\n        READY: 4, // all files uploaded\n    };\n\n    var res = null;\n    var canUpdateFileInput = function canUpdateFileInput() {\n        if (res === null) {\n            try {\n                var dataTransfer = new DataTransfer();\n                dataTransfer.items.add(new File(['hello world'], 'This_Works.txt'));\n                var el = document.createElement('input');\n                el.setAttribute('type', 'file');\n                el.files = dataTransfer.files;\n                res = el.files.length === 1;\n            } catch (err) {\n                res = false;\n            }\n        }\n        return res;\n    };\n\n    var ITEM_ERROR = [\n        ItemStatus.LOAD_ERROR,\n        ItemStatus.PROCESSING_ERROR,\n        ItemStatus.PROCESSING_REVERT_ERROR,\n    ];\n\n    var ITEM_BUSY = [\n        ItemStatus.LOADING,\n        ItemStatus.PROCESSING,\n        ItemStatus.PROCESSING_QUEUED,\n        ItemStatus.INIT,\n    ];\n\n    var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n    var isItemInErrorState = function isItemInErrorState(item) {\n        return ITEM_ERROR.includes(item.status);\n    };\n    var isItemInBusyState = function isItemInBusyState(item) {\n        return ITEM_BUSY.includes(item.status);\n    };\n    var isItemInReadyState = function isItemInReadyState(item) {\n        return ITEM_READY.includes(item.status);\n    };\n\n    var isAsync = function isAsync(state) {\n        return (\n            isObject(state.options.server) &&\n            (isObject(state.options.server.process) || isFunction(state.options.server.process))\n        );\n    };\n\n    var queries = function queries(state) {\n        return {\n            GET_STATUS: function GET_STATUS() {\n                var items = getActiveItems(state.items);\n                var EMPTY = Status.EMPTY,\n                    ERROR = Status.ERROR,\n                    BUSY = Status.BUSY,\n                    IDLE = Status.IDLE,\n                    READY = Status.READY;\n\n                if (items.length === 0) return EMPTY;\n\n                if (items.some(isItemInErrorState)) return ERROR;\n\n                if (items.some(isItemInBusyState)) return BUSY;\n\n                if (items.some(isItemInReadyState)) return READY;\n\n                return IDLE;\n            },\n\n            GET_ITEM: function GET_ITEM(query) {\n                return getItemByQuery(state.items, query);\n            },\n\n            GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n                return getItemByQuery(getActiveItems(state.items), query);\n            },\n\n            GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n                return getActiveItems(state.items);\n            },\n\n            GET_ITEMS: function GET_ITEMS() {\n                return state.items;\n            },\n\n            GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.filename : null;\n            },\n\n            GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n                var item = getItemByQuery(state.items, query);\n                return item ? item.fileSize : null;\n            },\n\n            GET_STYLES: function GET_STYLES() {\n                return Object.keys(state.options)\n                    .filter(function(key) {\n                        return /^style/.test(key);\n                    })\n                    .map(function(option) {\n                        return {\n                            name: option,\n                            value: state.options[option],\n                        };\n                    });\n            },\n\n            GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n                var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n                var aspectRatio = isShapeCircle\n                    ? 1\n                    : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n                return aspectRatio;\n            },\n\n            GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n                return state.options.styleItemPanelAspectRatio;\n            },\n\n            GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n                return getActiveItems(state.items).filter(function(item) {\n                    return item.status === status;\n                });\n            },\n\n            GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n                return getActiveItems(state.items).length;\n            },\n\n            SHOULD_UPDATE_FILE_INPUT: function SHOULD_UPDATE_FILE_INPUT() {\n                return state.options.storeAsFile && canUpdateFileInput() && !isAsync(state);\n            },\n\n            IS_ASYNC: function IS_ASYNC() {\n                return isAsync(state);\n            },\n\n            GET_FILE_SIZE_LABELS: function GET_FILE_SIZE_LABELS(query) {\n                return {\n                    labelBytes: query('GET_LABEL_FILE_SIZE_BYTES') || undefined,\n                    labelKilobytes: query('GET_LABEL_FILE_SIZE_KILOBYTES') || undefined,\n                    labelMegabytes: query('GET_LABEL_FILE_SIZE_MEGABYTES') || undefined,\n                    labelGigabytes: query('GET_LABEL_FILE_SIZE_GIGABYTES') || undefined,\n                };\n            },\n        };\n    };\n\n    var hasRoomForItem = function hasRoomForItem(state) {\n        var count = getActiveItems(state.items).length;\n\n        // if cannot have multiple items, to add one item it should currently not contain items\n        if (!state.options.allowMultiple) {\n            return count === 0;\n        }\n\n        // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n        var maxFileCount = state.options.maxFiles;\n        if (maxFileCount === null) {\n            return true;\n        }\n\n        // we check if the current count is smaller than the max count, if so, another file can still be added\n        if (count < maxFileCount) {\n            return true;\n        }\n\n        // no more room for another file\n        return false;\n    };\n\n    var limit = function limit(value, min, max) {\n        return Math.max(Math.min(max, value), min);\n    };\n\n    var arrayInsert = function arrayInsert(arr, index, item) {\n        return arr.splice(index, 0, item);\n    };\n\n    var insertItem = function insertItem(items, item, index) {\n        if (isEmpty(item)) {\n            return null;\n        }\n\n        // if index is undefined, append\n        if (typeof index === 'undefined') {\n            items.push(item);\n            return item;\n        }\n\n        // limit the index to the size of the items array\n        index = limit(index, 0, items.length);\n\n        // add item to array\n        arrayInsert(items, index, item);\n\n        // expose\n        return item;\n    };\n\n    var isBase64DataURI = function isBase64DataURI(str) {\n        return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n            str\n        );\n    };\n\n    var getFilenameFromURL = function getFilenameFromURL(url) {\n        return ('' + url)\n            .split('/')\n            .pop()\n            .split('?')\n            .shift();\n    };\n\n    var getExtensionFromFilename = function getExtensionFromFilename(name) {\n        return name.split('.').pop();\n    };\n\n    var guesstimateExtension = function guesstimateExtension(type) {\n        // if no extension supplied, exit here\n        if (typeof type !== 'string') {\n            return '';\n        }\n\n        // get subtype\n        var subtype = type.split('/').pop();\n\n        // is svg subtype\n        if (/svg/.test(subtype)) {\n            return 'svg';\n        }\n\n        if (/zip|compressed/.test(subtype)) {\n            return 'zip';\n        }\n\n        if (/plain/.test(subtype)) {\n            return 'txt';\n        }\n\n        if (/msword/.test(subtype)) {\n            return 'doc';\n        }\n\n        // if is valid subtype\n        if (/[a-z]+/.test(subtype)) {\n            // always use jpg extension\n            if (subtype === 'jpeg') {\n                return 'jpg';\n            }\n\n            // return subtype\n            return subtype;\n        }\n\n        return '';\n    };\n\n    var leftPad = function leftPad(value) {\n        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        return (padding + value).slice(-padding.length);\n    };\n\n    var getDateString = function getDateString() {\n        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n        return (\n            date.getFullYear() +\n            '-' +\n            leftPad(date.getMonth() + 1, '00') +\n            '-' +\n            leftPad(date.getDate(), '00') +\n            '_' +\n            leftPad(date.getHours(), '00') +\n            '-' +\n            leftPad(date.getMinutes(), '00') +\n            '-' +\n            leftPad(date.getSeconds(), '00')\n        );\n    };\n\n    var getFileFromBlob = function getFileFromBlob(blob, filename) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var extension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var file =\n            typeof type === 'string'\n                ? blob.slice(0, blob.size, type)\n                : blob.slice(0, blob.size, blob.type);\n        file.lastModifiedDate = new Date();\n\n        // copy relative path\n        if (blob._relativePath) file._relativePath = blob._relativePath;\n\n        // if blob has name property, use as filename if no filename supplied\n        if (!isString(filename)) {\n            filename = getDateString();\n        }\n\n        // if filename supplied but no extension and filename has extension\n        if (filename && extension === null && getExtensionFromFilename(filename)) {\n            file.name = filename;\n        } else {\n            extension = extension || guesstimateExtension(file.type);\n            file.name = filename + (extension ? '.' + extension : '');\n        }\n\n        return file;\n    };\n\n    var getBlobBuilder = function getBlobBuilder() {\n        return (window.BlobBuilder =\n            window.BlobBuilder ||\n            window.WebKitBlobBuilder ||\n            window.MozBlobBuilder ||\n            window.MSBlobBuilder);\n    };\n\n    var createBlob = function createBlob(arrayBuffer, mimeType) {\n        var BB = getBlobBuilder();\n\n        if (BB) {\n            var bb = new BB();\n            bb.append(arrayBuffer);\n            return bb.getBlob(mimeType);\n        }\n\n        return new Blob([arrayBuffer], {\n            type: mimeType,\n        });\n    };\n\n    var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n        byteString,\n        mimeType\n    ) {\n        var ab = new ArrayBuffer(byteString.length);\n        var ia = new Uint8Array(ab);\n\n        for (var i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n\n        return createBlob(ab, mimeType);\n    };\n\n    var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(dataURI) {\n        return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n    };\n\n    var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(dataURI) {\n        // get data part of string (remove data:image/jpeg...,)\n        var data = dataURI.split(',')[1];\n\n        // remove any whitespace as that causes InvalidCharacterError in IE\n        return data.replace(/\\s/g, '');\n    };\n\n    var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(dataURI) {\n        return atob(getBase64DataFromBase64DataURI(dataURI));\n    };\n\n    var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n        var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n        var byteString = getByteStringFromBase64DataURI(dataURI);\n\n        return getBlobFromByteStringWithMimeType(byteString, mimeType);\n    };\n\n    var getFileFromBase64DataURI = function getFileFromBase64DataURI(dataURI, filename, extension) {\n        return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n    };\n\n    var getFileNameFromHeader = function getFileNameFromHeader(header) {\n        // test if is content disposition header, if not exit\n        if (!/^content-disposition:/i.test(header)) return null;\n\n        // get filename parts\n        var matches = header\n            .split(/filename=|filename\\*=.+''/)\n            .splice(1)\n            .map(function(name) {\n                return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n            })\n            .filter(function(name) {\n                return name.length;\n            });\n\n        return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n    };\n\n    var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n        if (/content-length:/i.test(header)) {\n            var size = header.match(/[0-9]+/)[0];\n            return size ? parseInt(size, 10) : null;\n        }\n        return null;\n    };\n\n    var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n        if (/x-content-transfer-id:/i.test(header)) {\n            var id = (header.split(':')[1] || '').trim();\n            return id || null;\n        }\n        return null;\n    };\n\n    var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n        var info = {\n            source: null,\n            name: null,\n            size: null,\n        };\n\n        var rows = headers.split('\\n');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for (\n                var _iterator = rows[Symbol.iterator](), _step;\n                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n                _iteratorNormalCompletion = true\n            ) {\n                var header = _step.value;\n\n                var name = getFileNameFromHeader(header);\n                if (name) {\n                    info.name = name;\n                    continue;\n                }\n\n                var size = getFileSizeFromHeader(header);\n                if (size) {\n                    info.size = size;\n                    continue;\n                }\n\n                var source = getTranfserIdFromHeader(header);\n                if (source) {\n                    info.source = source;\n                    continue;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return info;\n    };\n\n    var createFileLoader = function createFileLoader(fetchFn) {\n        var state = {\n            source: null,\n            complete: false,\n            progress: 0,\n            size: null,\n            timestamp: null,\n            duration: 0,\n            request: null,\n        };\n\n        var getProgress = function getProgress() {\n            return state.progress;\n        };\n        var abort = function abort() {\n            if (state.request && state.request.abort) {\n                state.request.abort();\n            }\n        };\n\n        // load source\n        var load = function load() {\n            // get quick reference\n            var source = state.source;\n\n            api.fire('init', source);\n\n            // Load Files\n            if (source instanceof File) {\n                api.fire('load', source);\n            } else if (source instanceof Blob) {\n                // Load blobs, set default name to current date\n                api.fire('load', getFileFromBlob(source, source.name));\n            } else if (isBase64DataURI(source)) {\n                // Load base 64, set default name to current date\n                api.fire('load', getFileFromBase64DataURI(source));\n            } else {\n                // Deal as if is external URL, let's load it!\n                loadURL(source);\n            }\n        };\n\n        // loads a url\n        var loadURL = function loadURL(url) {\n            // is remote url and no fetch method supplied\n            if (!fetchFn) {\n                api.fire('error', {\n                    type: 'error',\n                    body: \"Can't load URL\",\n                    code: 400,\n                });\n\n                return;\n            }\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // load file\n            state.request = fetchFn(\n                url,\n                function(response) {\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // done!\n                    state.complete = true;\n\n                    // turn blob response into a file\n                    if (response instanceof Blob) {\n                        response = getFileFromBlob(\n                            response,\n                            response.name || getFilenameFromURL(url)\n                        );\n                    }\n\n                    api.fire(\n                        'load',\n                        // if has received blob, we go with blob, if no response, we return null\n                        response instanceof Blob ? response : response ? response.body : null\n                    );\n                },\n                function(error) {\n                    api.fire(\n                        'error',\n                        typeof error === 'string'\n                            ? {\n                                  type: 'error',\n                                  code: 0,\n                                  body: error,\n                              }\n                            : error\n                    );\n                },\n                function(computable, current, total) {\n                    // collected some meta data already\n                    if (total) {\n                        state.size = total;\n                    }\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // if we can't compute progress, we're not going to fire progress events\n                    if (!computable) {\n                        state.progress = null;\n                        return;\n                    }\n\n                    // update progress percentage\n                    state.progress = current / total;\n\n                    // expose\n                    api.fire('progress', state.progress);\n                },\n                function() {\n                    api.fire('abort');\n                },\n                function(response) {\n                    var fileinfo = getFileInfoFromHeaders(\n                        typeof response === 'string' ? response : response.headers\n                    );\n                    api.fire('meta', {\n                        size: state.size || fileinfo.size,\n                        filename: fileinfo.name,\n                        source: fileinfo.source,\n                    });\n                }\n            );\n        };\n\n        var api = Object.assign({}, on(), {\n            setSource: function setSource(source) {\n                return (state.source = source);\n            },\n            getProgress: getProgress, // file load progress\n            abort: abort, // abort file load\n            load: load, // start load\n        });\n\n        return api;\n    };\n\n    var isGet = function isGet(method) {\n        return /GET|HEAD/.test(method);\n    };\n\n    var sendRequest = function sendRequest(data, url, options) {\n        var api = {\n            onheaders: function onheaders() {},\n            onprogress: function onprogress() {},\n            onload: function onload() {},\n            ontimeout: function ontimeout() {},\n            onerror: function onerror() {},\n            onabort: function onabort() {},\n            abort: function abort() {\n                aborted = true;\n                xhr.abort();\n            },\n        };\n\n        // timeout identifier, only used when timeout is defined\n        var aborted = false;\n        var headersReceived = false;\n\n        // set default options\n        options = Object.assign(\n            {\n                method: 'POST',\n                headers: {},\n                withCredentials: false,\n            },\n            options\n        );\n\n        // encode url\n        url = encodeURI(url);\n\n        // if method is GET, add any received data to url\n\n        if (isGet(options.method) && data) {\n            url =\n                '' +\n                url +\n                encodeURIComponent(typeof data === 'string' ? data : JSON.stringify(data));\n        }\n\n        // create request\n        var xhr = new XMLHttpRequest();\n\n        // progress of load\n        var process = isGet(options.method) ? xhr : xhr.upload;\n        process.onprogress = function(e) {\n            // no progress event when aborted ( onprogress is called once after abort() )\n            if (aborted) {\n                return;\n            }\n\n            api.onprogress(e.lengthComputable, e.loaded, e.total);\n        };\n\n        // tries to get header info to the app as fast as possible\n        xhr.onreadystatechange = function() {\n            // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n            if (xhr.readyState < 2) {\n                return;\n            }\n\n            // no server response\n            if (xhr.readyState === 4 && xhr.status === 0) {\n                return;\n            }\n\n            if (headersReceived) {\n                return;\n            }\n\n            headersReceived = true;\n\n            // we've probably received some useful data in response headers\n            api.onheaders(xhr);\n        };\n\n        // load successful\n        xhr.onload = function() {\n            // is classified as valid response\n            if (xhr.status >= 200 && xhr.status < 300) {\n                api.onload(xhr);\n            } else {\n                api.onerror(xhr);\n            }\n        };\n\n        // error during load\n        xhr.onerror = function() {\n            return api.onerror(xhr);\n        };\n\n        // request aborted\n        xhr.onabort = function() {\n            aborted = true;\n            api.onabort();\n        };\n\n        // request timeout\n        xhr.ontimeout = function() {\n            return api.ontimeout(xhr);\n        };\n\n        // open up open up!\n        xhr.open(options.method, url, true);\n\n        // set timeout if defined (do it after open so IE11 plays ball)\n        if (isInt(options.timeout)) {\n            xhr.timeout = options.timeout;\n        }\n\n        // add headers\n        Object.keys(options.headers).forEach(function(key) {\n            var value = unescape(encodeURIComponent(options.headers[key]));\n            xhr.setRequestHeader(key, value);\n        });\n\n        // set type of response\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n\n        // set credentials\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        // let's send our data\n        xhr.send(data);\n\n        return api;\n    };\n\n    var createResponse = function createResponse(type, code, body, headers) {\n        return {\n            type: type,\n            code: code,\n            body: body,\n            headers: headers,\n        };\n    };\n\n    var createTimeoutResponse = function createTimeoutResponse(cb) {\n        return function(xhr) {\n            cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n        };\n    };\n\n    var hasQS = function hasQS(str) {\n        return /\\?/.test(str);\n    };\n    var buildURL = function buildURL() {\n        var url = '';\n        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n            parts[_key] = arguments[_key];\n        }\n        parts.forEach(function(part) {\n            url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n        });\n        return url;\n    };\n\n    var createFetchFunction = function createFetchFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied\n        if (!action || !isString(action.url)) {\n            return null;\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal handler\n        return function(url, load, error, progress, abort, headers) {\n            // do local or remote request based on if the url is external\n            var request = sendRequest(\n                url,\n                buildURL(apiUrl, action.url),\n                Object.assign({}, action, {\n                    responseType: 'blob',\n                })\n            );\n\n            request.onload = function(xhr) {\n                // get headers\n                var headers = xhr.getAllResponseHeaders();\n\n                // get filename\n                var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n                // create response\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        action.method === 'HEAD'\n                            ? null\n                            : getFileFromBlob(onload(xhr.response), filename),\n                        headers\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onheaders = function(xhr) {\n                headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var ChunkStatus = {\n        QUEUED: 0,\n        COMPLETE: 1,\n        PROCESSING: 2,\n        ERROR: 3,\n        WAITING: 4,\n    };\n\n    /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n    // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n    var processFileChunked = function processFileChunked(\n        apiUrl,\n        action,\n        name,\n        file,\n        metadata,\n        load,\n        error,\n        progress,\n        abort,\n        transfer,\n        options\n    ) {\n        // all chunks\n        var chunks = [];\n        var chunkTransferId = options.chunkTransferId,\n            chunkServer = options.chunkServer,\n            chunkSize = options.chunkSize,\n            chunkRetryDelays = options.chunkRetryDelays;\n\n        // default state\n        var state = {\n            serverId: chunkTransferId,\n            aborted: false,\n        };\n\n        // set onload handlers\n        var ondata =\n            action.ondata ||\n            function(fd) {\n                return fd;\n            };\n        var onload =\n            action.onload ||\n            function(xhr, method) {\n                return method === 'HEAD' ? xhr.getResponseHeader('Upload-Offset') : xhr.response;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // create server hook\n        var requestTransferId = function requestTransferId(cb) {\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata)\n                    : Object.assign(\n                          {},\n\n                          action.headers,\n                          {\n                              'Upload-Length': file.size,\n                          }\n                      );\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        var requestTransferOffset = function requestTransferOffset(cb) {\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(state.serverId)\n                    : Object.assign(\n                          {},\n\n                          action.headers\n                      );\n\n            var requestParams = {\n                headers: headers,\n                method: 'HEAD',\n            };\n\n            var request = sendRequest(null, requestUrl, requestParams);\n\n            request.onload = function(xhr) {\n                return cb(onload(xhr, requestParams.method));\n            };\n\n            request.onerror = function(xhr) {\n                return error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n        };\n\n        // create chunks\n        var lastChunkIndex = Math.floor(file.size / chunkSize);\n        for (var i = 0; i <= lastChunkIndex; i++) {\n            var offset = i * chunkSize;\n            var data = file.slice(offset, offset + chunkSize, 'application/offset+octet-stream');\n            chunks[i] = {\n                index: i,\n                size: data.size,\n                offset: offset,\n                data: data,\n                file: file,\n                progress: 0,\n                retries: _toConsumableArray(chunkRetryDelays),\n                status: ChunkStatus.QUEUED,\n                error: null,\n                request: null,\n                timeout: null,\n            };\n        }\n\n        var completeProcessingChunks = function completeProcessingChunks() {\n            return load(state.serverId);\n        };\n\n        var canProcessChunk = function canProcessChunk(chunk) {\n            return chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n        };\n\n        var processChunk = function processChunk(chunk) {\n            // processing is paused, wait here\n            if (state.aborted) return;\n\n            // get next chunk to process\n            chunk = chunk || chunks.find(canProcessChunk);\n\n            // no more chunks to process\n            if (!chunk) {\n                // all done?\n                if (\n                    chunks.every(function(chunk) {\n                        return chunk.status === ChunkStatus.COMPLETE;\n                    })\n                ) {\n                    completeProcessingChunks();\n                }\n\n                // no chunk to handle\n                return;\n            }\n\n            // now processing this chunk\n            chunk.status = ChunkStatus.PROCESSING;\n            chunk.progress = null;\n\n            // allow parsing of formdata\n            var ondata =\n                chunkServer.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onerror =\n                chunkServer.onerror ||\n                function(res) {\n                    return null;\n                };\n            var onload = chunkServer.onload || function() {};\n\n            // send request object\n            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n            var headers =\n                typeof chunkServer.headers === 'function'\n                    ? chunkServer.headers(chunk)\n                    : Object.assign(\n                          {},\n\n                          chunkServer.headers,\n                          {\n                              'Content-Type': 'application/offset+octet-stream',\n                              'Upload-Offset': chunk.offset,\n                              'Upload-Length': file.size,\n                              'Upload-Name': file.name,\n                          }\n                      );\n\n            var request = (chunk.request = sendRequest(\n                ondata(chunk.data),\n                requestUrl,\n                Object.assign({}, chunkServer, {\n                    headers: headers,\n                })\n            ));\n\n            request.onload = function(xhr) {\n                // allow hooking into request result\n                onload(xhr, chunk.index, chunks.length);\n\n                // done!\n                chunk.status = ChunkStatus.COMPLETE;\n\n                // remove request reference\n                chunk.request = null;\n\n                // start processing more chunks\n                processChunks();\n            };\n\n            request.onprogress = function(lengthComputable, loaded, total) {\n                chunk.progress = lengthComputable ? loaded : null;\n                updateTotalProgress();\n            };\n\n            request.onerror = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                chunk.error = onerror(xhr.response) || xhr.statusText;\n                if (!retryProcessChunk(chunk)) {\n                    error(\n                        createResponse(\n                            'error',\n                            xhr.status,\n                            onerror(xhr.response) || xhr.statusText,\n                            xhr.getAllResponseHeaders()\n                        )\n                    );\n                }\n            };\n\n            request.ontimeout = function(xhr) {\n                chunk.status = ChunkStatus.ERROR;\n                chunk.request = null;\n                if (!retryProcessChunk(chunk)) {\n                    createTimeoutResponse(error)(xhr);\n                }\n            };\n\n            request.onabort = function() {\n                chunk.status = ChunkStatus.QUEUED;\n                chunk.request = null;\n                abort();\n            };\n        };\n\n        var retryProcessChunk = function retryProcessChunk(chunk) {\n            // no more retries left\n            if (chunk.retries.length === 0) return false;\n\n            // new retry\n            chunk.status = ChunkStatus.WAITING;\n            clearTimeout(chunk.timeout);\n            chunk.timeout = setTimeout(function() {\n                processChunk(chunk);\n            }, chunk.retries.shift());\n\n            // we're going to retry\n            return true;\n        };\n\n        var updateTotalProgress = function updateTotalProgress() {\n            // calculate total progress fraction\n            var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n                if (p === null || chunk.progress === null) return null;\n                return p + chunk.progress;\n            }, 0);\n\n            // can't compute progress\n            if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n            // calculate progress values\n            var totalSize = chunks.reduce(function(total, chunk) {\n                return total + chunk.size;\n            }, 0);\n\n            // can update progress indicator\n            progress(true, totalBytesTransfered, totalSize);\n        };\n\n        // process new chunks\n        var processChunks = function processChunks() {\n            var totalProcessing = chunks.filter(function(chunk) {\n                return chunk.status === ChunkStatus.PROCESSING;\n            }).length;\n            if (totalProcessing >= 1) return;\n            processChunk();\n        };\n\n        var abortChunks = function abortChunks() {\n            chunks.forEach(function(chunk) {\n                clearTimeout(chunk.timeout);\n                if (chunk.request) {\n                    chunk.request.abort();\n                }\n            });\n        };\n\n        // let's go!\n        if (!state.serverId) {\n            requestTransferId(function(serverId) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // pass back to item so we can use it if something goes wrong\n                transfer(serverId);\n\n                // store internally\n                state.serverId = serverId;\n                processChunks();\n            });\n        } else {\n            requestTransferOffset(function(offset) {\n                // stop here if aborted, might have happened in between request and callback\n                if (state.aborted) return;\n\n                // mark chunks with lower offset as complete\n                chunks\n                    .filter(function(chunk) {\n                        return chunk.offset < offset;\n                    })\n                    .forEach(function(chunk) {\n                        chunk.status = ChunkStatus.COMPLETE;\n                        chunk.progress = chunk.size;\n                    });\n\n                // continue processing\n                processChunks();\n            });\n        }\n\n        return {\n            abort: function abort() {\n                state.aborted = true;\n                abortChunks();\n            },\n        };\n    };\n\n    /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n    var createFileProcessorFunction = function createFileProcessorFunction(\n        apiUrl,\n        action,\n        name,\n        options\n    ) {\n        return function(file, metadata, load, error, progress, abort, transfer) {\n            // no file received\n            if (!file) return;\n\n            // if was passed a file, and we can chunk it, exit here\n            var canChunkUpload = options.chunkUploads;\n            var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n            var willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n            if (file instanceof Blob && willChunkUpload)\n                return processFileChunked(\n                    apiUrl,\n                    action,\n                    name,\n                    file,\n                    metadata,\n                    load,\n                    error,\n                    progress,\n                    abort,\n                    transfer,\n                    options\n                );\n\n            // set handlers\n            var ondata =\n                action.ondata ||\n                function(fd) {\n                    return fd;\n                };\n            var onload =\n                action.onload ||\n                function(res) {\n                    return res;\n                };\n            var onerror =\n                action.onerror ||\n                function(res) {\n                    return null;\n                };\n\n            var headers =\n                typeof action.headers === 'function'\n                    ? action.headers(file, metadata) || {}\n                    : Object.assign(\n                          {},\n\n                          action.headers\n                      );\n\n            var requestParams = Object.assign({}, action, {\n                headers: headers,\n            });\n\n            // create formdata object\n            var formData = new FormData();\n\n            // add metadata under same name\n            if (isObject(metadata)) {\n                formData.append(name, JSON.stringify(metadata));\n            }\n\n            // Turn into an array of objects so no matter what the input, we can handle it the same way\n            (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(function(item) {\n                formData.append(\n                    name,\n                    item.file,\n                    item.name === null ? item.file.name : '' + item.name + item.file.name\n                );\n            });\n\n            // send request object\n            var request = sendRequest(\n                ondata(formData),\n                buildURL(apiUrl, action.url),\n                requestParams\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n            request.onprogress = progress;\n            request.onabort = abort;\n\n            // should return request\n            return request;\n        };\n    };\n\n    var createProcessorFunction = function createProcessorFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        var name = arguments.length > 2 ? arguments[2] : undefined;\n        var options = arguments.length > 3 ? arguments[3] : undefined;\n\n        // custom handler (should also handle file, load, error, progress and abort)\n        if (typeof action === 'function')\n            return function() {\n                for (\n                    var _len = arguments.length, params = new Array(_len), _key = 0;\n                    _key < _len;\n                    _key++\n                ) {\n                    params[_key] = arguments[_key];\n                }\n                return action.apply(void 0, [name].concat(params, [options]));\n            };\n\n        // no action supplied\n        if (!action || !isString(action.url)) return null;\n\n        // internal handler\n        return createFileProcessorFunction(apiUrl, action, name, options);\n    };\n\n    /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n    var createRevertFunction = function createRevertFunction() {\n        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var action = arguments.length > 1 ? arguments[1] : undefined;\n        // is custom implementation\n        if (typeof action === 'function') {\n            return action;\n        }\n\n        // no action supplied, return stub function, interface will work, but file won't be removed\n        if (!action || !isString(action.url)) {\n            return function(uniqueFileId, load) {\n                return load();\n            };\n        }\n\n        // set onload hanlder\n        var onload =\n            action.onload ||\n            function(res) {\n                return res;\n            };\n        var onerror =\n            action.onerror ||\n            function(res) {\n                return null;\n            };\n\n        // internal implementation\n        return function(uniqueFileId, load, error) {\n            var request = sendRequest(\n                uniqueFileId,\n                apiUrl + action.url,\n                action // contains method, headers and withCredentials properties\n            );\n            request.onload = function(xhr) {\n                load(\n                    createResponse(\n                        'load',\n                        xhr.status,\n                        onload(xhr.response),\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.onerror = function(xhr) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            };\n\n            request.ontimeout = createTimeoutResponse(error);\n\n            return request;\n        };\n    };\n\n    var getRandomNumber = function getRandomNumber() {\n        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        return min + Math.random() * (max - min);\n    };\n\n    var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(cb) {\n        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var tickMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n        var tickMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n        var timeout = null;\n        var start = Date.now();\n\n        var tick = function tick() {\n            var runtime = Date.now() - start;\n            var delay = getRandomNumber(tickMin, tickMax);\n\n            if (runtime + delay > duration) {\n                delay = runtime + delay - duration;\n            }\n\n            var progress = runtime / duration;\n            if (progress >= 1 || document.hidden) {\n                cb(1);\n                return;\n            }\n\n            cb(progress);\n\n            timeout = setTimeout(tick, delay);\n        };\n\n        if (duration > 0) tick();\n\n        return {\n            clear: function clear() {\n                clearTimeout(timeout);\n            },\n        };\n    };\n\n    var createFileProcessor = function createFileProcessor(processFn, options) {\n        var state = {\n            complete: false,\n            perceivedProgress: 0,\n            perceivedPerformanceUpdater: null,\n            progress: null,\n            timestamp: null,\n            perceivedDuration: 0,\n            duration: 0,\n            request: null,\n            response: null,\n        };\n        var allowMinimumUploadDuration = options.allowMinimumUploadDuration;\n\n        var process = function process(file, metadata) {\n            var progressFn = function progressFn() {\n                // we've not yet started the real download, stop here\n                // the request might not go through, for instance, there might be some server trouble\n                // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n                if (state.duration === 0 || state.progress === null) return;\n\n                // as we're now processing, fire the progress event\n                api.fire('progress', api.getProgress());\n            };\n\n            var completeFn = function completeFn() {\n                state.complete = true;\n                api.fire('load-perceived', state.response.body);\n            };\n\n            // let's start processing\n            api.fire('start');\n\n            // set request start\n            state.timestamp = Date.now();\n\n            // create perceived performance progress indicator\n            state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n                function(progress) {\n                    state.perceivedProgress = progress;\n                    state.perceivedDuration = Date.now() - state.timestamp;\n\n                    progressFn();\n\n                    // if fake progress is done, and a response has been received,\n                    // and we've not yet called the complete method\n                    if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                        // we done!\n                        completeFn();\n                    }\n                },\n                // random delay as in a list of files you start noticing\n                // files uploading at the exact same speed\n                allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0\n            );\n\n            // remember request so we can abort it later\n            state.request = processFn(\n                // the file to process\n                file,\n\n                // the metadata to send along\n                metadata,\n\n                // callbacks (load, error, progress, abort, transfer)\n                // load expects the body to be a server id if\n                // you want to make use of revert\n                function(response) {\n                    // we put the response in state so we can access\n                    // it outside of this method\n                    state.response = isObject(response)\n                        ? response\n                        : {\n                              type: 'load',\n                              code: 200,\n                              body: '' + response,\n                              headers: {},\n                          };\n\n                    // update duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // force progress to 1 as we're now done\n                    state.progress = 1;\n\n                    // actual load is done let's share results\n                    api.fire('load', state.response.body);\n\n                    // we are really done\n                    // if perceived progress is 1 ( wait for perceived progress to complete )\n                    // or if server does not support progress ( null )\n                    if (\n                        !allowMinimumUploadDuration ||\n                        (allowMinimumUploadDuration && state.perceivedProgress === 1)\n                    ) {\n                        completeFn();\n                    }\n                },\n\n                // error is expected to be an object with type, code, body\n                function(error) {\n                    // cancel updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // update others about this error\n                    api.fire(\n                        'error',\n                        isObject(error)\n                            ? error\n                            : {\n                                  type: 'error',\n                                  code: 0,\n                                  body: '' + error,\n                              }\n                    );\n                },\n\n                // actual processing progress\n                function(computable, current, total) {\n                    // update actual duration\n                    state.duration = Date.now() - state.timestamp;\n\n                    // update actual progress\n                    state.progress = computable ? current / total : null;\n\n                    progressFn();\n                },\n\n                // abort does not expect a value\n                function() {\n                    // stop updater\n                    state.perceivedPerformanceUpdater.clear();\n\n                    // fire the abort event so we can switch visuals\n                    api.fire('abort', state.response ? state.response.body : null);\n                },\n\n                // register the id for this transfer\n                function(transferId) {\n                    api.fire('transfer', transferId);\n                }\n            );\n        };\n\n        var abort = function abort() {\n            // no request running, can't abort\n            if (!state.request) return;\n\n            // stop updater\n            state.perceivedPerformanceUpdater.clear();\n\n            // abort actual request\n            if (state.request.abort) state.request.abort();\n\n            // if has response object, we've completed the request\n            state.complete = true;\n        };\n\n        var reset = function reset() {\n            abort();\n            state.complete = false;\n            state.perceivedProgress = 0;\n            state.progress = 0;\n            state.timestamp = null;\n            state.perceivedDuration = 0;\n            state.duration = 0;\n            state.request = null;\n            state.response = null;\n        };\n\n        var getProgress = allowMinimumUploadDuration\n            ? function() {\n                  return state.progress ? Math.min(state.progress, state.perceivedProgress) : null;\n              }\n            : function() {\n                  return state.progress || null;\n              };\n\n        var getDuration = allowMinimumUploadDuration\n            ? function() {\n                  return Math.min(state.duration, state.perceivedDuration);\n              }\n            : function() {\n                  return state.duration;\n              };\n\n        var api = Object.assign({}, on(), {\n            process: process, // start processing file\n            abort: abort, // abort active process request\n            getProgress: getProgress,\n            getDuration: getDuration,\n            reset: reset,\n        });\n\n        return api;\n    };\n\n    var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n        return name.substring(0, name.lastIndexOf('.')) || name;\n    };\n\n    var createFileStub = function createFileStub(source) {\n        var data = [source.name, source.size, source.type];\n\n        // is blob or base64, then we need to set the name\n        if (source instanceof Blob || isBase64DataURI(source)) {\n            data[0] = source.name || getDateString();\n        } else if (isBase64DataURI(source)) {\n            // if is base64 data uri we need to determine the average size and type\n            data[1] = source.length;\n            data[2] = getMimeTypeFromBase64DataURI(source);\n        } else if (isString(source)) {\n            // url\n            data[0] = getFilenameFromURL(source);\n            data[1] = 0;\n            data[2] = 'application/octet-stream';\n        }\n\n        return {\n            name: data[0],\n            size: data[1],\n            type: data[2],\n        };\n    };\n\n    var isFile = function isFile(value) {\n        return !!(value instanceof File || (value instanceof Blob && value.name));\n    };\n\n    var deepCloneObject = function deepCloneObject(src) {\n        if (!isObject(src)) return src;\n        var target = isArray(src) ? [] : {};\n        for (var key in src) {\n            if (!src.hasOwnProperty(key)) continue;\n            var v = src[key];\n            target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n        }\n        return target;\n    };\n\n    var createItem = function createItem() {\n        var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var serverFileReference =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        // unique id for this item, is used to identify the item across views\n        var id = getUniqueId();\n\n        /**\n         * Internal item state\n         */\n        var state = {\n            // is archived\n            archived: false,\n\n            // if is frozen, no longer fires events\n            frozen: false,\n\n            // removed from view\n            released: false,\n\n            // original source\n            source: null,\n\n            // file model reference\n            file: file,\n\n            // id of file on server\n            serverFileReference: serverFileReference,\n\n            // id of file transfer on server\n            transferId: null,\n\n            // is aborted\n            processingAborted: false,\n\n            // current item status\n            status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n\n            // active processes\n            activeLoader: null,\n            activeProcessor: null,\n        };\n\n        // callback used when abort processing is called to link back to the resolve method\n        var abortProcessingRequestComplete = null;\n\n        /**\n         * Externally added item metadata\n         */\n        var metadata = {};\n\n        // item data\n        var setStatus = function setStatus(status) {\n            return (state.status = status);\n        };\n\n        // fire event unless the item has been archived\n        var fire = function fire(event) {\n            if (state.released || state.frozen) return;\n            for (\n                var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n                _key < _len;\n                _key++\n            ) {\n                params[_key - 1] = arguments[_key];\n            }\n            api.fire.apply(api, [event].concat(params));\n        };\n\n        // file data\n        var getFileExtension = function getFileExtension() {\n            return getExtensionFromFilename(state.file.name);\n        };\n        var getFileType = function getFileType() {\n            return state.file.type;\n        };\n        var getFileSize = function getFileSize() {\n            return state.file.size;\n        };\n        var getFile = function getFile() {\n            return state.file;\n        };\n\n        //\n        // logic to load a file\n        //\n        var load = function load(source, loader, onload) {\n            // remember the original item source\n            state.source = source;\n\n            // source is known\n            api.fireSync('init');\n\n            // file stub is already there\n            if (state.file) {\n                api.fireSync('load-skip');\n                return;\n            }\n\n            // set a stub file object while loading the actual data\n            state.file = createFileStub(source);\n\n            // starts loading\n            loader.on('init', function() {\n                fire('load-init');\n            });\n\n            // we'eve received a size indication, let's update the stub\n            loader.on('meta', function(meta) {\n                // set size of file stub\n                state.file.size = meta.size;\n\n                // set name of file stub\n                state.file.filename = meta.filename;\n\n                // if has received source, we done\n                if (meta.source) {\n                    origin = FileOrigin.LIMBO;\n                    state.serverFileReference = meta.source;\n                    state.status = ItemStatus.PROCESSING_COMPLETE;\n                }\n\n                // size has been updated\n                fire('load-meta');\n            });\n\n            // the file is now loading we need to update the progress indicators\n            loader.on('progress', function(progress) {\n                setStatus(ItemStatus.LOADING);\n\n                fire('load-progress', progress);\n            });\n\n            // an error was thrown while loading the file, we need to switch to error state\n            loader.on('error', function(error) {\n                setStatus(ItemStatus.LOAD_ERROR);\n\n                fire('load-request-error', error);\n            });\n\n            // user or another process aborted the file load (cannot retry)\n            loader.on('abort', function() {\n                setStatus(ItemStatus.INIT);\n                fire('load-abort');\n            });\n\n            // done loading\n            loader.on('load', function(file) {\n                // as we've now loaded the file the loader is no longer required\n                state.activeLoader = null;\n\n                // called when file has loaded succesfully\n                var success = function success(result) {\n                    // set (possibly) transformed file\n                    state.file = isFile(result) ? result : state.file;\n\n                    // file received\n                    if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                        setStatus(ItemStatus.PROCESSING_COMPLETE);\n                    } else {\n                        setStatus(ItemStatus.IDLE);\n                    }\n\n                    fire('load');\n                };\n\n                var error = function error(result) {\n                    // set original file\n                    state.file = file;\n                    fire('load-meta');\n\n                    setStatus(ItemStatus.LOAD_ERROR);\n                    fire('load-file-error', result);\n                };\n\n                // if we already have a server file reference, we don't need to call the onload method\n                if (state.serverFileReference) {\n                    success(file);\n                    return;\n                }\n\n                // no server id, let's give this file the full treatment\n                onload(file, success, error);\n            });\n\n            // set loader source data\n            loader.setSource(source);\n\n            // set as active loader\n            state.activeLoader = loader;\n\n            // load the source data\n            loader.load();\n        };\n\n        var retryLoad = function retryLoad() {\n            if (!state.activeLoader) {\n                return;\n            }\n            state.activeLoader.load();\n        };\n\n        var abortLoad = function abortLoad() {\n            if (state.activeLoader) {\n                state.activeLoader.abort();\n                return;\n            }\n            setStatus(ItemStatus.INIT);\n            fire('load-abort');\n        };\n\n        //\n        // logic to process a file\n        //\n        var process = function process(processor, onprocess) {\n            // processing was aborted\n            if (state.processingAborted) {\n                state.processingAborted = false;\n                return;\n            }\n\n            // now processing\n            setStatus(ItemStatus.PROCESSING);\n\n            // reset abort callback\n            abortProcessingRequestComplete = null;\n\n            // if no file loaded we'll wait for the load event\n            if (!(state.file instanceof Blob)) {\n                api.on('load', function() {\n                    process(processor, onprocess);\n                });\n                return;\n            }\n\n            // setup processor\n            processor.on('load', function(serverFileReference) {\n                // need this id to be able to revert the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n            });\n\n            // register transfer id\n            processor.on('transfer', function(transferId) {\n                // need this id to be able to revert the upload\n                state.transferId = transferId;\n            });\n\n            processor.on('load-perceived', function(serverFileReference) {\n                // no longer required\n                state.activeProcessor = null;\n\n                // need this id to be able to rever the upload\n                state.transferId = null;\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.PROCESSING_COMPLETE);\n                fire('process-complete', serverFileReference);\n            });\n\n            processor.on('start', function() {\n                fire('process-start');\n            });\n\n            processor.on('error', function(error) {\n                state.activeProcessor = null;\n                setStatus(ItemStatus.PROCESSING_ERROR);\n                fire('process-error', error);\n            });\n\n            processor.on('abort', function(serverFileReference) {\n                state.activeProcessor = null;\n\n                // if file was uploaded but processing was cancelled during perceived processor time store file reference\n                state.serverFileReference = serverFileReference;\n\n                setStatus(ItemStatus.IDLE);\n                fire('process-abort');\n\n                // has timeout so doesn't interfere with remove action\n                if (abortProcessingRequestComplete) {\n                    abortProcessingRequestComplete();\n                }\n            });\n\n            processor.on('progress', function(progress) {\n                fire('process-progress', progress);\n            });\n\n            // when successfully transformed\n            var success = function success(file) {\n                // if was archived in the mean time, don't process\n                if (state.archived) return;\n\n                // process file!\n                processor.process(file, Object.assign({}, metadata));\n            };\n\n            // something went wrong during transform phase\n            var error = console.error;\n\n            // start processing the file\n            onprocess(state.file, success, error);\n\n            // set as active processor\n            state.activeProcessor = processor;\n        };\n\n        var requestProcessing = function requestProcessing() {\n            state.processingAborted = false;\n            setStatus(ItemStatus.PROCESSING_QUEUED);\n        };\n\n        var abortProcessing = function abortProcessing() {\n            return new Promise(function(resolve) {\n                if (!state.activeProcessor) {\n                    state.processingAborted = true;\n\n                    setStatus(ItemStatus.IDLE);\n                    fire('process-abort');\n\n                    resolve();\n                    return;\n                }\n\n                abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n                    resolve();\n                };\n\n                state.activeProcessor.abort();\n            });\n        };\n\n        //\n        // logic to revert a processed file\n        //\n        var revert = function revert(revertFileUpload, forceRevert) {\n            return new Promise(function(resolve, reject) {\n                // a completed upload will have a serverFileReference, a failed chunked upload where\n                // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n                var serverTransferId =\n                    state.serverFileReference !== null\n                        ? state.serverFileReference\n                        : state.transferId;\n\n                // cannot revert without a server id for this process\n                if (serverTransferId === null) {\n                    resolve();\n                    return;\n                }\n\n                // revert the upload (fire and forget)\n                revertFileUpload(\n                    serverTransferId,\n                    function() {\n                        // reset file server id and transfer id as now it's not available on the server\n                        state.serverFileReference = null;\n                        state.transferId = null;\n                        resolve();\n                    },\n                    function(error) {\n                        // don't set error state when reverting is optional, it will always resolve\n                        if (!forceRevert) {\n                            resolve();\n                            return;\n                        }\n\n                        // oh no errors\n                        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                        fire('process-revert-error');\n                        reject(error);\n                    }\n                );\n\n                // fire event\n                setStatus(ItemStatus.IDLE);\n                fire('process-revert');\n            });\n        };\n\n        // exposed methods\n        var _setMetadata = function setMetadata(key, value, silent) {\n            var keys = key.split('.');\n            var root = keys[0];\n            var last = keys.pop();\n            var data = metadata;\n            keys.forEach(function(key) {\n                return (data = data[key]);\n            });\n\n            // compare old value against new value, if they're the same, we're not updating\n            if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n            // update value\n            data[last] = value;\n\n            // fire update\n            fire('metadata-update', {\n                key: root,\n                value: metadata[root],\n                silent: silent,\n            });\n        };\n\n        var getMetadata = function getMetadata(key) {\n            return deepCloneObject(key ? metadata[key] : metadata);\n        };\n\n        var api = Object.assign(\n            {\n                id: {\n                    get: function get() {\n                        return id;\n                    },\n                },\n                origin: {\n                    get: function get() {\n                        return origin;\n                    },\n                    set: function set(value) {\n                        return (origin = value);\n                    },\n                },\n                serverId: {\n                    get: function get() {\n                        return state.serverFileReference;\n                    },\n                },\n                transferId: {\n                    get: function get() {\n                        return state.transferId;\n                    },\n                },\n                status: {\n                    get: function get() {\n                        return state.status;\n                    },\n                },\n                filename: {\n                    get: function get() {\n                        return state.file.name;\n                    },\n                },\n                filenameWithoutExtension: {\n                    get: function get() {\n                        return getFilenameWithoutExtension(state.file.name);\n                    },\n                },\n                fileExtension: { get: getFileExtension },\n                fileType: { get: getFileType },\n                fileSize: { get: getFileSize },\n                file: { get: getFile },\n                relativePath: {\n                    get: function get() {\n                        return state.file._relativePath;\n                    },\n                },\n\n                source: {\n                    get: function get() {\n                        return state.source;\n                    },\n                },\n\n                getMetadata: getMetadata,\n                setMetadata: function setMetadata(key, value, silent) {\n                    if (isObject(key)) {\n                        var data = key;\n                        Object.keys(data).forEach(function(key) {\n                            _setMetadata(key, data[key], value);\n                        });\n                        return key;\n                    }\n                    _setMetadata(key, value, silent);\n                    return value;\n                },\n\n                extend: function extend(name, handler) {\n                    return (itemAPI[name] = handler);\n                },\n\n                abortLoad: abortLoad,\n                retryLoad: retryLoad,\n                requestProcessing: requestProcessing,\n                abortProcessing: abortProcessing,\n\n                load: load,\n                process: process,\n                revert: revert,\n            },\n\n            on(),\n            {\n                freeze: function freeze() {\n                    return (state.frozen = true);\n                },\n\n                release: function release() {\n                    return (state.released = true);\n                },\n                released: {\n                    get: function get() {\n                        return state.released;\n                    },\n                },\n\n                archive: function archive() {\n                    return (state.archived = true);\n                },\n                archived: {\n                    get: function get() {\n                        return state.archived;\n                    },\n                },\n\n                // replace source and file object\n                setFile: function setFile(file) {\n                    return (state.file = file);\n                },\n            }\n        );\n\n        // create it here instead of returning it instantly so we can extend it later\n        var itemAPI = createObject(api);\n\n        return itemAPI;\n    };\n\n    var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n        // just return first index\n        if (isEmpty(query)) {\n            return 0;\n        }\n\n        // invalid queries\n        if (!isString(query)) {\n            return -1;\n        }\n\n        // return item by id (or -1 if not found)\n        return items.findIndex(function(item) {\n            return item.id === query;\n        });\n    };\n\n    var getItemById = function getItemById(items, itemId) {\n        var index = getItemIndexByQuery(items, itemId);\n        if (index < 0) {\n            return;\n        }\n        return items[index] || null;\n    };\n\n    var fetchBlob = function fetchBlob(url, load, error, progress, abort, headers) {\n        var request = sendRequest(null, url, {\n            method: 'GET',\n            responseType: 'blob',\n        });\n\n        request.onload = function(xhr) {\n            // get headers\n            var headers = xhr.getAllResponseHeaders();\n\n            // get filename\n            var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n            // create response\n            load(\n                createResponse('load', xhr.status, getFileFromBlob(xhr.response, filename), headers)\n            );\n        };\n\n        request.onerror = function(xhr) {\n            error(createResponse('error', xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n\n        request.onheaders = function(xhr) {\n            headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n\n        // should return request\n        return request;\n    };\n\n    var getDomainFromURL = function getDomainFromURL(url) {\n        if (url.indexOf('//') === 0) {\n            url = location.protocol + url;\n        }\n        return url\n            .toLowerCase()\n            .replace('blob:', '')\n            .replace(/([a-z])?:\\/\\//, '$1')\n            .split('/')[0];\n    };\n\n    var isExternalURL = function isExternalURL(url) {\n        return (\n            (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n            getDomainFromURL(location.href) !== getDomainFromURL(url)\n        );\n    };\n\n    var dynamicLabel = function dynamicLabel(label) {\n        return function() {\n            return isFunction(label) ? label.apply(void 0, arguments) : label;\n        };\n    };\n\n    var isMockItem = function isMockItem(item) {\n        return !isFile(item.file);\n    };\n\n    var listUpdated = function listUpdated(dispatch, state) {\n        clearTimeout(state.listUpdateTimeout);\n        state.listUpdateTimeout = setTimeout(function() {\n            dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n        }, 0);\n    };\n\n    var optionalPromise = function optionalPromise(fn) {\n        for (\n            var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;\n            _key < _len;\n            _key++\n        ) {\n            params[_key - 1] = arguments[_key];\n        }\n        return new Promise(function(resolve) {\n            if (!fn) {\n                return resolve(true);\n            }\n\n            var result = fn.apply(void 0, params);\n\n            if (result == null) {\n                return resolve(true);\n            }\n\n            if (typeof result === 'boolean') {\n                return resolve(result);\n            }\n\n            if (typeof result.then === 'function') {\n                result.then(resolve);\n            }\n        });\n    };\n\n    var sortItems = function sortItems(state, compare) {\n        state.items.sort(function(a, b) {\n            return compare(createItemAPI(a), createItemAPI(b));\n        });\n    };\n\n    // returns item based on state\n    var getItemByQueryFromState = function getItemByQueryFromState(state, itemHandler) {\n        return function() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var query = _ref.query,\n                _ref$success = _ref.success,\n                success = _ref$success === void 0 ? function() {} : _ref$success,\n                _ref$failure = _ref.failure,\n                failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n                options = _objectWithoutProperties(_ref, ['query', 'success', 'failure']);\n            var item = getItemByQuery(state.items, query);\n            if (!item) {\n                failure({\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                });\n\n                return;\n            }\n            itemHandler(item, success, failure, options || {});\n        };\n    };\n\n    var actions = function actions(dispatch, query, state) {\n        return {\n            /**\n             * Aborts all ongoing processes\n             */\n            ABORT_ALL: function ABORT_ALL() {\n                getActiveItems(state.items).forEach(function(item) {\n                    item.freeze();\n                    item.abortLoad();\n                    item.abortProcessing();\n                });\n            },\n\n            /**\n             * Sets initial files\n             */\n            DID_SET_FILES: function DID_SET_FILES(_ref2) {\n                var _ref2$value = _ref2.value,\n                    value = _ref2$value === void 0 ? [] : _ref2$value;\n                // map values to file objects\n                var files = value.map(function(file) {\n                    return {\n                        source: file.source ? file.source : file,\n                        options: file.options,\n                    };\n                });\n\n                // loop over files, if file is in list, leave it be, if not, remove\n                // test if items should be moved\n                var activeItems = getActiveItems(state.items);\n\n                activeItems.forEach(function(item) {\n                    // if item not is in new value, remove\n                    if (\n                        !files.find(function(file) {\n                            return file.source === item.source || file.source === item.file;\n                        })\n                    ) {\n                        dispatch('REMOVE_ITEM', { query: item, remove: false });\n                    }\n                });\n\n                // add new files\n                activeItems = getActiveItems(state.items);\n                files.forEach(function(file, index) {\n                    // if file is already in list\n                    if (\n                        activeItems.find(function(item) {\n                            return item.source === file.source || item.file === file.source;\n                        })\n                    )\n                        return;\n\n                    // not in list, add\n                    dispatch(\n                        'ADD_ITEM',\n                        Object.assign({}, file, {\n                            interactionMethod: InteractionMethod.NONE,\n                            index: index,\n                        })\n                    );\n                });\n            },\n\n            DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n                var id = _ref3.id,\n                    action = _ref3.action,\n                    change = _ref3.change;\n                // don't do anything\n                if (change.silent) return;\n\n                // if is called multiple times in close succession we combined all calls together to save resources\n                clearTimeout(state.itemUpdateTimeout);\n                state.itemUpdateTimeout = setTimeout(function() {\n                    var item = getItemById(state.items, id);\n\n                    // only revert and attempt to upload when we're uploading to a server\n                    if (!query('IS_ASYNC')) {\n                        // should we update the output data\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                            action: action,\n                            change: change,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            if (!shouldPrepareOutput) return;\n\n                            dispatch(\n                                'REQUEST_PREPARE_OUTPUT',\n                                {\n                                    query: id,\n                                    item: item,\n                                    success: function success(file) {\n                                        dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                    },\n                                },\n\n                                true\n                            );\n                        });\n\n                        return;\n                    }\n\n                    // if is local item we need to enable upload button so change can be propagated to server\n                    if (item.origin === FileOrigin.LOCAL) {\n                        dispatch('DID_LOAD_ITEM', {\n                            id: item.id,\n                            error: null,\n                            serverFileReference: item.source,\n                        });\n                    }\n\n                    // for async scenarios\n                    var upload = function upload() {\n                        // we push this forward a bit so the interface is updated correctly\n                        setTimeout(function() {\n                            dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n                        }, 32);\n                    };\n\n                    var revert = function revert(doUpload) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(doUpload ? upload : function() {})\n                            .catch(function() {});\n                    };\n\n                    var abort = function abort(doUpload) {\n                        item.abortProcessing().then(doUpload ? upload : function() {});\n                    };\n\n                    // if we should re-upload the file immediately\n                    if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                        return revert(state.options.instantUpload);\n                    }\n\n                    // if currently uploading, cancel upload\n                    if (item.status === ItemStatus.PROCESSING) {\n                        return abort(state.options.instantUpload);\n                    }\n\n                    if (state.options.instantUpload) {\n                        upload();\n                    }\n                }, 0);\n            },\n\n            MOVE_ITEM: function MOVE_ITEM(_ref4) {\n                var query = _ref4.query,\n                    index = _ref4.index;\n                var item = getItemByQuery(state.items, query);\n                if (!item) return;\n                var currentIndex = state.items.indexOf(item);\n                index = limit(index, 0, state.items.length - 1);\n                if (currentIndex === index) return;\n                state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n            },\n\n            SORT: function SORT(_ref5) {\n                var compare = _ref5.compare;\n                sortItems(state, compare);\n                dispatch('DID_SORT_ITEMS', {\n                    items: query('GET_ACTIVE_ITEMS'),\n                });\n            },\n\n            ADD_ITEMS: function ADD_ITEMS(_ref6) {\n                var items = _ref6.items,\n                    index = _ref6.index,\n                    interactionMethod = _ref6.interactionMethod,\n                    _ref6$success = _ref6.success,\n                    success = _ref6$success === void 0 ? function() {} : _ref6$success,\n                    _ref6$failure = _ref6.failure,\n                    failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n                var currentIndex = index;\n\n                if (index === -1 || typeof index === 'undefined') {\n                    var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n                    var totalItems = query('GET_TOTAL_ITEMS');\n                    currentIndex = insertLocation === 'before' ? 0 : totalItems;\n                }\n\n                var ignoredFiles = query('GET_IGNORED_FILES');\n                var isValidFile = function isValidFile(source) {\n                    return isFile(source)\n                        ? !ignoredFiles.includes(source.name.toLowerCase())\n                        : !isEmpty(source);\n                };\n                var validItems = items.filter(isValidFile);\n\n                var promises = validItems.map(function(source) {\n                    return new Promise(function(resolve, reject) {\n                        dispatch('ADD_ITEM', {\n                            interactionMethod: interactionMethod,\n                            source: source.source || source,\n                            success: resolve,\n                            failure: reject,\n                            index: currentIndex++,\n                            options: source.options || {},\n                        });\n                    });\n                });\n\n                Promise.all(promises)\n                    .then(success)\n                    .catch(failure);\n            },\n\n            /**\n             * @param source\n             * @param index\n             * @param interactionMethod\n             */\n            ADD_ITEM: function ADD_ITEM(_ref7) {\n                var source = _ref7.source,\n                    _ref7$index = _ref7.index,\n                    index = _ref7$index === void 0 ? -1 : _ref7$index,\n                    interactionMethod = _ref7.interactionMethod,\n                    _ref7$success = _ref7.success,\n                    success = _ref7$success === void 0 ? function() {} : _ref7$success,\n                    _ref7$failure = _ref7.failure,\n                    failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n                    _ref7$options = _ref7.options,\n                    options = _ref7$options === void 0 ? {} : _ref7$options;\n                // if no source supplied\n                if (isEmpty(source)) {\n                    failure({\n                        error: createResponse('error', 0, 'No source'),\n                        file: null,\n                    });\n\n                    return;\n                }\n\n                // filter out invalid file items, used to filter dropped directory contents\n                if (\n                    isFile(source) &&\n                    state.options.ignoredFiles.includes(source.name.toLowerCase())\n                ) {\n                    // fail silently\n                    return;\n                }\n\n                // test if there's still room in the list of files\n                if (!hasRoomForItem(state)) {\n                    // if multiple allowed, we can't replace\n                    // or if only a single item is allowed but we're not allowed to replace it we exit\n                    if (\n                        state.options.allowMultiple ||\n                        (!state.options.allowMultiple && !state.options.allowReplace)\n                    ) {\n                        var error = createResponse('warning', 0, 'Max files');\n\n                        dispatch('DID_THROW_MAX_FILES', {\n                            source: source,\n                            error: error,\n                        });\n\n                        failure({ error: error, file: null });\n\n                        return;\n                    }\n\n                    // let's replace the item\n                    // id of first item we're about to remove\n                    var _item = getActiveItems(state.items)[0];\n\n                    // if has been processed remove it from the server as well\n                    if (\n                        _item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        var forceRevert = query('GET_FORCE_REVERT');\n                        _item\n                            .revert(\n                                createRevertFunction(\n                                    state.options.server.url,\n                                    state.options.server.revert\n                                ),\n                                forceRevert\n                            )\n                            .then(function() {\n                                if (!forceRevert) return;\n\n                                // try to add now\n                                dispatch('ADD_ITEM', {\n                                    source: source,\n                                    index: index,\n                                    interactionMethod: interactionMethod,\n                                    success: success,\n                                    failure: failure,\n                                    options: options,\n                                });\n                            })\n                            .catch(function() {}); // no need to handle this catch state for now\n\n                        if (forceRevert) return;\n                    }\n\n                    // remove first item as it will be replaced by this item\n                    dispatch('REMOVE_ITEM', { query: _item.id });\n                }\n\n                // where did the file originate\n                var origin =\n                    options.type === 'local'\n                        ? FileOrigin.LOCAL\n                        : options.type === 'limbo'\n                        ? FileOrigin.LIMBO\n                        : FileOrigin.INPUT;\n\n                // create a new blank item\n                var item = createItem(\n                    // where did this file come from\n                    origin,\n\n                    // an input file never has a server file reference\n                    origin === FileOrigin.INPUT ? null : source,\n\n                    // file mock data, if defined\n                    options.file\n                );\n\n                // set initial meta data\n                Object.keys(options.metadata || {}).forEach(function(key) {\n                    item.setMetadata(key, options.metadata[key]);\n                });\n\n                // created the item, let plugins add methods\n                applyFilters('DID_CREATE_ITEM', item, { query: query, dispatch: dispatch });\n\n                // where to insert new items\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n                // adjust index if is not allowed to pick location\n                if (!state.options.itemInsertLocationFreedom) {\n                    index = itemInsertLocation === 'before' ? -1 : state.items.length;\n                }\n\n                // add item to list\n                insertItem(state.items, item, index);\n\n                // sort items in list\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // get a quick reference to the item id\n                var id = item.id;\n\n                // observe item events\n                item.on('init', function() {\n                    dispatch('DID_INIT_ITEM', { id: id });\n                });\n\n                item.on('load-init', function() {\n                    dispatch('DID_START_ITEM_LOAD', { id: id });\n                });\n\n                item.on('load-meta', function() {\n                    dispatch('DID_UPDATE_ITEM_META', { id: id });\n                });\n\n                item.on('load-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('load-request-error', function(error) {\n                    var mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n\n                    // is client error, no way to recover\n                    if (error.code >= 400 && error.code < 500) {\n                        dispatch('DID_THROW_ITEM_INVALID', {\n                            id: id,\n                            error: error,\n                            status: {\n                                main: mainStatus,\n                                sub: error.code + ' (' + error.body + ')',\n                            },\n                        });\n\n                        // reject the file so can be dealt with through API\n                        failure({ error: error, file: createItemAPI(item) });\n                        return;\n                    }\n\n                    // is possible server error, so might be possible to retry\n                    dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: mainStatus,\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('load-file-error', function(error) {\n                    dispatch('DID_THROW_ITEM_INVALID', {\n                        id: id,\n                        error: error.status,\n                        status: error.status,\n                    });\n\n                    failure({ error: error.status, file: createItemAPI(item) });\n                });\n\n                item.on('load-abort', function() {\n                    dispatch('REMOVE_ITEM', { query: id });\n                });\n\n                item.on('load-skip', function() {\n                    item.on('metadata-update', function(change) {\n                        if (!isFile(item.file)) return;\n                        dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n                    });\n\n                    dispatch('COMPLETE_LOAD_ITEM', {\n                        query: id,\n                        item: item,\n                        data: {\n                            source: source,\n                            success: success,\n                        },\n                    });\n                });\n\n                item.on('load', function() {\n                    var handleAdd = function handleAdd(shouldAdd) {\n                        // no should not add this file\n                        if (!shouldAdd) {\n                            dispatch('REMOVE_ITEM', {\n                                query: id,\n                            });\n\n                            return;\n                        }\n\n                        // now interested in metadata updates\n                        item.on('metadata-update', function(change) {\n                            dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n                        });\n\n                        // let plugins decide if the output data should be prepared at this point\n                        // means we'll do this and wait for idle state\n                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                            item: item,\n                            query: query,\n                        }).then(function(shouldPrepareOutput) {\n                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                            if (beforePrepareFile)\n                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                            var loadComplete = function loadComplete() {\n                                dispatch('COMPLETE_LOAD_ITEM', {\n                                    query: id,\n                                    item: item,\n                                    data: {\n                                        source: source,\n                                        success: success,\n                                    },\n                                });\n\n                                listUpdated(dispatch, state);\n                            };\n\n                            // exit\n                            if (shouldPrepareOutput) {\n                                // wait for idle state and then run PREPARE_OUTPUT\n                                dispatch(\n                                    'REQUEST_PREPARE_OUTPUT',\n                                    {\n                                        query: id,\n                                        item: item,\n                                        success: function success(file) {\n                                            dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                                            loadComplete();\n                                        },\n                                    },\n\n                                    true\n                                );\n\n                                return;\n                            }\n\n                            loadComplete();\n                        });\n                    };\n\n                    // item loaded, allow plugins to\n                    // - read data (quickly)\n                    // - add metadata\n                    applyFilterChain('DID_LOAD_ITEM', item, { query: query, dispatch: dispatch })\n                        .then(function() {\n                            optionalPromise(query('GET_BEFORE_ADD_FILE'), createItemAPI(item)).then(\n                                handleAdd\n                            );\n                        })\n                        .catch(function(e) {\n                            if (!e || !e.error || !e.status) return handleAdd(false);\n                            dispatch('DID_THROW_ITEM_INVALID', {\n                                id: id,\n                                error: e.error,\n                                status: e.status,\n                            });\n                        });\n                });\n\n                item.on('process-start', function() {\n                    dispatch('DID_START_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-progress', function(progress) {\n                    dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', { id: id, progress: progress });\n                });\n\n                item.on('process-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-revert-error', function(error) {\n                    dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n                        id: id,\n                        error: error,\n                        status: {\n                            main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                });\n\n                item.on('process-complete', function(serverFileReference) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: id,\n                        error: null,\n                        serverFileReference: serverFileReference,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n                });\n\n                item.on('process-abort', function() {\n                    dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n                });\n\n                item.on('process-revert', function() {\n                    dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n                    dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n                });\n\n                // let view know the item has been inserted\n                dispatch('DID_ADD_ITEM', {\n                    id: id,\n                    index: index,\n                    interactionMethod: interactionMethod,\n                });\n\n                listUpdated(dispatch, state);\n\n                // start loading the source\n                var _ref8 = state.options.server || {},\n                    url = _ref8.url,\n                    load = _ref8.load,\n                    restore = _ref8.restore,\n                    fetch = _ref8.fetch;\n\n                item.load(\n                    source,\n\n                    // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n                    createFileLoader(\n                        origin === FileOrigin.INPUT\n                            ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                              isString(source) && isExternalURL(source)\n                                ? fetch\n                                    ? createFetchFunction(url, fetch)\n                                    : fetchBlob // remote url\n                                : fetchBlob // try to fetch url\n                            : // limbo or local\n                            origin === FileOrigin.LIMBO\n                            ? createFetchFunction(url, restore) // limbo\n                            : createFetchFunction(url, load) // local\n                    ),\n\n                    // called when the file is loaded so it can be piped through the filters\n                    function(file, success, error) {\n                        // let's process the file\n                        applyFilterChain('LOAD_FILE', file, { query: query })\n                            .then(success)\n                            .catch(error);\n                    }\n                );\n            },\n\n            REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n                var item = _ref9.item,\n                    success = _ref9.success,\n                    _ref9$failure = _ref9.failure,\n                    failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n                // error response if item archived\n                var err = {\n                    error: createResponse('error', 0, 'Item not found'),\n                    file: null,\n                };\n\n                // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n                if (item.archived) return failure(err);\n\n                // allow plugins to alter the file data\n                applyFilterChain('PREPARE_OUTPUT', item.file, { query: query, item: item }).then(\n                    function(result) {\n                        applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n                            query: query,\n                            item: item,\n                        }).then(function(result) {\n                            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                            if (item.archived) return failure(err);\n\n                            // we done!\n                            success(result);\n                        });\n                    }\n                );\n            },\n\n            COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n                var item = _ref10.item,\n                    data = _ref10.data;\n                var success = data.success,\n                    source = data.source;\n\n                // sort items in list\n                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n                if (isFunction(itemInsertLocation) && source) {\n                    sortItems(state, itemInsertLocation);\n                }\n\n                // let interface know the item has loaded\n                dispatch('DID_LOAD_ITEM', {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: item.origin === FileOrigin.INPUT ? null : source,\n                });\n\n                // item has been successfully loaded and added to the\n                // list of items so can now be safely returned for use\n                success(createItemAPI(item));\n\n                // if this is a local server file we need to show a different state\n                if (item.origin === FileOrigin.LOCAL) {\n                    dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n                    return;\n                }\n\n                // if is a temp server file we prevent async upload call here (as the file is already on the server)\n                if (item.origin === FileOrigin.LIMBO) {\n                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                        id: item.id,\n                        error: null,\n                        serverFileReference: source,\n                    });\n\n                    dispatch('DID_DEFINE_VALUE', {\n                        id: item.id,\n                        value: item.serverId || source,\n                    });\n\n                    return;\n                }\n\n                // id we are allowed to upload the file immediately, lets do it\n                if (query('IS_ASYNC') && state.options.instantUpload) {\n                    dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n                }\n            },\n\n            RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                // try loading the source one more time\n                item.retryLoad();\n            }),\n\n            REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(item, _success, failure) {\n                dispatch(\n                    'REQUEST_PREPARE_OUTPUT',\n                    {\n                        query: item.id,\n                        item: item,\n                        success: function success(file) {\n                            dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n                            _success({\n                                file: item,\n                                output: file,\n                            });\n                        },\n                        failure: failure,\n                    },\n\n                    true\n                );\n            }),\n\n            REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n                item,\n                success,\n                failure\n            ) {\n                // cannot be queued (or is already queued)\n                var itemCanBeQueuedForProcessing =\n                    // waiting for something\n                    item.status === ItemStatus.IDLE ||\n                    // processing went wrong earlier\n                    item.status === ItemStatus.PROCESSING_ERROR;\n\n                // not ready to be processed\n                if (!itemCanBeQueuedForProcessing) {\n                    var processNow = function processNow() {\n                        return dispatch('REQUEST_ITEM_PROCESSING', {\n                            query: item,\n                            success: success,\n                            failure: failure,\n                        });\n                    };\n\n                    var process = function process() {\n                        return document.hidden ? processNow() : setTimeout(processNow, 32);\n                    };\n\n                    // if already done processing or tried to revert but didn't work, try again\n                    if (\n                        item.status === ItemStatus.PROCESSING_COMPLETE ||\n                        item.status === ItemStatus.PROCESSING_REVERT_ERROR\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        )\n                            .then(process)\n                            .catch(function() {}); // don't continue with processing if something went wrong\n                    } else if (item.status === ItemStatus.PROCESSING) {\n                        item.abortProcessing().then(process);\n                    }\n\n                    return;\n                }\n\n                // already queued for processing\n                if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n                item.requestProcessing();\n\n                dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n                dispatch('PROCESS_ITEM', { query: item, success: success, failure: failure }, true);\n            }),\n\n            PROCESS_ITEM: getItemByQueryFromState(state, function(item, success, failure) {\n                var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n                var totalCurrentUploads = query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING)\n                    .length;\n\n                // queue and wait till queue is freed up\n                if (totalCurrentUploads === maxParallelUploads) {\n                    // queue for later processing\n                    state.processingQueue.push({\n                        id: item.id,\n                        success: success,\n                        failure: failure,\n                    });\n\n                    // stop it!\n                    return;\n                }\n\n                // if was not queued or is already processing exit here\n                if (item.status === ItemStatus.PROCESSING) return;\n\n                var processNext = function processNext() {\n                    // process queueud items\n                    var queueEntry = state.processingQueue.shift();\n\n                    // no items left\n                    if (!queueEntry) return;\n\n                    // get item reference\n                    var id = queueEntry.id,\n                        success = queueEntry.success,\n                        failure = queueEntry.failure;\n                    var itemReference = getItemByQuery(state.items, id);\n\n                    // if item was archived while in queue, jump to next\n                    if (!itemReference || itemReference.archived) {\n                        processNext();\n                        return;\n                    }\n\n                    // process queued item\n                    dispatch(\n                        'PROCESS_ITEM',\n                        { query: id, success: success, failure: failure },\n                        true\n                    );\n                };\n\n                // we done function\n                item.onOnce('process-complete', function() {\n                    success(createItemAPI(item));\n                    processNext();\n\n                    // if origin is local, and we're instant uploading, trigger remove of original\n                    // as revert will remove file from list\n                    var server = state.options.server;\n                    var instantUpload = state.options.instantUpload;\n                    if (\n                        instantUpload &&\n                        item.origin === FileOrigin.LOCAL &&\n                        isFunction(server.remove)\n                    ) {\n                        var noop = function noop() {};\n                        item.origin = FileOrigin.LIMBO;\n                        state.options.server.remove(item.source, noop, noop);\n                    }\n\n                    // All items processed? No errors?\n                    var allItemsProcessed =\n                        query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE).length ===\n                        state.items.length;\n                    if (allItemsProcessed) {\n                        dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n                    }\n                });\n\n                // we error function\n                item.onOnce('process-error', function(error) {\n                    failure({ error: error, file: createItemAPI(item) });\n                    processNext();\n                });\n\n                // start file processing\n                var options = state.options;\n                item.process(\n                    createFileProcessor(\n                        createProcessorFunction(\n                            options.server.url,\n                            options.server.process,\n                            options.name,\n                            {\n                                chunkTransferId: item.transferId,\n                                chunkServer: options.server.patch,\n                                chunkUploads: options.chunkUploads,\n                                chunkForce: options.chunkForce,\n                                chunkSize: options.chunkSize,\n                                chunkRetryDelays: options.chunkRetryDelays,\n                            }\n                        ),\n\n                        {\n                            allowMinimumUploadDuration: query('GET_ALLOW_MINIMUM_UPLOAD_DURATION'),\n                        }\n                    ),\n\n                    // called when the file is about to be processed so it can be piped through the transform filters\n                    function(file, success, error) {\n                        // allow plugins to alter the file data\n                        applyFilterChain('PREPARE_OUTPUT', file, { query: query, item: item })\n                            .then(function(file) {\n                                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                                success(file);\n                            })\n                            .catch(error);\n                    }\n                );\n            }),\n\n            RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n            }),\n\n            REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n                optionalPromise(query('GET_BEFORE_REMOVE_FILE'), createItemAPI(item)).then(function(\n                    shouldRemove\n                ) {\n                    if (!shouldRemove) {\n                        return;\n                    }\n                    dispatch('REMOVE_ITEM', { query: item });\n                });\n            }),\n\n            RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n                item.release();\n            }),\n\n            REMOVE_ITEM: getItemByQueryFromState(state, function(item, success, failure, options) {\n                var removeFromView = function removeFromView() {\n                    // get id reference\n                    var id = item.id;\n\n                    // archive the item, this does not remove it from the list\n                    getItemById(state.items, id).archive();\n\n                    // tell the view the item has been removed\n                    dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n                    // now the list has been modified\n                    listUpdated(dispatch, state);\n\n                    // correctly removed\n                    success(createItemAPI(item));\n                };\n\n                // if this is a local file and the `server.remove` function has been configured,\n                // send source there so dev can remove file from server\n                var server = state.options.server;\n                if (\n                    item.origin === FileOrigin.LOCAL &&\n                    server &&\n                    isFunction(server.remove) &&\n                    options.remove !== false\n                ) {\n                    dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n                    server.remove(\n                        item.source,\n                        function() {\n                            return removeFromView();\n                        },\n                        function(status) {\n                            dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                                id: item.id,\n                                error: createResponse('error', 0, status, null),\n                                status: {\n                                    main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                                    sub: state.options.labelTapToRetry,\n                                },\n                            });\n                        }\n                    );\n                } else {\n                    // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n                    if (\n                        (options.revert &&\n                            item.origin !== FileOrigin.LOCAL &&\n                            item.serverId !== null) ||\n                        // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                        // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                        // revert before removing from the view...\n                        (state.options.chunkUploads && item.file.size > state.options.chunkSize) ||\n                        (state.options.chunkUploads && state.options.chunkForce)\n                    ) {\n                        item.revert(\n                            createRevertFunction(\n                                state.options.server.url,\n                                state.options.server.revert\n                            ),\n                            query('GET_FORCE_REVERT')\n                        );\n                    }\n\n                    // can now safely remove from view\n                    removeFromView();\n                }\n            }),\n\n            ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n                item.abortLoad();\n            }),\n\n            ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // test if is already processed\n                if (item.serverId) {\n                    dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n                    return;\n                }\n\n                // abort\n                item.abortProcessing().then(function() {\n                    var shouldRemove = state.options.instantUpload;\n                    if (shouldRemove) {\n                        dispatch('REMOVE_ITEM', { query: item.id });\n                    }\n                });\n            }),\n\n            REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                // not instant uploading, revert immediately\n                if (!state.options.instantUpload) {\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                    return;\n                }\n\n                // if we're instant uploading the file will also be removed if we revert,\n                // so if a before remove file hook is defined we need to run it now\n                var handleRevert = function handleRevert(shouldRevert) {\n                    if (!shouldRevert) return;\n                    dispatch('REVERT_ITEM_PROCESSING', { query: item });\n                };\n\n                var fn = query('GET_BEFORE_REMOVE_FILE');\n                if (!fn) {\n                    return handleRevert(true);\n                }\n\n                var requestRemoveResult = fn(createItemAPI(item));\n                if (requestRemoveResult == null) {\n                    // undefined or null\n                    return handleRevert(true);\n                }\n\n                if (typeof requestRemoveResult === 'boolean') {\n                    return handleRevert(requestRemoveResult);\n                }\n\n                if (typeof requestRemoveResult.then === 'function') {\n                    requestRemoveResult.then(handleRevert);\n                }\n            }),\n\n            REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                )\n                    .then(function() {\n                        var shouldRemove = state.options.instantUpload || isMockItem(item);\n                        if (shouldRemove) {\n                            dispatch('REMOVE_ITEM', { query: item.id });\n                        }\n                    })\n                    .catch(function() {});\n            }),\n\n            SET_OPTIONS: function SET_OPTIONS(_ref11) {\n                var options = _ref11.options;\n                // get all keys passed\n                var optionKeys = Object.keys(options);\n\n                // get prioritized keyed to include (remove once not in options object)\n                var prioritizedOptionKeys = PrioritizedOptions.filter(function(key) {\n                    return optionKeys.includes(key);\n                });\n\n                // order the keys, prioritized first, then rest\n                var orderedOptionKeys = [].concat(\n                    _toConsumableArray(prioritizedOptionKeys),\n                    _toConsumableArray(\n                        Object.keys(options).filter(function(key) {\n                            return !prioritizedOptionKeys.includes(key);\n                        })\n                    )\n                );\n\n                // dispatch set event for each option\n                orderedOptionKeys.forEach(function(key) {\n                    dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n                        value: options[key],\n                    });\n                });\n            },\n        };\n    };\n\n    var PrioritizedOptions = ['server'];\n\n    var formatFilename = function formatFilename(name) {\n        return name;\n    };\n\n    var createElement$1 = function createElement(tagName) {\n        return document.createElement(tagName);\n    };\n\n    var text = function text(node, value) {\n        var textNode = node.childNodes[0];\n        if (!textNode) {\n            textNode = document.createTextNode(value);\n            node.appendChild(textNode);\n        } else if (value !== textNode.nodeValue) {\n            textNode.nodeValue = value;\n        }\n    };\n\n    var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n        return {\n            x: centerX + radius * Math.cos(angleInRadians),\n            y: centerY + radius * Math.sin(angleInRadians),\n        };\n    };\n\n    var describeArc = function describeArc(x, y, radius, startAngle, endAngle, arcSweep) {\n        var start = polarToCartesian(x, y, radius, endAngle);\n        var end = polarToCartesian(x, y, radius, startAngle);\n        return ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');\n    };\n\n    var percentageArc = function percentageArc(x, y, radius, from, to) {\n        var arcSweep = 1;\n        if (to > from && to - from <= 0.5) {\n            arcSweep = 0;\n        }\n        if (from > to && from - to >= 0.5) {\n            arcSweep = 0;\n        }\n        return describeArc(\n            x,\n            y,\n            radius,\n            Math.min(0.9999, from) * 360,\n            Math.min(0.9999, to) * 360,\n            arcSweep\n        );\n    };\n\n    var create = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // start at 0\n        props.spin = false;\n        props.progress = 0;\n        props.opacity = 0;\n\n        // svg\n        var svg = createElement('svg');\n        root.ref.path = createElement('path', {\n            'stroke-width': 2,\n            'stroke-linecap': 'round',\n        });\n\n        svg.appendChild(root.ref.path);\n\n        root.ref.svg = svg;\n\n        root.appendChild(svg);\n    };\n\n    var write = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        if (props.opacity === 0) {\n            return;\n        }\n\n        if (props.align) {\n            root.element.dataset.align = props.align;\n        }\n\n        // get width of stroke\n        var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n        // calculate size of ring\n        var size = root.rect.element.width * 0.5;\n\n        // ring state\n        var ringFrom = 0;\n        var ringTo = 0;\n\n        // now in busy mode\n        if (props.spin) {\n            ringFrom = 0;\n            ringTo = 0.5;\n        } else {\n            ringFrom = 0;\n            ringTo = props.progress;\n        }\n\n        // get arc path\n        var coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n\n        // update progress bar\n        attr(root.ref.path, 'd', coordinates);\n\n        // hide while contains 0 value\n        attr(root.ref.path, 'stroke-opacity', props.spin || props.progress > 0 ? 1 : 0);\n    };\n\n    var progressIndicator = createView({\n        tag: 'div',\n        name: 'progress-indicator',\n        ignoreRectUpdate: true,\n        ignoreRect: true,\n        create: create,\n        write: write,\n        mixins: {\n            apis: ['progress', 'spin', 'align'],\n            styles: ['opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 500 },\n                progress: {\n                    type: 'spring',\n                    stiffness: 0.95,\n                    damping: 0.65,\n                    mass: 10,\n                },\n            },\n        },\n    });\n\n    var create$1 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.innerHTML = (props.icon || '') + ('<span>' + props.label + '</span>');\n\n        props.isDisabled = false;\n    };\n\n    var write$1 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        var isDisabled = props.isDisabled;\n        var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n        if (shouldDisable && !isDisabled) {\n            props.isDisabled = true;\n            attr(root.element, 'disabled', 'disabled');\n        } else if (!shouldDisable && isDisabled) {\n            props.isDisabled = false;\n            root.element.removeAttribute('disabled');\n        }\n    };\n\n    var fileActionButton = createView({\n        tag: 'button',\n        attributes: {\n            type: 'button',\n        },\n\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'file-action-button',\n        mixins: {\n            apis: ['label'],\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n\n            listeners: true,\n        },\n\n        create: create$1,\n        write: write$1,\n    });\n\n    var toNaturalFileSize = function toNaturalFileSize(bytes) {\n        var decimalSeparator =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var _options$labelBytes = options.labelBytes,\n            labelBytes = _options$labelBytes === void 0 ? 'bytes' : _options$labelBytes,\n            _options$labelKilobyt = options.labelKilobytes,\n            labelKilobytes = _options$labelKilobyt === void 0 ? 'KB' : _options$labelKilobyt,\n            _options$labelMegabyt = options.labelMegabytes,\n            labelMegabytes = _options$labelMegabyt === void 0 ? 'MB' : _options$labelMegabyt,\n            _options$labelGigabyt = options.labelGigabytes,\n            labelGigabytes = _options$labelGigabyt === void 0 ? 'GB' : _options$labelGigabyt;\n\n        // no negative byte sizes\n        bytes = Math.round(Math.abs(bytes));\n\n        var KB = base;\n        var MB = base * base;\n        var GB = base * base * base;\n\n        // just bytes\n        if (bytes < KB) {\n            return bytes + ' ' + labelBytes;\n        }\n\n        // kilobytes\n        if (bytes < MB) {\n            return Math.floor(bytes / KB) + ' ' + labelKilobytes;\n        }\n\n        // megabytes\n        if (bytes < GB) {\n            return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' ' + labelMegabytes;\n        }\n\n        // gigabytes\n        return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' ' + labelGigabytes;\n    };\n\n    var removeDecimalsWhenZero = function removeDecimalsWhenZero(value, decimalCount, separator) {\n        return value\n            .toFixed(decimalCount)\n            .split('.')\n            .filter(function(part) {\n                return part !== '0';\n            })\n            .join(separator);\n    };\n\n    var create$2 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // filename\n        var fileName = createElement$1('span');\n        fileName.className = 'filepond--file-info-main';\n        // hide for screenreaders\n        // the file is contained in a fieldset with legend that contains the filename\n        // no need to read it twice\n        attr(fileName, 'aria-hidden', 'true');\n        root.appendChild(fileName);\n        root.ref.fileName = fileName;\n\n        // filesize\n        var fileSize = createElement$1('span');\n        fileSize.className = 'filepond--file-info-sub';\n        root.appendChild(fileSize);\n        root.ref.fileSize = fileSize;\n\n        // set initial values\n        text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n        text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFile = function updateFile(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        text(\n            root.ref.fileSize,\n            toNaturalFileSize(\n                root.query('GET_ITEM_SIZE', props.id),\n                '.',\n                root.query('GET_FILE_SIZE_BASE'),\n                root.query('GET_FILE_SIZE_LABELS', root.query)\n            )\n        );\n\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props;\n        // if size is available don't fallback to unknown size message\n        if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n            updateFile({ root: root, props: props });\n            return;\n        }\n\n        text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n    };\n\n    var fileInfo = createView({\n        name: 'file-info',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: updateFile,\n            DID_UPDATE_ITEM_META: updateFile,\n            DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n            DID_THROW_ITEM_INVALID: updateFileSizeOnError,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$2,\n        mixins: {\n            styles: ['translateX', 'translateY'],\n            animations: {\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var toPercentage = function toPercentage(value) {\n        return Math.round(value * 100);\n    };\n\n    var create$3 = function create(_ref) {\n        var root = _ref.root;\n\n        // main status\n        var main = createElement$1('span');\n        main.className = 'filepond--file-status-main';\n        root.appendChild(main);\n        root.ref.main = main;\n\n        // sub status\n        var sub = createElement$1('span');\n        sub.className = 'filepond--file-status-sub';\n        root.appendChild(sub);\n        root.ref.sub = sub;\n\n        didSetItemLoadProgress({ root: root, action: { progress: null } });\n    };\n\n    var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_LOADING')\n                : root.query('GET_LABEL_FILE_LOADING') + ' ' + toPercentage(action.progress) + '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var title =\n            action.progress === null\n                ? root.query('GET_LABEL_FILE_PROCESSING')\n                : root.query('GET_LABEL_FILE_PROCESSING') +\n                  ' ' +\n                  toPercentage(action.progress) +\n                  '%';\n\n        text(root.ref.main, title);\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n        var root = _ref4.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n    };\n\n    var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n        var root = _ref5.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n    };\n\n    var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n        var root = _ref6.root;\n        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n    };\n\n    var clear = function clear(_ref7) {\n        var root = _ref7.root;\n        text(root.ref.main, '');\n        text(root.ref.sub, '');\n    };\n\n    var error = function error(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        text(root.ref.main, action.status.main);\n        text(root.ref.sub, action.status.sub);\n    };\n\n    var fileStatus = createView({\n        name: 'file-status',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: clear,\n            DID_REVERT_ITEM_PROCESSING: clear,\n            DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n            DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n            DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n            DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n            DID_THROW_ITEM_LOAD_ERROR: error,\n            DID_THROW_ITEM_INVALID: error,\n            DID_THROW_ITEM_PROCESSING_ERROR: error,\n            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n            DID_THROW_ITEM_REMOVE_ERROR: error,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        create: create$3,\n        mixins: {\n            styles: ['translateX', 'translateY', 'opacity'],\n            animations: {\n                opacity: { type: 'tween', duration: 250 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    /**\n     * Button definitions for the file view\n     */\n\n    var Buttons = {\n        AbortItemLoad: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n            action: 'ABORT_ITEM_LOAD',\n            className: 'filepond--action-abort-item-load',\n            align: 'LOAD_INDICATOR_POSITION', // right\n        },\n        RetryItemLoad: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n            action: 'RETRY_ITEM_LOAD',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-load',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RemoveItem: {\n            label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n            action: 'REQUEST_REMOVE_ITEM',\n            icon: 'GET_ICON_REMOVE',\n            className: 'filepond--action-remove-item',\n            align: 'BUTTON_REMOVE_ITEM_POSITION', // left\n        },\n        ProcessItem: {\n            label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n            action: 'REQUEST_ITEM_PROCESSING',\n            icon: 'GET_ICON_PROCESS',\n            className: 'filepond--action-process-item',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        AbortItemProcessing: {\n            label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n            action: 'ABORT_ITEM_PROCESSING',\n            className: 'filepond--action-abort-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RetryItemProcessing: {\n            label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n            action: 'RETRY_ITEM_PROCESSING',\n            icon: 'GET_ICON_RETRY',\n            className: 'filepond--action-retry-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n        RevertItemProcessing: {\n            label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n            action: 'REQUEST_REVERT_ITEM_PROCESSING',\n            icon: 'GET_ICON_UNDO',\n            className: 'filepond--action-revert-item-processing',\n            align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n        },\n    };\n\n    // make a list of buttons, we can then remove buttons from this list if they're disabled\n    var ButtonKeys = [];\n    forin(Buttons, function(key) {\n        ButtonKeys.push(key);\n    });\n\n    var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n        if (getRemoveIndicatorAligment(root) === 'right') return 0;\n        var buttonRect = root.ref.buttonRemoveItem.rect.element;\n        return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n    };\n\n    var calculateButtonWidth = function calculateButtonWidth(root) {\n        var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n        return buttonRect.width;\n    };\n\n    // Force on full pixels so text stays crips\n    var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n    };\n    var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(root) {\n        return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n    };\n\n    var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n        return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n    };\n    var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(root) {\n        return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n    };\n    var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n        return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n    };\n\n    var DefaultStyle = {\n        buttonAbortItemLoad: { opacity: 0 },\n        buttonRetryItemLoad: { opacity: 0 },\n        buttonRemoveItem: { opacity: 0 },\n        buttonProcessItem: { opacity: 0 },\n        buttonAbortItemProcessing: { opacity: 0 },\n        buttonRetryItemProcessing: { opacity: 0 },\n        buttonRevertItemProcessing: { opacity: 0 },\n        loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n        processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },\n        processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n        info: { translateX: 0, translateY: 0, opacity: 0 },\n        status: { translateX: 0, translateY: 0, opacity: 0 },\n    };\n\n    var IdleStyle = {\n        buttonRemoveItem: { opacity: 1 },\n        buttonProcessItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { translateX: calculateFileInfoOffset },\n    };\n\n    var ProcessingStyle = {\n        buttonAbortItemProcessing: { opacity: 1 },\n        processProgressIndicator: { opacity: 1 },\n        status: { opacity: 1 },\n    };\n\n    var StyleMap = {\n        DID_THROW_ITEM_INVALID: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset, opacity: 1 },\n        },\n\n        DID_START_ITEM_LOAD: {\n            buttonAbortItemLoad: { opacity: 1 },\n            loadProgressIndicator: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_LOAD_ERROR: {\n            buttonRetryItemLoad: { opacity: 1 },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_START_ITEM_REMOVE: {\n            processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 0 },\n        },\n\n        DID_THROW_ITEM_REMOVE_ERROR: {\n            processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1, translateX: calculateFileInfoOffset },\n        },\n\n        DID_LOAD_ITEM: IdleStyle,\n        DID_LOAD_LOCAL_ITEM: {\n            buttonRemoveItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_START_ITEM_PROCESSING: ProcessingStyle,\n        DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n        DID_COMPLETE_ITEM_PROCESSING: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            info: { opacity: 1 },\n            status: { opacity: 1 },\n        },\n\n        DID_THROW_ITEM_PROCESSING_ERROR: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonRetryItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n        },\n\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n            buttonRevertItemProcessing: { opacity: 1 },\n            status: { opacity: 1 },\n            info: { opacity: 1 },\n        },\n\n        DID_ABORT_ITEM_PROCESSING: {\n            buttonRemoveItem: { opacity: 1 },\n            buttonProcessItem: { opacity: 1 },\n            info: { translateX: calculateFileInfoOffset },\n            status: { opacity: 1 },\n        },\n\n        DID_REVERT_ITEM_PROCESSING: IdleStyle,\n    };\n\n    // complete indicator view\n    var processingCompleteIndicatorView = createView({\n        create: function create(_ref) {\n            var root = _ref.root;\n            root.element.innerHTML = root.query('GET_ICON_DONE');\n        },\n        name: 'processing-complete-indicator',\n        ignoreRect: true,\n        mixins: {\n            styles: ['scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$4 = function create(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // copy Buttons object\n        var LocalButtons = Object.keys(Buttons).reduce(function(prev, curr) {\n            prev[curr] = Object.assign({}, Buttons[curr]);\n            return prev;\n        }, {});\n        var id = props.id;\n\n        // allow reverting upload\n        var allowRevert = root.query('GET_ALLOW_REVERT');\n\n        // allow remove file\n        var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n        // allow processing upload\n        var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n        // is instant uploading, need this to determine the icon of the undo button\n        var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n        // is async set up\n        var isAsync = root.query('IS_ASYNC');\n\n        // should align remove item buttons\n        var alignRemoveItemButton = root.query('GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN');\n\n        // enabled buttons array\n        var buttonFilter;\n        if (isAsync) {\n            if (allowProcess && !allowRevert) {\n                // only remove revert button\n                buttonFilter = function buttonFilter(key) {\n                    return !/RevertItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && allowRevert) {\n                // only remove process button\n                buttonFilter = function buttonFilter(key) {\n                    return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n                };\n            } else if (!allowProcess && !allowRevert) {\n                // remove all process buttons\n                buttonFilter = function buttonFilter(key) {\n                    return !/Process/.test(key);\n                };\n            }\n        } else {\n            // no process controls available\n            buttonFilter = function buttonFilter(key) {\n                return !/Process/.test(key);\n            };\n        }\n\n        var enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n\n        // update icon and label for revert button when instant uploading\n        if (instantUpload && allowRevert) {\n            LocalButtons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n            LocalButtons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n        }\n\n        // remove last button (revert) if not allowed\n        if (isAsync && !allowRevert) {\n            var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            map.info.translateX = calculateFileHorizontalCenterOffset;\n            map.info.translateY = calculateFileVerticalCenterOffset;\n            map.status.translateY = calculateFileVerticalCenterOffset;\n            map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // should align center\n        if (isAsync && !allowProcess) {\n            [\n                'DID_START_ITEM_PROCESSING',\n                'DID_REQUEST_ITEM_PROCESSING',\n                'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n                'DID_THROW_ITEM_PROCESSING_ERROR',\n            ].forEach(function(key) {\n                StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n            });\n            StyleMap['DID_THROW_ITEM_PROCESSING_ERROR'].status.translateX = calculateButtonWidth;\n        }\n\n        // move remove button to right\n        if (alignRemoveItemButton && allowRevert) {\n            LocalButtons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n            var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n            _map.info.translateX = calculateFileInfoOffset;\n            _map.status.translateY = calculateFileVerticalCenterOffset;\n            _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n        }\n\n        // show/hide RemoveItem button\n        if (!allowRemove) {\n            LocalButtons['RemoveItem'].disabled = true;\n        }\n\n        // create the button views\n        forin(LocalButtons, function(key, definition) {\n            // create button\n            var buttonView = root.createChildView(fileActionButton, {\n                label: root.query(definition.label),\n                icon: root.query(definition.icon),\n                opacity: 0,\n            });\n\n            // should be appended?\n            if (enabledButtons.includes(key)) {\n                root.appendChildView(buttonView);\n            }\n\n            // toggle\n            if (definition.disabled) {\n                buttonView.element.setAttribute('disabled', 'disabled');\n                buttonView.element.setAttribute('hidden', 'hidden');\n            }\n\n            // add position attribute\n            buttonView.element.dataset.align = root.query('GET_STYLE_' + definition.align);\n\n            // add class\n            buttonView.element.classList.add(definition.className);\n\n            // handle interactions\n            buttonView.on('click', function(e) {\n                e.stopPropagation();\n                if (definition.disabled) return;\n                root.dispatch(definition.action, { query: id });\n            });\n\n            // set reference\n            root.ref['button' + key] = buttonView;\n        });\n\n        // checkmark\n        root.ref.processingCompleteIndicator = root.appendChildView(\n            root.createChildView(processingCompleteIndicatorView)\n        );\n\n        root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n            'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n        );\n\n        // create file info view\n        root.ref.info = root.appendChildView(root.createChildView(fileInfo, { id: id }));\n\n        // create file status view\n        root.ref.status = root.appendChildView(root.createChildView(fileStatus, { id: id }));\n\n        // add progress indicators\n        var loadIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION'),\n            })\n        );\n\n        loadIndicatorView.element.classList.add('filepond--load-indicator');\n        root.ref.loadProgressIndicator = loadIndicatorView;\n\n        var progressIndicatorView = root.appendChildView(\n            root.createChildView(progressIndicator, {\n                opacity: 0,\n                align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION'),\n            })\n        );\n\n        progressIndicatorView.element.classList.add('filepond--process-indicator');\n        root.ref.processProgressIndicator = progressIndicatorView;\n\n        // current active styles\n        root.ref.activeStyles = [];\n    };\n\n    var write$2 = function write(_ref3) {\n        var root = _ref3.root,\n            actions = _ref3.actions,\n            props = _ref3.props;\n        // route actions\n        route({ root: root, actions: actions, props: props });\n\n        // select last state change action\n        var action = actions\n            .concat()\n            .filter(function(action) {\n                return /^DID_/.test(action.type);\n            })\n            .reverse()\n            .find(function(action) {\n                return StyleMap[action.type];\n            });\n\n        // a new action happened, let's get the matching styles\n        if (action) {\n            // define new active styles\n            root.ref.activeStyles = [];\n\n            var stylesToApply = StyleMap[action.type];\n            forin(DefaultStyle, function(name, defaultStyles) {\n                // get reference to control\n                var control = root.ref[name];\n\n                // loop over all styles for this control\n                forin(defaultStyles, function(key, defaultValue) {\n                    var value =\n                        stylesToApply[name] && typeof stylesToApply[name][key] !== 'undefined'\n                            ? stylesToApply[name][key]\n                            : defaultValue;\n                    root.ref.activeStyles.push({ control: control, key: key, value: value });\n                });\n            });\n        }\n\n        // apply active styles to element\n        root.ref.activeStyles.forEach(function(_ref4) {\n            var control = _ref4.control,\n                key = _ref4.key,\n                value = _ref4.value;\n            control[key] = typeof value === 'function' ? value(root) : value;\n        });\n    };\n\n    var route = createRoute({\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n            _ref5\n        ) {\n            var root = _ref5.root,\n                action = _ref5.action;\n            root.ref.buttonAbortItemProcessing.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(_ref6) {\n            var root = _ref6.root,\n                action = _ref6.action;\n            root.ref.buttonAbortItemLoad.label = action.value;\n        },\n        DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n            _ref7\n        ) {\n            var root = _ref7.root,\n                action = _ref7.action;\n            root.ref.buttonAbortItemRemoval.label = action.value;\n        },\n        DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n            var root = _ref8.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n            var root = _ref9.root;\n            root.ref.loadProgressIndicator.spin = true;\n            root.ref.loadProgressIndicator.progress = 0;\n        },\n        DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n            var root = _ref10.root;\n            root.ref.processProgressIndicator.spin = true;\n            root.ref.processProgressIndicator.progress = 0;\n        },\n        DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(_ref11) {\n            var root = _ref11.root,\n                action = _ref11.action;\n            root.ref.loadProgressIndicator.spin = false;\n            root.ref.loadProgressIndicator.progress = action.progress;\n        },\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(_ref12) {\n            var root = _ref12.root,\n                action = _ref12.action;\n            root.ref.processProgressIndicator.spin = false;\n            root.ref.processProgressIndicator.progress = action.progress;\n        },\n    });\n\n    var file = createView({\n        create: create$4,\n        write: write$2,\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        name: 'file',\n    });\n\n    /**\n     * Creates the file view\n     */\n    var create$5 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // filename\n        root.ref.fileName = createElement$1('legend');\n        root.appendChild(root.ref.fileName);\n\n        // file appended\n        root.ref.file = root.appendChildView(root.createChildView(file, { id: props.id }));\n\n        // data has moved to data.js\n        root.ref.data = false;\n    };\n\n    /**\n     * Data storage\n     */\n    var didLoadItem = function didLoadItem(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n        // updates the legend of the fieldset so screenreaders can better group buttons\n        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n    };\n\n    var fileWrapper = createView({\n        create: create$5,\n        ignoreRect: true,\n        write: createRoute({\n            DID_LOAD_ITEM: didLoadItem,\n        }),\n\n        didCreateView: function didCreateView(root) {\n            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n        },\n        tag: 'fieldset',\n        name: 'file-wrapper',\n    });\n\n    var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n    var create$6 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        [\n            {\n                name: 'top',\n            },\n\n            {\n                name: 'center',\n                props: {\n                    translateY: null,\n                    scaleY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        scaleY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY', 'scaleY'],\n                },\n            },\n\n            {\n                name: 'bottom',\n                props: {\n                    translateY: null,\n                },\n\n                mixins: {\n                    animations: {\n                        translateY: PANEL_SPRING_PROPS,\n                    },\n\n                    styles: ['translateY'],\n                },\n            },\n        ].forEach(function(section) {\n            createSection(root, section, props.name);\n        });\n\n        root.element.classList.add('filepond--' + props.name);\n\n        root.ref.scalable = null;\n    };\n\n    var createSection = function createSection(root, section, className) {\n        var viewConstructor = createView({\n            name: 'panel-' + section.name + ' filepond--' + className,\n            mixins: section.mixins,\n            ignoreRectUpdate: true,\n        });\n\n        var view = root.createChildView(viewConstructor, section.props);\n\n        root.ref[section.name] = root.appendChildView(view);\n    };\n\n    var write$3 = function write(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props;\n\n        // update scalable state\n        if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n            root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n            root.element.dataset.scalable = root.ref.scalable;\n        }\n\n        // no height, can't set\n        if (!props.height) return;\n\n        // get child rects\n        var topRect = root.ref.top.rect.element;\n        var bottomRect = root.ref.bottom.rect.element;\n\n        // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n        var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n        // offset center part\n        root.ref.center.translateY = topRect.height;\n\n        // scale center part\n        // use math ceil to prevent transparent lines because of rounding errors\n        root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n\n        // offset bottom part\n        root.ref.bottom.translateY = height - bottomRect.height;\n    };\n\n    var panel = createView({\n        name: 'panel',\n        read: function read(_ref3) {\n            var root = _ref3.root,\n                props = _ref3.props;\n            return (props.heightCurrent = root.ref.bottom.translateY);\n        },\n        write: write$3,\n        create: create$6,\n        ignoreRect: true,\n        mixins: {\n            apis: ['height', 'heightCurrent', 'scalable'],\n        },\n    });\n\n    var createDragHelper = function createDragHelper(items) {\n        var itemIds = items.map(function(item) {\n            return item.id;\n        });\n        var prevIndex = undefined;\n        return {\n            setIndex: function setIndex(index) {\n                prevIndex = index;\n            },\n            getIndex: function getIndex() {\n                return prevIndex;\n            },\n            getItemIndex: function getItemIndex(item) {\n                return itemIds.indexOf(item.id);\n            },\n        };\n    };\n\n    var ITEM_TRANSLATE_SPRING = {\n        type: 'spring',\n        stiffness: 0.75,\n        damping: 0.45,\n        mass: 10,\n    };\n\n    var ITEM_SCALE_SPRING = 'spring';\n\n    var StateMap = {\n        DID_START_ITEM_LOAD: 'busy',\n        DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n        DID_THROW_ITEM_INVALID: 'load-invalid',\n        DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n        DID_LOAD_ITEM: 'idle',\n        DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n        DID_START_ITEM_REMOVE: 'busy',\n        DID_START_ITEM_PROCESSING: 'busy processing',\n        DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n        DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n        DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n        DID_ABORT_ITEM_PROCESSING: 'cancelled',\n        DID_REVERT_ITEM_PROCESSING: 'idle',\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$7 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // select\n        root.ref.handleClick = function(e) {\n            return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n        };\n\n        // set id\n        root.element.id = 'filepond--item-' + props.id;\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // file view\n        root.ref.container = root.appendChildView(\n            root.createChildView(fileWrapper, { id: props.id })\n        );\n\n        // file panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'item-panel' }));\n\n        // default start height\n        root.ref.panel.height = null;\n\n        // by default not marked for removal\n        props.markedForRemoval = false;\n\n        // if not allowed to reorder file items, exit here\n        if (!root.query('GET_ALLOW_REORDER')) return;\n\n        // set to idle so shows grab cursor\n        root.element.dataset.dragState = 'idle';\n\n        var grab = function grab(e) {\n            if (!e.isPrimary) return;\n\n            var removedActivateListener = false;\n\n            var origin = {\n                x: e.pageX,\n                y: e.pageY,\n            };\n\n            props.dragOrigin = {\n                x: root.translateX,\n                y: root.translateY,\n            };\n\n            props.dragCenter = {\n                x: e.offsetX,\n                y: e.offsetY,\n            };\n\n            var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n            root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n            var drag = function drag(e) {\n                if (!e.isPrimary) return;\n\n                e.stopPropagation();\n                e.preventDefault();\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                // if dragged stop listening to clicks, will re-add when done dragging\n                var dist =\n                    props.dragOffset.x * props.dragOffset.x +\n                    props.dragOffset.y * props.dragOffset.y;\n                if (dist > 16 && !removedActivateListener) {\n                    removedActivateListener = true;\n                    root.element.removeEventListener('click', root.ref.handleClick);\n                }\n\n                root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n            };\n\n            var drop = function drop(e) {\n                if (!e.isPrimary) return;\n\n                props.dragOffset = {\n                    x: e.pageX - origin.x,\n                    y: e.pageY - origin.y,\n                };\n\n                reset();\n            };\n\n            var cancel = function cancel() {\n                reset();\n            };\n\n            var reset = function reset() {\n                document.removeEventListener('pointercancel', cancel);\n                document.removeEventListener('pointermove', drag);\n                document.removeEventListener('pointerup', drop);\n\n                root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n                // start listening to clicks again\n                if (removedActivateListener) {\n                    setTimeout(function() {\n                        return root.element.addEventListener('click', root.ref.handleClick);\n                    }, 0);\n                }\n            };\n\n            document.addEventListener('pointercancel', cancel);\n            document.addEventListener('pointermove', drag);\n            document.addEventListener('pointerup', drop);\n        };\n\n        root.element.addEventListener('pointerdown', grab);\n    };\n\n    var route$1 = createRoute({\n        DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n            var root = _ref2.root,\n                action = _ref2.action;\n            root.height = action.height;\n        },\n    });\n\n    var write$4 = createRoute(\n        {\n            DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n                var root = _ref3.root,\n                    props = _ref3.props;\n                props.dragOrigin = {\n                    x: root.translateX,\n                    y: root.translateY,\n                };\n            },\n            DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n                var root = _ref4.root;\n                root.element.dataset.dragState = 'drag';\n            },\n            DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n                var root = _ref5.root,\n                    props = _ref5.props;\n                props.dragOffset = null;\n                props.dragOrigin = null;\n                root.element.dataset.dragState = 'drop';\n            },\n        },\n\n        function(_ref6) {\n            var root = _ref6.root,\n                actions = _ref6.actions,\n                props = _ref6.props,\n                shouldOptimize = _ref6.shouldOptimize;\n            if (root.element.dataset.dragState === 'drop') {\n                if (root.scaleX <= 1) {\n                    root.element.dataset.dragState = 'idle';\n                }\n            }\n\n            // select last state change action\n            var action = actions\n                .concat()\n                .filter(function(action) {\n                    return /^DID_/.test(action.type);\n                })\n                .reverse()\n                .find(function(action) {\n                    return StateMap[action.type];\n                });\n\n            // no need to set same state twice\n            if (action && action.type !== props.currentState) {\n                // set current state\n                props.currentState = action.type;\n\n                // set state\n                root.element.dataset.filepondItemState = StateMap[props.currentState] || '';\n            }\n\n            // route actions\n            var aspectRatio =\n                root.query('GET_ITEM_PANEL_ASPECT_RATIO') || root.query('GET_PANEL_ASPECT_RATIO');\n            if (!aspectRatio) {\n                route$1({ root: root, actions: actions, props: props });\n                if (!root.height && root.ref.container.rect.element.height > 0) {\n                    root.height = root.ref.container.rect.element.height;\n                }\n            } else if (!shouldOptimize) {\n                root.height = root.rect.element.width * aspectRatio;\n            }\n\n            // sync panel height with item height\n            if (shouldOptimize) {\n                root.ref.panel.height = null;\n            }\n\n            root.ref.panel.height = root.height;\n        }\n    );\n\n    var item = createView({\n        create: create$7,\n        write: write$4,\n        destroy: function destroy(_ref7) {\n            var root = _ref7.root,\n                props = _ref7.props;\n            root.element.removeEventListener('click', root.ref.handleClick);\n            root.dispatch('RELEASE_ITEM', { query: props.id });\n        },\n        tag: 'li',\n        name: 'item',\n        mixins: {\n            apis: [\n                'id',\n                'interactionMethod',\n                'markedForRemoval',\n                'spawnDate',\n                'dragCenter',\n                'dragOrigin',\n                'dragOffset',\n            ],\n\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity', 'height'],\n            animations: {\n                scaleX: ITEM_SCALE_SPRING,\n                scaleY: ITEM_SCALE_SPRING,\n                translateX: ITEM_TRANSLATE_SPRING,\n                translateY: ITEM_TRANSLATE_SPRING,\n                opacity: { type: 'tween', duration: 150 },\n            },\n        },\n    });\n\n    var getItemsPerRow = function(horizontalSpace, itemWidth) {\n        // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n\n        return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n    };\n\n    var getItemIndexByPosition = function getItemIndexByPosition(view, children, positionInView) {\n        if (!positionInView) return;\n\n        var horizontalSpace = view.rect.element.width;\n        // const children = view.childViews;\n        var l = children.length;\n        var last = null;\n\n        // -1, don't move items to accomodate (either add to top or bottom)\n        if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n        // let's get the item width\n        var item = children[0];\n        var itemRect = item.rect.element;\n        var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n        var itemWidth = itemRect.width + itemHorizontalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            for (var index = 0; index < l; index++) {\n                var child = children[index];\n                var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n                if (positionInView.top < childMid) {\n                    return index;\n                }\n            }\n            return l;\n        }\n\n        // grid\n        var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n        var itemHeight = itemRect.height + itemVerticalMargin;\n        for (var _index = 0; _index < l; _index++) {\n            var indexX = _index % itemsPerRow;\n            var indexY = Math.floor(_index / itemsPerRow);\n\n            var offsetX = indexX * itemWidth;\n            var offsetY = indexY * itemHeight;\n\n            var itemTop = offsetY - itemRect.marginTop;\n            var itemRight = offsetX + itemWidth;\n            var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n            if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n                if (positionInView.left < itemRight) {\n                    return _index;\n                } else if (_index !== l - 1) {\n                    last = _index;\n                } else {\n                    last = null;\n                }\n            }\n        }\n\n        if (last !== null) {\n            return last;\n        }\n\n        return l;\n    };\n\n    var dropAreaDimensions = {\n        height: 0,\n        width: 0,\n        get getHeight() {\n            return this.height;\n        },\n        set setHeight(val) {\n            if (this.height === 0 || val === 0) this.height = val;\n        },\n        get getWidth() {\n            return this.width;\n        },\n        set setWidth(val) {\n            if (this.width === 0 || val === 0) this.width = val;\n        },\n        setDimensions: function setDimensions(height, width) {\n            if (this.height === 0 || height === 0) this.height = height;\n            if (this.width === 0 || width === 0) this.width = width;\n        },\n    };\n\n    var create$8 = function create(_ref) {\n        var root = _ref.root;\n        // need to set role to list as otherwise it won't be read as a list by VoiceOver\n        attr(root.element, 'role', 'list');\n\n        root.ref.lastItemSpanwDate = Date.now();\n    };\n\n    /**\n     * Inserts a new item\n     * @param root\n     * @param action\n     */\n    var addItemView = function addItemView(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        var id = action.id,\n            index = action.index,\n            interactionMethod = action.interactionMethod;\n\n        root.ref.addIndex = index;\n\n        var now = Date.now();\n        var spawnDate = now;\n        var opacity = 1;\n\n        if (interactionMethod !== InteractionMethod.NONE) {\n            opacity = 0;\n            var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n            var dist = now - root.ref.lastItemSpanwDate;\n            spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n        }\n\n        root.ref.lastItemSpanwDate = spawnDate;\n\n        root.appendChildView(\n            root.createChildView(\n                // view type\n                item,\n\n                // props\n                {\n                    spawnDate: spawnDate,\n                    id: id,\n                    opacity: opacity,\n                    interactionMethod: interactionMethod,\n                }\n            ),\n\n            index\n        );\n    };\n\n    var moveItem = function moveItem(item, x, y) {\n        var vx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var vy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n        // set to null to remove animation while dragging\n        if (item.dragOffset) {\n            item.translateX = null;\n            item.translateY = null;\n            item.translateX = item.dragOrigin.x + item.dragOffset.x;\n            item.translateY = item.dragOrigin.y + item.dragOffset.y;\n            item.scaleX = 1.025;\n            item.scaleY = 1.025;\n        } else {\n            item.translateX = x;\n            item.translateY = y;\n\n            if (Date.now() > item.spawnDate) {\n                // reveal element\n                if (item.opacity === 0) {\n                    introItemView(item, x, y, vx, vy);\n                }\n\n                // make sure is default scale every frame\n                item.scaleX = 1;\n                item.scaleY = 1;\n                item.opacity = 1;\n            }\n        }\n    };\n\n    var introItemView = function introItemView(item, x, y, vx, vy) {\n        if (item.interactionMethod === InteractionMethod.NONE) {\n            item.translateX = null;\n            item.translateX = x;\n            item.translateY = null;\n            item.translateY = y;\n        } else if (item.interactionMethod === InteractionMethod.DROP) {\n            item.translateX = null;\n            item.translateX = x - vx * 20;\n\n            item.translateY = null;\n            item.translateY = y - vy * 10;\n\n            item.scaleX = 0.8;\n            item.scaleY = 0.8;\n        } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n            item.translateY = null;\n            item.translateY = y - 30;\n        } else if (item.interactionMethod === InteractionMethod.API) {\n            item.translateX = null;\n            item.translateX = x - 30;\n            item.translateY = null;\n        }\n    };\n\n    /**\n     * Removes an existing item\n     * @param root\n     * @param action\n     */\n    var removeItemView = function removeItemView(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var id = action.id;\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        // if no view found, exit\n        if (!view) {\n            return;\n        }\n\n        // animate view out of view\n        view.scaleX = 0.9;\n        view.scaleY = 0.9;\n        view.opacity = 0;\n\n        // mark for removal\n        view.markedForRemoval = true;\n    };\n\n    var getItemHeight = function getItemHeight(child) {\n        return (\n            child.rect.element.height +\n            child.rect.element.marginBottom * 0.5 +\n            child.rect.element.marginTop * 0.5\n        );\n    };\n    var getItemWidth = function getItemWidth(child) {\n        return (\n            child.rect.element.width +\n            child.rect.element.marginLeft * 0.5 +\n            child.rect.element.marginRight * 0.5\n        );\n    };\n\n    var dragItem = function dragItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var id = action.id,\n            dragState = action.dragState;\n\n        // reference to item\n        var item = root.query('GET_ITEM', { id: id });\n\n        // get the view matching the given id\n        var view = root.childViews.find(function(child) {\n            return child.id === id;\n        });\n\n        var numItems = root.childViews.length;\n        var oldIndex = dragState.getItemIndex(item);\n\n        // if no view found, exit\n        if (!view) return;\n\n        var dragPosition = {\n            x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n            y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y,\n        };\n\n        // get drag area dimensions\n        var dragHeight = getItemHeight(view);\n        var dragWidth = getItemWidth(view);\n\n        // get rows and columns (There will always be at least one row and one column if a file is present)\n        var cols = Math.floor(root.rect.outer.width / dragWidth);\n        if (cols > numItems) cols = numItems;\n\n        // rows are used to find when we have left the preview area bounding box\n        var rows = Math.floor(numItems / cols + 1);\n\n        dropAreaDimensions.setHeight = dragHeight * rows;\n        dropAreaDimensions.setWidth = dragWidth * cols;\n\n        // get new index of dragged item\n        var location = {\n            y: Math.floor(dragPosition.y / dragHeight),\n            x: Math.floor(dragPosition.x / dragWidth),\n            getGridIndex: function getGridIndex() {\n                if (\n                    dragPosition.y > dropAreaDimensions.getHeight ||\n                    dragPosition.y < 0 ||\n                    dragPosition.x > dropAreaDimensions.getWidth ||\n                    dragPosition.x < 0\n                )\n                    return oldIndex;\n                return this.y * cols + this.x;\n            },\n            getColIndex: function getColIndex() {\n                var items = root.query('GET_ACTIVE_ITEMS');\n                var visibleChildren = root.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = items.map(function(item) {\n                    return visibleChildren.find(function(childView) {\n                        return childView.id === item.id;\n                    });\n                });\n\n                var currentIndex = children.findIndex(function(child) {\n                    return child === view;\n                });\n                var dragHeight = getItemHeight(view);\n                var l = children.length;\n                var idx = l;\n                var childHeight = 0;\n                var childBottom = 0;\n                var childTop = 0;\n                for (var i = 0; i < l; i++) {\n                    childHeight = getItemHeight(children[i]);\n                    childTop = childBottom;\n                    childBottom = childTop + childHeight;\n                    if (dragPosition.y < childBottom) {\n                        if (currentIndex > i) {\n                            if (dragPosition.y < childTop + dragHeight) {\n                                idx = i;\n                                break;\n                            }\n                            continue;\n                        }\n                        idx = i;\n                        break;\n                    }\n                }\n                return idx;\n            },\n        };\n\n        // get new index\n        var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n        root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n        // if the index of the item changed, dispatch reorder action\n        var currentIndex = dragState.getIndex();\n\n        if (currentIndex === undefined || currentIndex !== index) {\n            dragState.setIndex(index);\n\n            if (currentIndex === undefined) return;\n\n            root.dispatch('DID_REORDER_ITEMS', {\n                items: root.query('GET_ACTIVE_ITEMS'),\n                origin: oldIndex,\n                target: index,\n            });\n        }\n    };\n\n    /**\n     * Setup action routes\n     */\n    var route$2 = createRoute({\n        DID_ADD_ITEM: addItemView,\n        DID_REMOVE_ITEM: removeItemView,\n        DID_DRAG_ITEM: dragItem,\n    });\n\n    /**\n     * Write to view\n     * @param root\n     * @param actions\n     * @param props\n     */\n    var write$5 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions,\n            shouldOptimize = _ref5.shouldOptimize;\n        // route actions\n        route$2({ root: root, props: props, actions: actions });\n        var dragCoordinates = props.dragCoordinates;\n\n        // available space on horizontal axis\n        var horizontalSpace = root.rect.element.width;\n\n        // only draw children that have dimensions\n        var visibleChildren = root.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n\n        // sort based on current active items\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // get index\n        var dragIndex = dragCoordinates\n            ? getItemIndexByPosition(root, children, dragCoordinates)\n            : null;\n\n        // add index is used to reserve the dropped/added item index till the actual item is rendered\n        var addIndex = root.ref.addIndex || null;\n\n        // add index no longer needed till possibly next draw\n        root.ref.addIndex = null;\n\n        var dragIndexOffset = 0;\n        var removeIndexOffset = 0;\n        var addIndexOffset = 0;\n\n        if (children.length === 0) return;\n\n        var childRect = children[0].rect.element;\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            var offsetY = 0;\n            var dragOffset = 0;\n\n            children.forEach(function(child, index) {\n                if (dragIndex) {\n                    var dist = index - dragIndex;\n                    if (dist === -2) {\n                        dragOffset = -itemVerticalMargin * 0.25;\n                    } else if (dist === -1) {\n                        dragOffset = -itemVerticalMargin * 0.75;\n                    } else if (dist === 0) {\n                        dragOffset = itemVerticalMargin * 0.75;\n                    } else if (dist === 1) {\n                        dragOffset = itemVerticalMargin * 0.25;\n                    } else {\n                        dragOffset = 0;\n                    }\n                }\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                if (!child.markedForRemoval) {\n                    moveItem(child, 0, offsetY + dragOffset);\n                }\n\n                var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n                var visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n                offsetY += visualHeight;\n            });\n        }\n        // grid\n        else {\n            var prevX = 0;\n            var prevY = 0;\n\n            children.forEach(function(child, index) {\n                if (index === dragIndex) {\n                    dragIndexOffset = 1;\n                }\n\n                if (index === addIndex) {\n                    addIndexOffset += 1;\n                }\n\n                if (child.markedForRemoval && child.opacity < 0.5) {\n                    removeIndexOffset -= 1;\n                }\n\n                var visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n                var indexX = visualIndex % itemsPerRow;\n                var indexY = Math.floor(visualIndex / itemsPerRow);\n\n                var offsetX = indexX * itemWidth;\n                var offsetY = indexY * itemHeight;\n\n                var vectorX = Math.sign(offsetX - prevX);\n                var vectorY = Math.sign(offsetY - prevY);\n\n                prevX = offsetX;\n                prevY = offsetY;\n\n                if (child.markedForRemoval) return;\n\n                if (shouldOptimize) {\n                    child.translateX = null;\n                    child.translateY = null;\n                }\n\n                moveItem(child, offsetX, offsetY, vectorX, vectorY);\n            });\n        }\n    };\n\n    /**\n     * Filters actions that are meant specifically for a certain child of the list\n     * @param child\n     * @param actions\n     */\n    var filterSetItemActions = function filterSetItemActions(child, actions) {\n        return actions.filter(function(action) {\n            // if action has an id, filter out actions that don't have this child id\n            if (action.data && action.data.id) {\n                return child.id === action.data.id;\n            }\n\n            // allow all other actions\n            return true;\n        });\n    };\n\n    var list = createView({\n        create: create$8,\n        write: write$5,\n        tag: 'ul',\n        name: 'list',\n        didWriteView: function didWriteView(_ref6) {\n            var root = _ref6.root;\n            root.childViews\n                .filter(function(view) {\n                    return view.markedForRemoval && view.opacity === 0 && view.resting;\n                })\n                .forEach(function(view) {\n                    view._destroy();\n                    root.removeChildView(view);\n                });\n        },\n        filterFrameActionsForChild: filterSetItemActions,\n        mixins: {\n            apis: ['dragCoordinates'],\n        },\n    });\n\n    var create$9 = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.ref.list = root.appendChildView(root.createChildView(list));\n        props.dragCoordinates = null;\n        props.overflowing = false;\n    };\n\n    var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n        var root = _ref2.root,\n            props = _ref2.props,\n            action = _ref2.action;\n        if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n        props.dragCoordinates = {\n            left: action.position.scopeLeft - root.ref.list.rect.element.left,\n            top:\n                action.position.scopeTop -\n                (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop),\n        };\n    };\n\n    var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n        var props = _ref3.props;\n        props.dragCoordinates = null;\n    };\n\n    var route$3 = createRoute({\n        DID_DRAG: storeDragCoordinates,\n        DID_END_DRAG: clearDragCoordinates,\n    });\n\n    var write$6 = function write(_ref4) {\n        var root = _ref4.root,\n            props = _ref4.props,\n            actions = _ref4.actions;\n\n        // route actions\n        route$3({ root: root, props: props, actions: actions });\n\n        // current drag position\n        root.ref.list.dragCoordinates = props.dragCoordinates;\n\n        // if currently overflowing but no longer received overflow\n        if (props.overflowing && !props.overflow) {\n            props.overflowing = false;\n\n            // reset overflow state\n            root.element.dataset.state = '';\n            root.height = null;\n        }\n\n        // if is not overflowing currently but does receive overflow value\n        if (props.overflow) {\n            var newHeight = Math.round(props.overflow);\n            if (newHeight !== root.height) {\n                props.overflowing = true;\n                root.element.dataset.state = 'overflow';\n                root.height = newHeight;\n            }\n        }\n    };\n\n    var listScroller = createView({\n        create: create$9,\n        write: write$6,\n        name: 'list-scroller',\n        mixins: {\n            apis: ['overflow', 'dragCoordinates'],\n            styles: ['height', 'translateY'],\n            animations: {\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var attrToggle = function attrToggle(element, name, state) {\n        var enabledValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n        if (state) {\n            attr(element, name, enabledValue);\n        } else {\n            element.removeAttribute(name);\n        }\n    };\n\n    var resetFileInput = function resetFileInput(input) {\n        // no value, no need to reset\n        if (!input || input.value === '') {\n            return;\n        }\n\n        try {\n            // for modern browsers\n            input.value = '';\n        } catch (err) {}\n\n        // for IE10\n        if (input.value) {\n            // quickly append input to temp form and reset form\n            var form = createElement$1('form');\n            var parentNode = input.parentNode;\n            var ref = input.nextSibling;\n            form.appendChild(input);\n            form.reset();\n\n            // re-inject input where it originally was\n            if (ref) {\n                parentNode.insertBefore(input, ref);\n            } else {\n                parentNode.appendChild(input);\n            }\n        }\n    };\n\n    var create$a = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n\n        // set id so can be referenced from outside labels\n        root.element.id = 'filepond--browser-' + props.id;\n\n        // set name of element (is removed when a value is set)\n        attr(root.element, 'name', root.query('GET_NAME'));\n\n        // we have to link this element to the status element\n        attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n        // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n        attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n        // set configurable props\n        setAcceptedFileTypes({\n            root: root,\n            action: { value: root.query('GET_ACCEPTED_FILE_TYPES') },\n        });\n        toggleAllowMultiple({ root: root, action: { value: root.query('GET_ALLOW_MULTIPLE') } });\n        toggleDirectoryFilter({\n            root: root,\n            action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') },\n        });\n        toggleDisabled({ root: root });\n        toggleRequired({ root: root, action: { value: root.query('GET_REQUIRED') } });\n        setCaptureMethod({ root: root, action: { value: root.query('GET_CAPTURE_METHOD') } });\n\n        // handle changes to the input field\n        root.ref.handleChange = function(e) {\n            if (!root.element.value) {\n                return;\n            }\n\n            // extract files and move value of webkitRelativePath path to _relativePath\n            var files = Array.from(root.element.files).map(function(file) {\n                file._relativePath = file.webkitRelativePath;\n                return file;\n            });\n\n            // we add a little delay so the OS file select window can move out of the way before we add our file\n            setTimeout(function() {\n                // load files\n                props.onload(files);\n\n                // reset input, it's just for exposing a method to drop files, should not retain any state\n                resetFileInput(root.element);\n            }, 250);\n        };\n\n        root.element.addEventListener('change', root.ref.handleChange);\n    };\n\n    var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n        attrToggle(\n            root.element,\n            'accept',\n            !!action.value,\n            action.value ? action.value.join(',') : ''\n        );\n    };\n\n    var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        attrToggle(root.element, 'multiple', action.value);\n    };\n\n    var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        attrToggle(root.element, 'webkitdirectory', action.value);\n    };\n\n    var toggleDisabled = function toggleDisabled(_ref5) {\n        var root = _ref5.root;\n        var isDisabled = root.query('GET_DISABLED');\n        var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n        var disableField = isDisabled || !doesAllowBrowse;\n        attrToggle(root.element, 'disabled', disableField);\n    };\n\n    var toggleRequired = function toggleRequired(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        // want to remove required, always possible\n        if (!action.value) {\n            attrToggle(root.element, 'required', false);\n        }\n        // if want to make required, only possible when zero items\n        else if (root.query('GET_TOTAL_ITEMS') === 0) {\n            attrToggle(root.element, 'required', true);\n        }\n    };\n\n    var setCaptureMethod = function setCaptureMethod(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        attrToggle(\n            root.element,\n            'capture',\n            !!action.value,\n            action.value === true ? '' : action.value\n        );\n    };\n\n    var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n        var root = _ref8.root;\n        var element = root.element;\n        // always remove the required attribute when more than zero items\n        if (root.query('GET_TOTAL_ITEMS') > 0) {\n            attrToggle(element, 'required', false);\n            attrToggle(element, 'name', false);\n        } else {\n            // add name attribute\n            attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n            // remove any validation messages\n            var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n            if (shouldCheckValidity) {\n                element.setCustomValidity('');\n            }\n\n            // we only add required if the field has been deemed required\n            if (root.query('GET_REQUIRED')) {\n                attrToggle(element, 'required', true);\n            }\n        }\n    };\n\n    var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n        var root = _ref9.root;\n        var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n        if (!shouldCheckValidity) return;\n        root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n    };\n\n    var browser = createView({\n        tag: 'input',\n        name: 'browser',\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        attributes: {\n            type: 'file',\n        },\n\n        create: create$a,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            root.element.removeEventListener('change', root.ref.handleChange);\n        },\n        write: createRoute({\n            DID_LOAD_ITEM: updateRequiredStatus,\n            DID_REMOVE_ITEM: updateRequiredStatus,\n            DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n            DID_SET_DISABLED: toggleDisabled,\n            DID_SET_ALLOW_BROWSE: toggleDisabled,\n            DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n            DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n            DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n            DID_SET_CAPTURE_METHOD: setCaptureMethod,\n            DID_SET_REQUIRED: toggleRequired,\n        }),\n    });\n\n    var Key = {\n        ENTER: 13,\n        SPACE: 32,\n    };\n\n    var create$b = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // create the label and link it to the file browser\n        var label = createElement$1('label');\n        attr(label, 'for', 'filepond--browser-' + props.id);\n\n        // use for labeling file input (aria-labelledby on file input)\n        attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n        // handle keys\n        root.ref.handleKeyDown = function(e) {\n            var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n            if (!isActivationKey) return;\n            // stops from triggering the element a second time\n            e.preventDefault();\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        root.ref.handleClick = function(e) {\n            var isLabelClick = e.target === label || label.contains(e.target);\n\n            // don't want to click twice\n            if (isLabelClick) return;\n\n            // click link (will then in turn activate file input)\n            root.ref.label.click();\n        };\n\n        // attach events\n        label.addEventListener('keydown', root.ref.handleKeyDown);\n        root.element.addEventListener('click', root.ref.handleClick);\n\n        // update\n        updateLabelValue(label, props.caption);\n\n        // add!\n        root.appendChild(label);\n        root.ref.label = label;\n    };\n\n    var updateLabelValue = function updateLabelValue(label, value) {\n        label.innerHTML = value;\n        var clickable = label.querySelector('.filepond--label-action');\n        if (clickable) {\n            attr(clickable, 'tabindex', '0');\n        }\n        return value;\n    };\n\n    var dropLabel = createView({\n        name: 'drop-label',\n        ignoreRect: true,\n        create: create$b,\n        destroy: function destroy(_ref2) {\n            var root = _ref2.root;\n            root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n            root.element.removeEventListener('click', root.ref.handleClick);\n        },\n        write: createRoute({\n            DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n                var root = _ref3.root,\n                    action = _ref3.action;\n                updateLabelValue(root.ref.label, action.value);\n            },\n        }),\n\n        mixins: {\n            styles: ['opacity', 'translateX', 'translateY'],\n            animations: {\n                opacity: { type: 'tween', duration: 150 },\n                translateX: 'spring',\n                translateY: 'spring',\n            },\n        },\n    });\n\n    var blob = createView({\n        name: 'drip-blob',\n        ignoreRect: true,\n        mixins: {\n            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n            animations: {\n                scaleX: 'spring',\n                scaleY: 'spring',\n                translateX: 'spring',\n                translateY: 'spring',\n                opacity: { type: 'tween', duration: 250 },\n            },\n        },\n    });\n\n    var addBlob = function addBlob(_ref) {\n        var root = _ref.root;\n        var centerX = root.rect.element.width * 0.5;\n        var centerY = root.rect.element.height * 0.5;\n\n        root.ref.blob = root.appendChildView(\n            root.createChildView(blob, {\n                opacity: 0,\n                scaleX: 2.5,\n                scaleY: 2.5,\n                translateX: centerX,\n                translateY: centerY,\n            })\n        );\n    };\n\n    var moveBlob = function moveBlob(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!root.ref.blob) {\n            addBlob({ root: root });\n            return;\n        }\n\n        root.ref.blob.translateX = action.position.scopeLeft;\n        root.ref.blob.translateY = action.position.scopeTop;\n        root.ref.blob.scaleX = 1;\n        root.ref.blob.scaleY = 1;\n        root.ref.blob.opacity = 1;\n    };\n\n    var hideBlob = function hideBlob(_ref3) {\n        var root = _ref3.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.opacity = 0;\n    };\n\n    var explodeBlob = function explodeBlob(_ref4) {\n        var root = _ref4.root;\n        if (!root.ref.blob) {\n            return;\n        }\n        root.ref.blob.scaleX = 2.5;\n        root.ref.blob.scaleY = 2.5;\n        root.ref.blob.opacity = 0;\n    };\n\n    var write$7 = function write(_ref5) {\n        var root = _ref5.root,\n            props = _ref5.props,\n            actions = _ref5.actions;\n        route$4({ root: root, props: props, actions: actions });\n        var blob = root.ref.blob;\n\n        if (actions.length === 0 && blob && blob.opacity === 0) {\n            root.removeChildView(blob);\n            root.ref.blob = null;\n        }\n    };\n\n    var route$4 = createRoute({\n        DID_DRAG: moveBlob,\n        DID_DROP: explodeBlob,\n        DID_END_DRAG: hideBlob,\n    });\n\n    var drip = createView({\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        name: 'drip',\n        write: write$7,\n    });\n\n    var setInputFiles = function setInputFiles(element, files) {\n        try {\n            // Create a DataTransfer instance and add a newly created file\n            var dataTransfer = new DataTransfer();\n            files.forEach(function(file) {\n                if (file instanceof File) {\n                    dataTransfer.items.add(file);\n                } else {\n                    dataTransfer.items.add(\n                        new File([file], file.name, {\n                            type: file.type,\n                        })\n                    );\n                }\n            });\n\n            // Assign the DataTransfer files list to the file input\n            element.files = dataTransfer.files;\n        } catch (err) {\n            return false;\n        }\n        return true;\n    };\n\n    var create$c = function create(_ref) {\n        var root = _ref.root;\n        root.ref.fields = {};\n        var legend = document.createElement('legend');\n        legend.textContent = 'Files';\n        root.element.appendChild(legend);\n    };\n\n    var getField = function getField(root, id) {\n        return root.ref.fields[id];\n    };\n\n    var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n        root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n            if (!root.ref.fields[item.id]) return;\n            root.element.appendChild(root.ref.fields[item.id]);\n        });\n    };\n\n    var didReorderItems = function didReorderItems(_ref2) {\n        var root = _ref2.root;\n        return syncFieldPositionsWithItems(root);\n    };\n\n    var didAddItem = function didAddItem(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        var fileItem = root.query('GET_ITEM', action.id);\n        var isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n        var shouldUseFileInput = !isLocalFile && root.query('SHOULD_UPDATE_FILE_INPUT');\n        var dataContainer = createElement$1('input');\n        dataContainer.type = shouldUseFileInput ? 'file' : 'hidden';\n        dataContainer.name = root.query('GET_NAME');\n        root.ref.fields[action.id] = dataContainer;\n        syncFieldPositionsWithItems(root);\n    };\n\n    var didLoadItem$1 = function didLoadItem(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n\n        // store server ref in hidden input\n        if (action.serverFileReference !== null) field.value = action.serverFileReference;\n\n        // store file item in file input\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n\n        var fileItem = root.query('GET_ITEM', action.id);\n        setInputFiles(field, [fileItem.file]);\n    };\n\n    var didPrepareOutput = function didPrepareOutput(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        // this timeout pushes the handler after 'load'\n        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n        setTimeout(function() {\n            var field = getField(root, action.id);\n            if (!field) return;\n            setInputFiles(field, [action.file]);\n        }, 0);\n    };\n\n    var didSetDisabled = function didSetDisabled(_ref6) {\n        var root = _ref6.root;\n        root.element.disabled = root.query('GET_DISABLED');\n    };\n\n    var didRemoveItem = function didRemoveItem(_ref7) {\n        var root = _ref7.root,\n            action = _ref7.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (field.parentNode) field.parentNode.removeChild(field);\n        delete root.ref.fields[action.id];\n    };\n\n    // only runs for server files. will refuse to update the value if the field\n    // is a file field\n    var didDefineValue = function didDefineValue(_ref8) {\n        var root = _ref8.root,\n            action = _ref8.action;\n        var field = getField(root, action.id);\n        if (!field) return;\n        if (action.value === null) {\n            // clear field value\n            field.removeAttribute('value');\n        } else {\n            // set field value\n            if (field.type != 'file') {\n                field.value = action.value;\n            }\n        }\n        syncFieldPositionsWithItems(root);\n    };\n\n    var write$8 = createRoute({\n        DID_SET_DISABLED: didSetDisabled,\n        DID_ADD_ITEM: didAddItem,\n        DID_LOAD_ITEM: didLoadItem$1,\n        DID_REMOVE_ITEM: didRemoveItem,\n        DID_DEFINE_VALUE: didDefineValue,\n        DID_PREPARE_OUTPUT: didPrepareOutput,\n        DID_REORDER_ITEMS: didReorderItems,\n        DID_SORT_ITEMS: didReorderItems,\n    });\n\n    var data = createView({\n        tag: 'fieldset',\n        name: 'data',\n        create: create$c,\n        write: write$8,\n        ignoreRect: true,\n    });\n\n    var getRootNode = function getRootNode(element) {\n        return 'getRootNode' in element ? element.getRootNode() : document;\n    };\n\n    var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n    var text$1 = ['css', 'csv', 'html', 'txt'];\n    var map = {\n        zip: 'zip|compressed',\n        epub: 'application/epub+zip',\n    };\n\n    var guesstimateMimeType = function guesstimateMimeType() {\n        var extension = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        extension = extension.toLowerCase();\n        if (images.includes(extension)) {\n            return (\n                'image/' +\n                (extension === 'jpg' ? 'jpeg' : extension === 'svg' ? 'svg+xml' : extension)\n            );\n        }\n        if (text$1.includes(extension)) {\n            return 'text/' + extension;\n        }\n\n        return map[extension] || '';\n    };\n\n    var requestDataTransferItems = function requestDataTransferItems(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n            var links = getLinks(dataTransfer);\n            if (links.length && !hasFiles(dataTransfer)) {\n                return resolve(links);\n            }\n            // try to get files from the transfer\n            getFiles(dataTransfer).then(resolve);\n        });\n    };\n\n    /**\n     * Test if datatransfer has files\n     */\n    var hasFiles = function hasFiles(dataTransfer) {\n        if (dataTransfer.files) return dataTransfer.files.length > 0;\n        return false;\n    };\n\n    /**\n     * Extracts files from a DataTransfer object\n     */\n    var getFiles = function getFiles(dataTransfer) {\n        return new Promise(function(resolve, reject) {\n            // get the transfer items as promises\n            var promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])\n                // only keep file system items (files and directories)\n                .filter(function(item) {\n                    return isFileSystemItem(item);\n                })\n\n                // map each item to promise\n                .map(function(item) {\n                    return getFilesFromItem(item);\n                });\n\n            // if is empty, see if we can extract some info from the files property as a fallback\n            if (!promisedFiles.length) {\n                // TODO: test for directories (should not be allowed)\n                // Use FileReader, problem is that the files property gets lost in the process\n                resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n                return;\n            }\n\n            // done!\n            Promise.all(promisedFiles)\n                .then(function(returnedFileGroups) {\n                    // flatten groups\n                    var files = [];\n                    returnedFileGroups.forEach(function(group) {\n                        files.push.apply(files, group);\n                    });\n\n                    // done (filter out empty files)!\n                    resolve(\n                        files\n                            .filter(function(file) {\n                                return file;\n                            })\n                            .map(function(file) {\n                                if (!file._relativePath)\n                                    file._relativePath = file.webkitRelativePath;\n                                return file;\n                            })\n                    );\n                })\n                .catch(console.error);\n        });\n    };\n\n    var isFileSystemItem = function isFileSystemItem(item) {\n        if (isEntry(item)) {\n            var entry = getAsEntry(item);\n            if (entry) {\n                return entry.isFile || entry.isDirectory;\n            }\n        }\n        return item.kind === 'file';\n    };\n\n    var getFilesFromItem = function getFilesFromItem(item) {\n        return new Promise(function(resolve, reject) {\n            if (isDirectoryEntry(item)) {\n                getFilesInDirectory(getAsEntry(item))\n                    .then(resolve)\n                    .catch(reject);\n                return;\n            }\n\n            resolve([item.getAsFile()]);\n        });\n    };\n\n    var getFilesInDirectory = function getFilesInDirectory(entry) {\n        return new Promise(function(resolve, reject) {\n            var files = [];\n\n            // the total entries to read\n            var dirCounter = 0;\n            var fileCounter = 0;\n\n            var resolveIfDone = function resolveIfDone() {\n                if (fileCounter === 0 && dirCounter === 0) {\n                    resolve(files);\n                }\n            };\n\n            // the recursive function\n            var readEntries = function readEntries(dirEntry) {\n                dirCounter++;\n\n                var directoryReader = dirEntry.createReader();\n\n                // directories are returned in batches, we need to process all batches before we're done\n                var readBatch = function readBatch() {\n                    directoryReader.readEntries(function(entries) {\n                        if (entries.length === 0) {\n                            dirCounter--;\n                            resolveIfDone();\n                            return;\n                        }\n\n                        entries.forEach(function(entry) {\n                            // recursively read more directories\n                            if (entry.isDirectory) {\n                                readEntries(entry);\n                            } else {\n                                // read as file\n                                fileCounter++;\n\n                                entry.file(function(file) {\n                                    var correctedFile = correctMissingFileType(file);\n                                    if (entry.fullPath)\n                                        correctedFile._relativePath = entry.fullPath;\n                                    files.push(correctedFile);\n                                    fileCounter--;\n                                    resolveIfDone();\n                                });\n                            }\n                        });\n\n                        // try to get next batch of files\n                        readBatch();\n                    }, reject);\n                };\n\n                // read first batch of files\n                readBatch();\n            };\n\n            // go!\n            readEntries(entry);\n        });\n    };\n\n    var correctMissingFileType = function correctMissingFileType(file) {\n        if (file.type.length) return file;\n        var date = file.lastModifiedDate;\n        var name = file.name;\n        var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n        if (!type.length) return file;\n        file = file.slice(0, file.size, type);\n        file.name = name;\n        file.lastModifiedDate = date;\n        return file;\n    };\n\n    var isDirectoryEntry = function isDirectoryEntry(item) {\n        return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n    };\n\n    var isEntry = function isEntry(item) {\n        return 'webkitGetAsEntry' in item;\n    };\n\n    var getAsEntry = function getAsEntry(item) {\n        return item.webkitGetAsEntry();\n    };\n\n    /**\n     * Extracts links from a DataTransfer object\n     */\n    var getLinks = function getLinks(dataTransfer) {\n        var links = [];\n        try {\n            // look in meta data property\n            links = getLinksFromTransferMetaData(dataTransfer);\n            if (links.length) {\n                return links;\n            }\n            links = getLinksFromTransferURLData(dataTransfer);\n        } catch (e) {\n            // nope nope nope (probably IE trouble)\n        }\n        return links;\n    };\n\n    var getLinksFromTransferURLData = function getLinksFromTransferURLData(dataTransfer) {\n        var data = dataTransfer.getData('url');\n        if (typeof data === 'string' && data.length) {\n            return [data];\n        }\n        return [];\n    };\n\n    var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(dataTransfer) {\n        var data = dataTransfer.getData('text/html');\n        if (typeof data === 'string' && data.length) {\n            var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n            if (matches) {\n                return [matches[1]];\n            }\n        }\n        return [];\n    };\n\n    var dragNDropObservers = [];\n\n    var eventPosition = function eventPosition(e) {\n        return {\n            pageLeft: e.pageX,\n            pageTop: e.pageY,\n            scopeLeft: e.offsetX || e.layerX,\n            scopeTop: e.offsetY || e.layerY,\n        };\n    };\n\n    var createDragNDropClient = function createDragNDropClient(\n        element,\n        scopeToObserve,\n        filterElement\n    ) {\n        var observer = getDragNDropObserver(scopeToObserve);\n\n        var client = {\n            element: element,\n            filterElement: filterElement,\n            state: null,\n            ondrop: function ondrop() {},\n            onenter: function onenter() {},\n            ondrag: function ondrag() {},\n            onexit: function onexit() {},\n            onload: function onload() {},\n            allowdrop: function allowdrop() {},\n        };\n\n        client.destroy = observer.addListener(client);\n\n        return client;\n    };\n\n    var getDragNDropObserver = function getDragNDropObserver(element) {\n        // see if already exists, if so, return\n        var observer = dragNDropObservers.find(function(item) {\n            return item.element === element;\n        });\n        if (observer) {\n            return observer;\n        }\n\n        // create new observer, does not yet exist for this element\n        var newObserver = createDragNDropObserver(element);\n        dragNDropObservers.push(newObserver);\n        return newObserver;\n    };\n\n    var createDragNDropObserver = function createDragNDropObserver(element) {\n        var clients = [];\n\n        var routes = {\n            dragenter: dragenter,\n            dragover: dragover,\n            dragleave: dragleave,\n            drop: drop,\n        };\n\n        var handlers = {};\n\n        forin(routes, function(event, createHandler) {\n            handlers[event] = createHandler(element, clients);\n            element.addEventListener(event, handlers[event], false);\n        });\n\n        var observer = {\n            element: element,\n            addListener: function addListener(client) {\n                // add as client\n                clients.push(client);\n\n                // return removeListener function\n                return function() {\n                    // remove client\n                    clients.splice(clients.indexOf(client), 1);\n\n                    // if no more clients, clean up observer\n                    if (clients.length === 0) {\n                        dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n                        forin(routes, function(event) {\n                            element.removeEventListener(event, handlers[event], false);\n                        });\n                    }\n                };\n            },\n        };\n\n        return observer;\n    };\n\n    var elementFromPoint = function elementFromPoint(root, point) {\n        if (!('elementFromPoint' in root)) {\n            root = document;\n        }\n        return root.elementFromPoint(point.x, point.y);\n    };\n\n    var isEventTarget = function isEventTarget(e, target) {\n        // get root\n        var root = getRootNode(target);\n\n        // get element at position\n        // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n        var elementAtPosition = elementFromPoint(root, {\n            x: e.pageX - window.pageXOffset,\n            y: e.pageY - window.pageYOffset,\n        });\n\n        // test if target is the element or if one of its children is\n        return elementAtPosition === target || target.contains(elementAtPosition);\n    };\n\n    var initialTarget = null;\n\n    var setDropEffect = function setDropEffect(dataTransfer, effect) {\n        // is in try catch as IE11 will throw error if not\n        try {\n            dataTransfer.dropEffect = effect;\n        } catch (e) {}\n    };\n\n    var dragenter = function dragenter(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            initialTarget = e.target;\n\n            clients.forEach(function(client) {\n                var element = client.element,\n                    onenter = client.onenter;\n\n                if (isEventTarget(e, element)) {\n                    client.state = 'enter';\n\n                    // fire enter event\n                    onenter(eventPosition(e));\n                }\n            });\n        };\n    };\n\n    var dragover = function dragover(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                var overDropTarget = false;\n\n                clients.some(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        onenter = client.onenter,\n                        onexit = client.onexit,\n                        ondrag = client.ondrag,\n                        allowdrop = client.allowdrop;\n\n                    // by default we can drop\n                    setDropEffect(dataTransfer, 'copy');\n\n                    // allow transfer of these items\n                    var allowsTransfer = allowdrop(items);\n\n                    // only used when can be dropped on page\n                    if (!allowsTransfer) {\n                        setDropEffect(dataTransfer, 'none');\n                        return;\n                    }\n\n                    // targetting this client\n                    if (isEventTarget(e, element)) {\n                        overDropTarget = true;\n\n                        // had no previous state, means we are entering this client\n                        if (client.state === null) {\n                            client.state = 'enter';\n                            onenter(eventPosition(e));\n                            return;\n                        }\n\n                        // now over element (no matter if it allows the drop or not)\n                        client.state = 'over';\n\n                        // needs to allow transfer\n                        if (filterElement && !allowsTransfer) {\n                            setDropEffect(dataTransfer, 'none');\n                            return;\n                        }\n\n                        // dragging\n                        ondrag(eventPosition(e));\n                    } else {\n                        // should be over an element to drop\n                        if (filterElement && !overDropTarget) {\n                            setDropEffect(dataTransfer, 'none');\n                        }\n\n                        // might have just left this client?\n                        if (client.state) {\n                            client.state = null;\n                            onexit(eventPosition(e));\n                        }\n                    }\n                });\n            });\n        };\n    };\n\n    var drop = function drop(root, clients) {\n        return function(e) {\n            e.preventDefault();\n\n            var dataTransfer = e.dataTransfer;\n\n            requestDataTransferItems(dataTransfer).then(function(items) {\n                clients.forEach(function(client) {\n                    var filterElement = client.filterElement,\n                        element = client.element,\n                        ondrop = client.ondrop,\n                        onexit = client.onexit,\n                        allowdrop = client.allowdrop;\n\n                    client.state = null;\n\n                    // if we're filtering on element we need to be over the element to drop\n                    if (filterElement && !isEventTarget(e, element)) return;\n\n                    // no transfer for this client\n                    if (!allowdrop(items)) return onexit(eventPosition(e));\n\n                    // we can drop these items on this client\n                    ondrop(eventPosition(e), items);\n                });\n            });\n        };\n    };\n\n    var dragleave = function dragleave(root, clients) {\n        return function(e) {\n            if (initialTarget !== e.target) {\n                return;\n            }\n\n            clients.forEach(function(client) {\n                var onexit = client.onexit;\n\n                client.state = null;\n\n                onexit(eventPosition(e));\n            });\n        };\n    };\n\n    var createHopper = function createHopper(scope, validateItems, options) {\n        // is now hopper scope\n        scope.classList.add('filepond--hopper');\n\n        // shortcuts\n        var catchesDropsOnPage = options.catchesDropsOnPage,\n            requiresDropOnElement = options.requiresDropOnElement,\n            _options$filterItems = options.filterItems,\n            filterItems =\n                _options$filterItems === void 0\n                    ? function(items) {\n                          return items;\n                      }\n                    : _options$filterItems;\n\n        // create a dnd client\n        var client = createDragNDropClient(\n            scope,\n            catchesDropsOnPage ? document.documentElement : scope,\n            requiresDropOnElement\n        );\n\n        // current client state\n        var lastState = '';\n        var currentState = '';\n\n        // determines if a file may be dropped\n        client.allowdrop = function(items) {\n            // TODO: if we can, throw error to indicate the items cannot by dropped\n\n            return validateItems(filterItems(items));\n        };\n\n        client.ondrop = function(position, items) {\n            var filteredItems = filterItems(items);\n\n            if (!validateItems(filteredItems)) {\n                api.ondragend(position);\n                return;\n            }\n\n            currentState = 'drag-drop';\n\n            api.onload(filteredItems, position);\n        };\n\n        client.ondrag = function(position) {\n            api.ondrag(position);\n        };\n\n        client.onenter = function(position) {\n            currentState = 'drag-over';\n\n            api.ondragstart(position);\n        };\n\n        client.onexit = function(position) {\n            currentState = 'drag-exit';\n\n            api.ondragend(position);\n        };\n\n        var api = {\n            updateHopperState: function updateHopperState() {\n                if (lastState !== currentState) {\n                    scope.dataset.hopperState = currentState;\n                    lastState = currentState;\n                }\n            },\n            onload: function onload() {},\n            ondragstart: function ondragstart() {},\n            ondrag: function ondrag() {},\n            ondragend: function ondragend() {},\n            destroy: function destroy() {\n                // destroy client\n                client.destroy();\n            },\n        };\n\n        return api;\n    };\n\n    var listening = false;\n    var listeners$1 = [];\n\n    var handlePaste = function handlePaste(e) {\n        // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n        var activeEl = document.activeElement;\n        var isActiveElementEditable =\n            activeEl &&\n            (/textarea|input/i.test(activeEl.nodeName) ||\n                activeEl.getAttribute('contenteditable') === 'true');\n\n        if (isActiveElementEditable) {\n            // test textarea or input is contained in filepond root\n            var inScope = false;\n            var element = activeEl;\n            while (element !== document.body) {\n                if (element.classList.contains('filepond--root')) {\n                    inScope = true;\n                    break;\n                }\n                element = element.parentNode;\n            }\n\n            if (!inScope) return;\n        }\n\n        requestDataTransferItems(e.clipboardData).then(function(files) {\n            // no files received\n            if (!files.length) {\n                return;\n            }\n\n            // notify listeners of received files\n            listeners$1.forEach(function(listener) {\n                return listener(files);\n            });\n        });\n    };\n\n    var listen = function listen(cb) {\n        // can't add twice\n        if (listeners$1.includes(cb)) {\n            return;\n        }\n\n        // add initial listener\n        listeners$1.push(cb);\n\n        // setup paste listener for entire page\n        if (listening) {\n            return;\n        }\n\n        listening = true;\n        document.addEventListener('paste', handlePaste);\n    };\n\n    var unlisten = function unlisten(listener) {\n        arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n        // clean up\n        if (listeners$1.length === 0) {\n            document.removeEventListener('paste', handlePaste);\n            listening = false;\n        }\n    };\n\n    var createPaster = function createPaster() {\n        var cb = function cb(files) {\n            api.onload(files);\n        };\n\n        var api = {\n            destroy: function destroy() {\n                unlisten(cb);\n            },\n            onload: function onload() {},\n        };\n\n        listen(cb);\n\n        return api;\n    };\n\n    /**\n     * Creates the file view\n     */\n    var create$d = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        root.element.id = 'filepond--assistant-' + props.id;\n        attr(root.element, 'role', 'alert');\n        attr(root.element, 'aria-live', 'polite');\n        attr(root.element, 'aria-relevant', 'additions');\n    };\n\n    var addFilesNotificationTimeout = null;\n    var notificationClearTimeout = null;\n\n    var filenames = [];\n\n    var assist = function assist(root, message) {\n        root.element.textContent = message;\n    };\n\n    var clear$1 = function clear(root) {\n        root.element.textContent = '';\n    };\n\n    var listModified = function listModified(root, filename, label) {\n        var total = root.query('GET_TOTAL_ITEMS');\n        assist(\n            root,\n            label +\n                ' ' +\n                filename +\n                ', ' +\n                total +\n                ' ' +\n                (total === 1\n                    ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n                    : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n        );\n\n        // clear group after set amount of time so the status is not read twice\n        clearTimeout(notificationClearTimeout);\n        notificationClearTimeout = setTimeout(function() {\n            clear$1(root);\n        }, 1500);\n    };\n\n    var isUsingFilePond = function isUsingFilePond(root) {\n        return root.element.parentNode.contains(document.activeElement);\n    };\n\n    var itemAdded = function itemAdded(_ref2) {\n        var root = _ref2.root,\n            action = _ref2.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        root.element.textContent = '';\n        var item = root.query('GET_ITEM', action.id);\n        filenames.push(item.filename);\n\n        clearTimeout(addFilesNotificationTimeout);\n        addFilesNotificationTimeout = setTimeout(function() {\n            listModified(root, filenames.join(', '), root.query('GET_LABEL_FILE_ADDED'));\n            filenames.length = 0;\n        }, 750);\n    };\n\n    var itemRemoved = function itemRemoved(_ref3) {\n        var root = _ref3.root,\n            action = _ref3.action;\n        if (!isUsingFilePond(root)) {\n            return;\n        }\n\n        var item = action.item;\n        listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n    };\n\n    var itemProcessed = function itemProcessed(_ref4) {\n        var root = _ref4.root,\n            action = _ref4.action;\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n        var root = _ref5.root,\n            action = _ref5.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n        var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n        assist(root, filename + ' ' + label);\n    };\n\n    var itemError = function itemError(_ref6) {\n        var root = _ref6.root,\n            action = _ref6.action;\n        var item = root.query('GET_ITEM', action.id);\n        var filename = item.filename;\n\n        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n        assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n    };\n\n    var assistant = createView({\n        create: create$d,\n        ignoreRect: true,\n        ignoreRectUpdate: true,\n        write: createRoute({\n            DID_LOAD_ITEM: itemAdded,\n            DID_REMOVE_ITEM: itemRemoved,\n            DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n            DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n            DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n            DID_THROW_ITEM_REMOVE_ERROR: itemError,\n            DID_THROW_ITEM_LOAD_ERROR: itemError,\n            DID_THROW_ITEM_INVALID: itemError,\n            DID_THROW_ITEM_PROCESSING_ERROR: itemError,\n        }),\n\n        tag: 'span',\n        name: 'assistant',\n    });\n\n    var toCamels = function toCamels(string) {\n        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n        return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n            return sub.charAt(1).toUpperCase();\n        });\n    };\n\n    var debounce = function debounce(func) {\n        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n        var immidiateOnly =\n            arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var last = Date.now();\n        var timeout = null;\n\n        return function() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            clearTimeout(timeout);\n\n            var dist = Date.now() - last;\n\n            var fn = function fn() {\n                last = Date.now();\n                func.apply(void 0, args);\n            };\n\n            if (dist < interval) {\n                // we need to delay by the difference between interval and dist\n                // for example: if distance is 10 ms and interval is 16 ms,\n                // we need to wait an additional 6ms before calling the function)\n                if (!immidiateOnly) {\n                    timeout = setTimeout(fn, interval - dist);\n                }\n            } else {\n                // go!\n                fn();\n            }\n        };\n    };\n\n    var MAX_FILES_LIMIT = 1000000;\n\n    var prevent = function prevent(e) {\n        return e.preventDefault();\n    };\n\n    var create$e = function create(_ref) {\n        var root = _ref.root,\n            props = _ref.props;\n        // Add id\n        var id = root.query('GET_ID');\n        if (id) {\n            root.element.id = id;\n        }\n\n        // Add className\n        var className = root.query('GET_CLASS_NAME');\n        if (className) {\n            className\n                .split(' ')\n                .filter(function(name) {\n                    return name.length;\n                })\n                .forEach(function(name) {\n                    root.element.classList.add(name);\n                });\n        }\n\n        // Field label\n        root.ref.label = root.appendChildView(\n            root.createChildView(\n                dropLabel,\n                Object.assign({}, props, {\n                    translateY: null,\n                    caption: root.query('GET_LABEL_IDLE'),\n                })\n            )\n        );\n\n        // List of items\n        root.ref.list = root.appendChildView(\n            root.createChildView(listScroller, { translateY: null })\n        );\n\n        // Background panel\n        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'panel-root' }));\n\n        // Assistant notifies assistive tech when content changes\n        root.ref.assistant = root.appendChildView(\n            root.createChildView(assistant, Object.assign({}, props))\n        );\n\n        // Data\n        root.ref.data = root.appendChildView(root.createChildView(data, Object.assign({}, props)));\n\n        // Measure (tests if fixed height was set)\n        // DOCTYPE needs to be set for this to work\n        root.ref.measure = createElement$1('div');\n        root.ref.measure.style.height = '100%';\n        root.element.appendChild(root.ref.measure);\n\n        // information on the root height or fixed height status\n        root.ref.bounds = null;\n\n        // apply initial style properties\n        root.query('GET_STYLES')\n            .filter(function(style) {\n                return !isEmpty(style.value);\n            })\n            .map(function(_ref2) {\n                var name = _ref2.name,\n                    value = _ref2.value;\n                root.element.dataset[name] = value;\n            });\n\n        // determine if width changed\n        root.ref.widthPrevious = null;\n        root.ref.widthUpdated = debounce(function() {\n            root.ref.updateHistory = [];\n            root.dispatch('DID_RESIZE_ROOT');\n        }, 250);\n\n        // history of updates\n        root.ref.previousAspectRatio = null;\n        root.ref.updateHistory = [];\n\n        // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n        var canHover = window.matchMedia('(pointer: fine) and (hover: hover)').matches;\n        var hasPointerEvents = 'PointerEvent' in window;\n        if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n            root.element.addEventListener('touchmove', prevent, { passive: false });\n            root.element.addEventListener('gesturestart', prevent);\n        }\n\n        // add credits\n        var credits = root.query('GET_CREDITS');\n        var hasCredits = credits.length === 2;\n        if (hasCredits) {\n            var frag = document.createElement('a');\n            frag.className = 'filepond--credits';\n            frag.href = credits[0];\n            frag.tabIndex = -1;\n            frag.target = '_blank';\n            frag.rel = 'noopener noreferrer nofollow';\n            frag.textContent = credits[1];\n            root.element.appendChild(frag);\n            root.ref.credits = frag;\n        }\n    };\n\n    var write$9 = function write(_ref3) {\n        var root = _ref3.root,\n            props = _ref3.props,\n            actions = _ref3.actions;\n        // route actions\n        route$5({ root: root, props: props, actions: actions });\n\n        // apply style properties\n        actions\n            .filter(function(action) {\n                return /^DID_SET_STYLE_/.test(action.type);\n            })\n            .filter(function(action) {\n                return !isEmpty(action.data.value);\n            })\n            .map(function(_ref4) {\n                var type = _ref4.type,\n                    data = _ref4.data;\n                var name = toCamels(type.substring(8).toLowerCase(), '_');\n                root.element.dataset[name] = data.value;\n                root.invalidateLayout();\n            });\n\n        if (root.rect.element.hidden) return;\n\n        if (root.rect.element.width !== root.ref.widthPrevious) {\n            root.ref.widthPrevious = root.rect.element.width;\n            root.ref.widthUpdated();\n        }\n\n        // get box bounds, we do this only once\n        var bounds = root.ref.bounds;\n        if (!bounds) {\n            bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n            // destroy measure element\n            root.element.removeChild(root.ref.measure);\n            root.ref.measure = null;\n        }\n\n        // get quick references to various high level parts of the upload tool\n        var _root$ref = root.ref,\n            hopper = _root$ref.hopper,\n            label = _root$ref.label,\n            list = _root$ref.list,\n            panel = _root$ref.panel;\n\n        // sets correct state to hopper scope\n        if (hopper) {\n            hopper.updateHopperState();\n        }\n\n        // bool to indicate if we're full or not\n        var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = isMultiItem ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT : 1;\n        var atMaxCapacity = totalItems === maxItems;\n\n        // action used to add item\n        var addAction = actions.find(function(action) {\n            return action.type === 'DID_ADD_ITEM';\n        });\n\n        // if reached max capacity and we've just reached it\n        if (atMaxCapacity && addAction) {\n            // get interaction type\n            var interactionMethod = addAction.data.interactionMethod;\n\n            // hide label\n            label.opacity = 0;\n\n            if (isMultiItem) {\n                label.translateY = -40;\n            } else {\n                if (interactionMethod === InteractionMethod.API) {\n                    label.translateX = 40;\n                } else if (interactionMethod === InteractionMethod.BROWSE) {\n                    label.translateY = 40;\n                } else {\n                    label.translateY = 30;\n                }\n            }\n        } else if (!atMaxCapacity) {\n            label.opacity = 1;\n            label.translateX = 0;\n            label.translateY = 0;\n        }\n\n        var listItemMargin = calculateListItemMargin(root);\n\n        var listHeight = calculateListHeight(root);\n\n        var labelHeight = label.rect.element.height;\n        var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n        var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n        var listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n        var visualHeight =\n            currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n        var boundsHeight =\n            currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n        // link list to label bottom position\n        list.translateY =\n            Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n\n        if (aspectRatio) {\n            // fixed aspect ratio\n\n            // calculate height based on width\n            var width = root.rect.element.width;\n            var height = width * aspectRatio;\n\n            // clear history if aspect ratio has changed\n            if (aspectRatio !== root.ref.previousAspectRatio) {\n                root.ref.previousAspectRatio = aspectRatio;\n                root.ref.updateHistory = [];\n            }\n\n            // remember this width\n            var history = root.ref.updateHistory;\n            history.push(width);\n\n            var MAX_BOUNCES = 2;\n            if (history.length > MAX_BOUNCES * 2) {\n                var l = history.length;\n                var bottom = l - 10;\n                var bounces = 0;\n                for (var i = l; i >= bottom; i--) {\n                    if (history[i] === history[i - 2]) {\n                        bounces++;\n                    }\n\n                    if (bounces >= MAX_BOUNCES) {\n                        // dont adjust height\n                        return;\n                    }\n                }\n            }\n\n            // fix height of panel so it adheres to aspect ratio\n            panel.scalable = false;\n            panel.height = height;\n\n            // available height for list\n            var listAvailableHeight =\n                // the height of the panel minus the label height\n                height -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            if (listHeight.visual > listAvailableHeight) {\n                list.overflow = listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = height;\n        } else if (bounds.fixedHeight) {\n            // fixed height\n\n            // fix height of panel\n            panel.scalable = false;\n\n            // available height for list\n            var _listAvailableHeight =\n                // the height of the panel minus the label height\n                bounds.fixedHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height\n            if (listHeight.visual > _listAvailableHeight) {\n                list.overflow = _listAvailableHeight;\n            } else {\n                list.overflow = null;\n            }\n\n            // no need to set container bounds as these are handles by CSS fixed height\n        } else if (bounds.cappedHeight) {\n            // max-height\n\n            // not a fixed height panel\n            var isCappedHeight = visualHeight >= bounds.cappedHeight;\n            var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n            panel.scalable = true;\n            panel.height = isCappedHeight\n                ? panelHeight\n                : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n            // available height for list\n            var _listAvailableHeight2 =\n                // the height of the panel minus the label height\n                panelHeight -\n                currentLabelHeight -\n                // the room we leave open between the end of the list and the panel bottom\n                (listMarginBottom - listItemMargin.bottom) -\n                // if we're full we need to leave some room between the top of the panel and the list\n                (atMaxCapacity ? listMarginTop : 0);\n\n            // set list height (if is overflowing)\n            if (visualHeight > bounds.cappedHeight && listHeight.visual > _listAvailableHeight2) {\n                list.overflow = _listAvailableHeight2;\n            } else {\n                list.overflow = null;\n            }\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.min(\n                bounds.cappedHeight,\n                boundsHeight - listItemMargin.top - listItemMargin.bottom\n            );\n        } else {\n            // flexible height\n\n            // not a fixed height panel\n            var itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n            panel.scalable = true;\n            panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n            // set container bounds (so pushes siblings downwards)\n            root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n        }\n\n        // move credits to bottom\n        if (root.ref.credits && panel.heightCurrent)\n            root.ref.credits.style.transform = 'translateY(' + panel.heightCurrent + 'px)';\n    };\n\n    var calculateListItemMargin = function calculateListItemMargin(root) {\n        var item = root.ref.list.childViews[0].childViews[0];\n        return item\n            ? {\n                  top: item.rect.element.marginTop,\n                  bottom: item.rect.element.marginBottom,\n              }\n            : {\n                  top: 0,\n                  bottom: 0,\n              };\n    };\n\n    var calculateListHeight = function calculateListHeight(root) {\n        var visual = 0;\n        var bounds = 0;\n\n        // get file list reference\n        var scrollList = root.ref.list;\n        var itemList = scrollList.childViews[0];\n        var visibleChildren = itemList.childViews.filter(function(child) {\n            return child.rect.element.height;\n        });\n        var children = root\n            .query('GET_ACTIVE_ITEMS')\n            .map(function(item) {\n                return visibleChildren.find(function(child) {\n                    return child.id === item.id;\n                });\n            })\n            .filter(function(item) {\n                return item;\n            });\n\n        // no children, done!\n        if (children.length === 0) return { visual: visual, bounds: bounds };\n\n        var horizontalSpace = itemList.rect.element.width;\n        var dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n\n        var childRect = children[0].rect.element;\n\n        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n        var itemWidth = childRect.width + itemHorizontalMargin;\n        var itemHeight = childRect.height + itemVerticalMargin;\n\n        var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n        var removedItem = children.find(function(child) {\n            return child.markedForRemoval && child.opacity < 0.45;\n        })\n            ? -1\n            : 0;\n        var verticalItemCount = children.length + newItem + removedItem;\n        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n        // stack\n        if (itemsPerRow === 1) {\n            children.forEach(function(item) {\n                var height = item.rect.element.height + itemVerticalMargin;\n                bounds += height;\n                visual += height * item.opacity;\n            });\n        }\n        // grid\n        else {\n            bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n            visual = bounds;\n        }\n\n        return { visual: visual, bounds: bounds };\n    };\n\n    var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(root) {\n        var height = root.ref.measureHeight || null;\n        var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n        var fixedHeight = height === 0 ? null : height;\n\n        return {\n            cappedHeight: cappedHeight,\n            fixedHeight: fixedHeight,\n        };\n    };\n\n    var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n        var allowReplace = root.query('GET_ALLOW_REPLACE');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n        var totalItems = root.query('GET_TOTAL_ITEMS');\n        var maxItems = root.query('GET_MAX_FILES');\n\n        // total amount of items being dragged\n        var totalBrowseItems = items.length;\n\n        // if does not allow multiple items and dragging more than one item\n        if (!allowMultiple && totalBrowseItems > 1) {\n            root.dispatch('DID_THROW_MAX_FILES', {\n                source: items,\n                error: createResponse('warning', 0, 'Max files'),\n            });\n\n            return true;\n        }\n\n        // limit max items to one if not allowed to drop multiple items\n        maxItems = allowMultiple ? maxItems : 1;\n\n        if (!allowMultiple && allowReplace) {\n            // There is only one item, so there is room to replace or add an item\n            return false;\n        }\n\n        // no more room?\n        var hasMaxItems = isInt(maxItems);\n        if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n            root.dispatch('DID_THROW_MAX_FILES', {\n                source: items,\n                error: createResponse('warning', 0, 'Max files'),\n            });\n\n            return true;\n        }\n\n        return false;\n    };\n\n    var getDragIndex = function getDragIndex(list, children, position) {\n        var itemList = list.childViews[0];\n        return getItemIndexByPosition(itemList, children, {\n            left: position.scopeLeft - itemList.rect.element.left,\n            top:\n                position.scopeTop -\n                (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop),\n        });\n    };\n\n    /**\n     * Enable or disable file drop functionality\n     */\n    var toggleDrop = function toggleDrop(root) {\n        var isAllowed = root.query('GET_ALLOW_DROP');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.hopper) {\n            var hopper = createHopper(\n                root.element,\n                function(items) {\n                    // allow quick validation of dropped items\n                    var beforeDropFile =\n                        root.query('GET_BEFORE_DROP_FILE') ||\n                        function() {\n                            return true;\n                        };\n\n                    // all items should be validated by all filters as valid\n                    var dropValidation = root.query('GET_DROP_VALIDATION');\n                    return dropValidation\n                        ? items.every(function(item) {\n                              return (\n                                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                                      query: root.query,\n                                  }).every(function(result) {\n                                      return result === true;\n                                  }) && beforeDropFile(item)\n                              );\n                          })\n                        : true;\n                },\n                {\n                    filterItems: function filterItems(items) {\n                        var ignoredFiles = root.query('GET_IGNORED_FILES');\n                        return items.filter(function(item) {\n                            if (isFile(item)) {\n                                return !ignoredFiles.includes(item.name.toLowerCase());\n                            }\n                            return true;\n                        });\n                    },\n                    catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n                    requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT'),\n                }\n            );\n\n            hopper.onload = function(items, position) {\n                // get item children elements and sort based on list sort\n                var list = root.ref.list.childViews[0];\n                var visibleChildren = list.childViews.filter(function(child) {\n                    return child.rect.element.height;\n                });\n                var children = root\n                    .query('GET_ACTIVE_ITEMS')\n                    .map(function(item) {\n                        return visibleChildren.find(function(child) {\n                            return child.id === item.id;\n                        });\n                    })\n                    .filter(function(item) {\n                        return item;\n                    });\n\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // go\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: getDragIndex(root.ref.list, children, position),\n                        interactionMethod: InteractionMethod.DROP,\n                    });\n                });\n\n                root.dispatch('DID_DROP', { position: position });\n\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            hopper.ondragstart = function(position) {\n                root.dispatch('DID_START_DRAG', { position: position });\n            };\n\n            hopper.ondrag = debounce(function(position) {\n                root.dispatch('DID_DRAG', { position: position });\n            });\n\n            hopper.ondragend = function(position) {\n                root.dispatch('DID_END_DRAG', { position: position });\n            };\n\n            root.ref.hopper = hopper;\n\n            root.ref.drip = root.appendChildView(root.createChildView(drip));\n        } else if (!enabled && root.ref.hopper) {\n            root.ref.hopper.destroy();\n            root.ref.hopper = null;\n            root.removeChildView(root.ref.drip);\n        }\n    };\n\n    /**\n     * Enable or disable browse functionality\n     */\n    var toggleBrowse = function toggleBrowse(root, props) {\n        var isAllowed = root.query('GET_ALLOW_BROWSE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.browser) {\n            root.ref.browser = root.appendChildView(\n                root.createChildView(\n                    browser,\n                    Object.assign({}, props, {\n                        onload: function onload(items) {\n                            applyFilterChain('ADD_ITEMS', items, {\n                                dispatch: root.dispatch,\n                            }).then(function(queue) {\n                                // these files don't fit so stop here\n                                if (exceedsMaxFiles(root, queue)) return false;\n\n                                // add items!\n                                root.dispatch('ADD_ITEMS', {\n                                    items: queue,\n                                    index: -1,\n                                    interactionMethod: InteractionMethod.BROWSE,\n                                });\n                            });\n                        },\n                    })\n                ),\n\n                0\n            );\n        } else if (!enabled && root.ref.browser) {\n            root.removeChildView(root.ref.browser);\n            root.ref.browser = null;\n        }\n    };\n\n    /**\n     * Enable or disable paste functionality\n     */\n    var togglePaste = function togglePaste(root) {\n        var isAllowed = root.query('GET_ALLOW_PASTE');\n        var isDisabled = root.query('GET_DISABLED');\n        var enabled = isAllowed && !isDisabled;\n        if (enabled && !root.ref.paster) {\n            root.ref.paster = createPaster();\n            root.ref.paster.onload = function(items) {\n                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(\n                    queue\n                ) {\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n\n                    // add items!\n                    root.dispatch('ADD_ITEMS', {\n                        items: queue,\n                        index: -1,\n                        interactionMethod: InteractionMethod.PASTE,\n                    });\n                });\n            };\n        } else if (!enabled && root.ref.paster) {\n            root.ref.paster.destroy();\n            root.ref.paster = null;\n        }\n    };\n\n    /**\n     * Route actions\n     */\n    var route$5 = createRoute({\n        DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n            var root = _ref5.root,\n                props = _ref5.props;\n            toggleBrowse(root, props);\n        },\n        DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n            var root = _ref6.root;\n            toggleDrop(root);\n        },\n        DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n            var root = _ref7.root;\n            togglePaste(root);\n        },\n        DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n            var root = _ref8.root,\n                props = _ref8.props;\n            toggleDrop(root);\n            togglePaste(root);\n            toggleBrowse(root, props);\n            var isDisabled = root.query('GET_DISABLED');\n            if (isDisabled) {\n                root.element.dataset.disabled = 'disabled';\n            } else {\n                // delete root.element.dataset.disabled; <= this does not work on iOS 10\n                root.element.removeAttribute('data-disabled');\n            }\n        },\n    });\n\n    var root = createView({\n        name: 'root',\n        read: function read(_ref9) {\n            var root = _ref9.root;\n            if (root.ref.measure) {\n                root.ref.measureHeight = root.ref.measure.offsetHeight;\n            }\n        },\n        create: create$e,\n        write: write$9,\n        destroy: function destroy(_ref10) {\n            var root = _ref10.root;\n            if (root.ref.paster) {\n                root.ref.paster.destroy();\n            }\n            if (root.ref.hopper) {\n                root.ref.hopper.destroy();\n            }\n            root.element.removeEventListener('touchmove', prevent);\n            root.element.removeEventListener('gesturestart', prevent);\n        },\n        mixins: {\n            styles: ['height'],\n        },\n    });\n\n    // creates the app\n    var createApp = function createApp() {\n        var initialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // let element\n        var originalElement = null;\n\n        // get default options\n        var defaultOptions = getOptions();\n\n        // create the data store, this will contain all our app info\n        var store = createStore(\n            // initial state (should be serializable)\n            createInitialState(defaultOptions),\n\n            // queries\n            [queries, createOptionQueries(defaultOptions)],\n\n            // action handlers\n            [actions, createOptionActions(defaultOptions)]\n        );\n\n        // set initial options\n        store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n        // kick thread if visibility changes\n        var visibilityHandler = function visibilityHandler() {\n            if (document.hidden) return;\n            store.dispatch('KICK');\n        };\n        document.addEventListener('visibilitychange', visibilityHandler);\n\n        // re-render on window resize start and finish\n        var resizeDoneTimer = null;\n        var isResizing = false;\n        var isResizingHorizontally = false;\n        var initialWindowWidth = null;\n        var currentWindowWidth = null;\n        var resizeHandler = function resizeHandler() {\n            if (!isResizing) {\n                isResizing = true;\n            }\n            clearTimeout(resizeDoneTimer);\n            resizeDoneTimer = setTimeout(function() {\n                isResizing = false;\n                initialWindowWidth = null;\n                currentWindowWidth = null;\n                if (isResizingHorizontally) {\n                    isResizingHorizontally = false;\n                    store.dispatch('DID_STOP_RESIZE');\n                }\n            }, 500);\n        };\n        window.addEventListener('resize', resizeHandler);\n\n        // render initial view\n        var view = root(store, { id: getUniqueId() });\n\n        //\n        // PRIVATE API -------------------------------------------------------------------------------------\n        //\n        var isResting = false;\n        var isHidden = false;\n\n        var readWriteApi = {\n            // necessary for update loop\n\n            /**\n             * Reads from dom (never call manually)\n             * @private\n             */\n            _read: function _read() {\n                // test if we're resizing horizontally\n                // TODO: see if we can optimize this by measuring root rect\n                if (isResizing) {\n                    currentWindowWidth = window.innerWidth;\n                    if (!initialWindowWidth) {\n                        initialWindowWidth = currentWindowWidth;\n                    }\n\n                    if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                        store.dispatch('DID_START_RESIZE');\n                        isResizingHorizontally = true;\n                    }\n                }\n\n                if (isHidden && isResting) {\n                    // test if is no longer hidden\n                    isResting = view.element.offsetParent === null;\n                }\n\n                // if resting, no need to read as numbers will still all be correct\n                if (isResting) return;\n\n                // read view data\n                view._read();\n\n                // if is hidden we need to know so we exit rest mode when revealed\n                isHidden = view.rect.element.hidden;\n            },\n\n            /**\n             * Writes to dom (never call manually)\n             * @private\n             */\n            _write: function _write(ts) {\n                // get all actions from store\n                var actions = store\n                    .processActionQueue()\n\n                    // filter out set actions (these will automatically trigger DID_SET)\n                    .filter(function(action) {\n                        return !/^SET_/.test(action.type);\n                    });\n\n                // if was idling and no actions stop here\n                if (isResting && !actions.length) return;\n\n                // some actions might trigger events\n                routeActionsToEvents(actions);\n\n                // update the view\n                isResting = view._write(ts, actions, isResizingHorizontally);\n\n                // will clean up all archived items\n                removeReleasedItems(store.query('GET_ITEMS'));\n\n                // now idling\n                if (isResting) {\n                    store.processDispatchQueue();\n                }\n            },\n        };\n\n        //\n        // EXPOSE EVENTS -------------------------------------------------------------------------------------\n        //\n        var createEvent = function createEvent(name) {\n            return function(data) {\n                // create default event\n                var event = {\n                    type: name,\n                };\n\n                // no data to add\n                if (!data) {\n                    return event;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('error')) {\n                    event.error = data.error ? Object.assign({}, data.error) : null;\n                }\n\n                if (data.status) {\n                    event.status = Object.assign({}, data.status);\n                }\n\n                if (data.file) {\n                    event.output = data.file;\n                }\n\n                // only source is available, else add item if possible\n                if (data.source) {\n                    event.file = data.source;\n                } else if (data.item || data.id) {\n                    var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n                    event.file = item ? createItemAPI(item) : null;\n                }\n\n                // map all items in a possible items array\n                if (data.items) {\n                    event.items = data.items.map(createItemAPI);\n                }\n\n                // if this is a progress event add the progress amount\n                if (/progress/.test(name)) {\n                    event.progress = data.progress;\n                }\n\n                // copy relevant props\n                if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n                    event.origin = data.origin;\n                    event.target = data.target;\n                }\n\n                return event;\n            };\n        };\n\n        var eventRoutes = {\n            DID_DESTROY: createEvent('destroy'),\n\n            DID_INIT: createEvent('init'),\n\n            DID_THROW_MAX_FILES: createEvent('warning'),\n\n            DID_INIT_ITEM: createEvent('initfile'),\n            DID_START_ITEM_LOAD: createEvent('addfilestart'),\n            DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n            DID_LOAD_ITEM: createEvent('addfile'),\n\n            DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n            DID_THROW_ITEM_REMOVE_ERROR: [createEvent('error'), createEvent('removefile')],\n\n            DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n            DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n            DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n            DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n            DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n            DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n            DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n            DID_THROW_ITEM_PROCESSING_ERROR: [createEvent('error'), createEvent('processfile')],\n\n            DID_REMOVE_ITEM: createEvent('removefile'),\n\n            DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n            DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n            DID_REORDER_ITEMS: createEvent('reorderfiles'),\n        };\n\n        var exposeEvent = function exposeEvent(event) {\n            // create event object to be dispatched\n            var detail = Object.assign({ pond: exports }, event);\n            delete detail.type;\n            view.element.dispatchEvent(\n                new CustomEvent('FilePond:' + event.type, {\n                    // event info\n                    detail: detail,\n\n                    // event behaviour\n                    bubbles: true,\n                    cancelable: true,\n                    composed: true, // triggers listeners outside of shadow root\n                })\n            );\n\n            // event object to params used for `on()` event handlers and callbacks `oninit()`\n            var params = [];\n\n            // if is possible error event, make it the first param\n            if (event.hasOwnProperty('error')) {\n                params.push(event.error);\n            }\n\n            // file is always section\n            if (event.hasOwnProperty('file')) {\n                params.push(event.file);\n            }\n\n            // append other props\n            var filtered = ['type', 'error', 'file'];\n            Object.keys(event)\n                .filter(function(key) {\n                    return !filtered.includes(key);\n                })\n                .forEach(function(key) {\n                    return params.push(event[key]);\n                });\n\n            // on(type, () => { })\n            exports.fire.apply(exports, [event.type].concat(params));\n\n            // oninit = () => {}\n            var handler = store.query('GET_ON' + event.type.toUpperCase());\n            if (handler) {\n                handler.apply(void 0, params);\n            }\n        };\n\n        var routeActionsToEvents = function routeActionsToEvents(actions) {\n            if (!actions.length) return;\n            actions\n                .filter(function(action) {\n                    return eventRoutes[action.type];\n                })\n                .forEach(function(action) {\n                    var routes = eventRoutes[action.type];\n                    (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n                        // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                        if (action.type === 'DID_INIT_ITEM') {\n                            exposeEvent(route(action.data));\n                        } else {\n                            setTimeout(function() {\n                                exposeEvent(route(action.data));\n                            }, 0);\n                        }\n                    });\n                });\n        };\n\n        //\n        // PUBLIC API -------------------------------------------------------------------------------------\n        //\n        var setOptions = function setOptions(options) {\n            return store.dispatch('SET_OPTIONS', { options: options });\n        };\n\n        var getFile = function getFile(query) {\n            return store.query('GET_ACTIVE_ITEM', query);\n        };\n\n        var prepareFile = function prepareFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PREPARE', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var addFile = function addFile(source) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new Promise(function(resolve, reject) {\n                addFiles([{ source: source, options: options }], { index: options.index })\n                    .then(function(items) {\n                        return resolve(items && items[0]);\n                    })\n                    .catch(reject);\n            });\n        };\n\n        var isFilePondFile = function isFilePondFile(obj) {\n            return obj.file && obj.id;\n        };\n\n        var removeFile = function removeFile(query, options) {\n            // if only passed options\n            if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n                options = query;\n                query = undefined;\n            }\n\n            // request item removal\n            store.dispatch('REMOVE_ITEM', Object.assign({}, options, { query: query }));\n\n            // see if item has been removed\n            return store.query('GET_ACTIVE_ITEM', query) === null;\n        };\n\n        var addFiles = function addFiles() {\n            for (\n                var _len = arguments.length, args = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                args[_key] = arguments[_key];\n            }\n            return new Promise(function(resolve, reject) {\n                var sources = [];\n                var options = {};\n\n                // user passed a sources array\n                if (isArray(args[0])) {\n                    sources.push.apply(sources, args[0]);\n                    Object.assign(options, args[1] || {});\n                } else {\n                    // user passed sources as arguments, last one might be options object\n                    var lastArgument = args[args.length - 1];\n                    if (typeof lastArgument === 'object' && !(lastArgument instanceof Blob)) {\n                        Object.assign(options, args.pop());\n                    }\n\n                    // add rest to sources\n                    sources.push.apply(sources, args);\n                }\n\n                store.dispatch('ADD_ITEMS', {\n                    items: sources,\n                    index: options.index,\n                    interactionMethod: InteractionMethod.API,\n                    success: resolve,\n                    failure: reject,\n                });\n            });\n        };\n\n        var getFiles = function getFiles() {\n            return store.query('GET_ACTIVE_ITEMS');\n        };\n\n        var processFile = function processFile(query) {\n            return new Promise(function(resolve, reject) {\n                store.dispatch('REQUEST_ITEM_PROCESSING', {\n                    query: query,\n                    success: function success(item) {\n                        resolve(item);\n                    },\n                    failure: function failure(error) {\n                        reject(error);\n                    },\n                });\n            });\n        };\n\n        var prepareFiles = function prepareFiles() {\n            for (\n                var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n                _key2 < _len2;\n                _key2++\n            ) {\n                args[_key2] = arguments[_key2];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            var items = queries.length ? queries : getFiles();\n            return Promise.all(items.map(prepareFile));\n        };\n\n        var processFiles = function processFiles() {\n            for (\n                var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n                _key3 < _len3;\n                _key3++\n            ) {\n                args[_key3] = arguments[_key3];\n            }\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n            if (!queries.length) {\n                var files = getFiles().filter(function(item) {\n                    return (\n                        !(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) &&\n                        item.status !== ItemStatus.PROCESSING &&\n                        item.status !== ItemStatus.PROCESSING_COMPLETE &&\n                        item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n                    );\n                });\n\n                return Promise.all(files.map(processFile));\n            }\n            return Promise.all(queries.map(processFile));\n        };\n\n        var removeFiles = function removeFiles() {\n            for (\n                var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n                _key4 < _len4;\n                _key4++\n            ) {\n                args[_key4] = arguments[_key4];\n            }\n\n            var queries = Array.isArray(args[0]) ? args[0] : args;\n\n            var options;\n            if (typeof queries[queries.length - 1] === 'object') {\n                options = queries.pop();\n            } else if (Array.isArray(args[0])) {\n                options = args[1];\n            }\n\n            var files = getFiles();\n\n            if (!queries.length)\n                return Promise.all(\n                    files.map(function(file) {\n                        return removeFile(file, options);\n                    })\n                );\n\n            // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n            var mappedQueries = queries\n                .map(function(query) {\n                    return isNumber(query) ? (files[query] ? files[query].id : null) : query;\n                })\n                .filter(function(query) {\n                    return query;\n                });\n\n            return mappedQueries.map(function(q) {\n                return removeFile(q, options);\n            });\n        };\n\n        var exports = Object.assign(\n            {},\n\n            on(),\n            {},\n\n            readWriteApi,\n            {},\n\n            createOptionAPI(store, defaultOptions),\n            {\n                /**\n                 * Override options defined in options object\n                 * @param options\n                 */\n                setOptions: setOptions,\n\n                /**\n                 * Load the given file\n                 * @param source - the source of the file (either a File, base64 data uri or url)\n                 * @param options - object, { index: 0 }\n                 */\n                addFile: addFile,\n\n                /**\n                 * Load the given files\n                 * @param sources - the sources of the files to load\n                 * @param options - object, { index: 0 }\n                 */\n                addFiles: addFiles,\n\n                /**\n                 * Returns the file objects matching the given query\n                 * @param query { string, number, null }\n                 */\n                getFile: getFile,\n\n                /**\n                 * Upload file with given name\n                 * @param query { string, number, null  }\n                 */\n                processFile: processFile,\n\n                /**\n                 * Request prepare output for file with given name\n                 * @param query { string, number, null  }\n                 */\n                prepareFile: prepareFile,\n\n                /**\n                 * Removes a file by its name\n                 * @param query { string, number, null  }\n                 */\n                removeFile: removeFile,\n\n                /**\n                 * Moves a file to a new location in the files list\n                 */\n                moveFile: function moveFile(query, index) {\n                    return store.dispatch('MOVE_ITEM', { query: query, index: index });\n                },\n\n                /**\n                 * Returns all files (wrapped in public api)\n                 */\n                getFiles: getFiles,\n\n                /**\n                 * Starts uploading all files\n                 */\n                processFiles: processFiles,\n\n                /**\n                 * Clears all files from the files list\n                 */\n                removeFiles: removeFiles,\n\n                /**\n                 * Starts preparing output of all files\n                 */\n                prepareFiles: prepareFiles,\n\n                /**\n                 * Sort list of files\n                 */\n                sort: function sort(compare) {\n                    return store.dispatch('SORT', { compare: compare });\n                },\n\n                /**\n                 * Browse the file system for a file\n                 */\n                browse: function browse() {\n                    // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n                    var input = view.element.querySelector('input[type=file]');\n                    if (input) {\n                        input.click();\n                    }\n                },\n\n                /**\n                 * Destroys the app\n                 */\n                destroy: function destroy() {\n                    // request destruction\n                    exports.fire('destroy', view.element);\n\n                    // stop active processes (file uploads, fetches, stuff like that)\n                    // loop over items and depending on states call abort for ongoing processes\n                    store.dispatch('ABORT_ALL');\n\n                    // destroy view\n                    view._destroy();\n\n                    // stop listening to resize\n                    window.removeEventListener('resize', resizeHandler);\n\n                    // stop listening to the visiblitychange event\n                    document.removeEventListener('visibilitychange', visibilityHandler);\n\n                    // dispatch destroy\n                    store.dispatch('DID_DESTROY');\n                },\n\n                /**\n                 * Inserts the plugin before the target element\n                 */\n                insertBefore: function insertBefore$1(element) {\n                    return insertBefore(view.element, element);\n                },\n\n                /**\n                 * Inserts the plugin after the target element\n                 */\n                insertAfter: function insertAfter$1(element) {\n                    return insertAfter(view.element, element);\n                },\n\n                /**\n                 * Appends the plugin to the target element\n                 */\n                appendTo: function appendTo(element) {\n                    return element.appendChild(view.element);\n                },\n\n                /**\n                 * Replaces an element with the app\n                 */\n                replaceElement: function replaceElement(element) {\n                    // insert the app before the element\n                    insertBefore(view.element, element);\n\n                    // remove the original element\n                    element.parentNode.removeChild(element);\n\n                    // remember original element\n                    originalElement = element;\n                },\n\n                /**\n                 * Restores the original element\n                 */\n                restoreElement: function restoreElement() {\n                    if (!originalElement) {\n                        return; // no element to restore\n                    }\n\n                    // restore original element\n                    insertAfter(originalElement, view.element);\n\n                    // remove our element\n                    view.element.parentNode.removeChild(view.element);\n\n                    // remove reference\n                    originalElement = null;\n                },\n\n                /**\n                 * Returns true if the app root is attached to given element\n                 * @param element\n                 */\n                isAttachedTo: function isAttachedTo(element) {\n                    return view.element === element || originalElement === element;\n                },\n\n                /**\n                 * Returns the root element\n                 */\n                element: {\n                    get: function get() {\n                        return view.element;\n                    },\n                },\n\n                /**\n                 * Returns the current pond status\n                 */\n                status: {\n                    get: function get() {\n                        return store.query('GET_STATUS');\n                    },\n                },\n            }\n        );\n\n        // Done!\n        store.dispatch('DID_INIT');\n\n        // create actual api object\n        return createObject(exports);\n    };\n\n    var createAppObject = function createAppObject() {\n        var customOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // default options\n        var defaultOptions = {};\n        forin(getOptions(), function(key, value) {\n            defaultOptions[key] = value[0];\n        });\n\n        // set app options\n        var app = createApp(\n            Object.assign(\n                {},\n\n                defaultOptions,\n                {},\n\n                customOptions\n            )\n        );\n\n        // return the plugin instance\n        return app;\n    };\n\n    var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n        return string.charAt(0).toLowerCase() + string.slice(1);\n    };\n\n    var attributeNameToPropertyName = function attributeNameToPropertyName(attributeName) {\n        return toCamels(attributeName.replace(/^data-/, ''));\n    };\n\n    var mapObject = function mapObject(object, propertyMap) {\n        // remove unwanted\n        forin(propertyMap, function(selector, mapping) {\n            forin(object, function(property, value) {\n                // create regexp shortcut\n                var selectorRegExp = new RegExp(selector);\n\n                // tests if\n                var matches = selectorRegExp.test(property);\n\n                // no match, skip\n                if (!matches) {\n                    return;\n                }\n\n                // if there's a mapping, the original property is always removed\n                delete object[property];\n\n                // should only remove, we done!\n                if (mapping === false) {\n                    return;\n                }\n\n                // move value to new property\n                if (isString(mapping)) {\n                    object[mapping] = value;\n                    return;\n                }\n\n                // move to group\n                var group = mapping.group;\n                if (isObject(mapping) && !object[group]) {\n                    object[group] = {};\n                }\n\n                object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ''))] = value;\n            });\n\n            // do submapping\n            if (mapping.mapping) {\n                mapObject(object[mapping.group], mapping.mapping);\n            }\n        });\n    };\n\n    var getAttributesAsObject = function getAttributesAsObject(node) {\n        var attributeMapping =\n            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        // turn attributes into object\n        var attributes = [];\n        forin(node.attributes, function(index) {\n            attributes.push(node.attributes[index]);\n        });\n\n        var output = attributes\n            .filter(function(attribute) {\n                return attribute.name;\n            })\n            .reduce(function(obj, attribute) {\n                var value = attr(node, attribute.name);\n\n                obj[attributeNameToPropertyName(attribute.name)] =\n                    value === attribute.name ? true : value;\n                return obj;\n            }, {});\n\n        // do mapping of object properties\n        mapObject(output, attributeMapping);\n\n        return output;\n    };\n\n    var createAppAtElement = function createAppAtElement(element) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // how attributes of the input element are mapped to the options for the plugin\n        var attributeMapping = {\n            // translate to other name\n            '^class$': 'className',\n            '^multiple$': 'allowMultiple',\n            '^capture$': 'captureMethod',\n            '^webkitdirectory$': 'allowDirectoriesOnly',\n\n            // group under single property\n            '^server': {\n                group: 'server',\n                mapping: {\n                    '^process': {\n                        group: 'process',\n                    },\n\n                    '^revert': {\n                        group: 'revert',\n                    },\n\n                    '^fetch': {\n                        group: 'fetch',\n                    },\n\n                    '^restore': {\n                        group: 'restore',\n                    },\n\n                    '^load': {\n                        group: 'load',\n                    },\n                },\n            },\n\n            // don't include in object\n            '^type$': false,\n            '^files$': false,\n        };\n\n        // add additional option translators\n        applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n        // create final options object by setting options object and then overriding options supplied on element\n        var mergedOptions = Object.assign({}, options);\n\n        var attributeOptions = getAttributesAsObject(\n            element.nodeName === 'FIELDSET' ? element.querySelector('input[type=file]') : element,\n            attributeMapping\n        );\n\n        // merge with options object\n        Object.keys(attributeOptions).forEach(function(key) {\n            if (isObject(attributeOptions[key])) {\n                if (!isObject(mergedOptions[key])) {\n                    mergedOptions[key] = {};\n                }\n                Object.assign(mergedOptions[key], attributeOptions[key]);\n            } else {\n                mergedOptions[key] = attributeOptions[key];\n            }\n        });\n\n        // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n        // these will then be automatically set to the initial files\n        mergedOptions.files = (options.files || []).concat(\n            Array.from(element.querySelectorAll('input:not([type=file])')).map(function(input) {\n                return {\n                    source: input.value,\n                    options: {\n                        type: input.dataset.type,\n                    },\n                };\n            })\n        );\n\n        // build plugin\n        var app = createAppObject(mergedOptions);\n\n        // add already selected files\n        if (element.files) {\n            Array.from(element.files).forEach(function(file) {\n                app.addFile(file);\n            });\n        }\n\n        // replace the target element\n        app.replaceElement(element);\n\n        // expose\n        return app;\n    };\n\n    // if an element is passed, we create the instance at that element, if not, we just create an up object\n    var createApp$1 = function createApp() {\n        return isNode(arguments.length <= 0 ? undefined : arguments[0])\n            ? createAppAtElement.apply(void 0, arguments)\n            : createAppObject.apply(void 0, arguments);\n    };\n\n    var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n    var createAppAPI = function createAppAPI(app) {\n        var api = {};\n\n        copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n        return api;\n    };\n\n    /**\n     * Replaces placeholders in given string with replacements\n     * @param string - \"Foo {bar}\"\"\n     * @param replacements - { \"bar\": 10 }\n     */\n    var replaceInString = function replaceInString(string, replacements) {\n        return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n            return replacements[group];\n        });\n    };\n\n    var createWorker = function createWorker(fn) {\n        var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n            type: 'application/javascript',\n        });\n\n        var workerURL = URL.createObjectURL(workerBlob);\n        var worker = new Worker(workerURL);\n\n        return {\n            transfer: function transfer(message, cb) {},\n            post: function post(message, cb, transferList) {\n                var id = getUniqueId();\n\n                worker.onmessage = function(e) {\n                    if (e.data.id === id) {\n                        cb(e.data.message);\n                    }\n                };\n\n                worker.postMessage(\n                    {\n                        id: id,\n                        message: message,\n                    },\n\n                    transferList\n                );\n            },\n            terminate: function terminate() {\n                worker.terminate();\n                URL.revokeObjectURL(workerURL);\n            },\n        };\n    };\n\n    var loadImage = function loadImage(url) {\n        return new Promise(function(resolve, reject) {\n            var img = new Image();\n            img.onload = function() {\n                resolve(img);\n            };\n            img.onerror = function(e) {\n                reject(e);\n            };\n            img.src = url;\n        });\n    };\n\n    var renameFile = function renameFile(file, name) {\n        var renamedFile = file.slice(0, file.size, file.type);\n        renamedFile.lastModifiedDate = file.lastModifiedDate;\n        renamedFile.name = name;\n        return renamedFile;\n    };\n\n    var copyFile = function copyFile(file) {\n        return renameFile(file, file.name);\n    };\n\n    // already registered plugins (can't register twice)\n    var registeredPlugins = [];\n\n    // pass utils to plugin\n    var createAppPlugin = function createAppPlugin(plugin) {\n        // already registered\n        if (registeredPlugins.includes(plugin)) {\n            return;\n        }\n\n        // remember this plugin\n        registeredPlugins.push(plugin);\n\n        // setup!\n        var pluginOutline = plugin({\n            addFilter: addFilter,\n            utils: {\n                Type: Type,\n                forin: forin,\n                isString: isString,\n                isFile: isFile,\n                toNaturalFileSize: toNaturalFileSize,\n                replaceInString: replaceInString,\n                getExtensionFromFilename: getExtensionFromFilename,\n                getFilenameWithoutExtension: getFilenameWithoutExtension,\n                guesstimateMimeType: guesstimateMimeType,\n                getFileFromBlob: getFileFromBlob,\n                getFilenameFromURL: getFilenameFromURL,\n                createRoute: createRoute,\n                createWorker: createWorker,\n                createView: createView,\n                createItemAPI: createItemAPI,\n                loadImage: loadImage,\n                copyFile: copyFile,\n                renameFile: renameFile,\n                createBlob: createBlob,\n                applyFilterChain: applyFilterChain,\n                text: text,\n                getNumericAspectRatioFromString: getNumericAspectRatioFromString,\n            },\n\n            views: {\n                fileActionButton: fileActionButton,\n            },\n        });\n\n        // add plugin options to default options\n        extendDefaultOptions(pluginOutline.options);\n    };\n\n    // feature detection used by supported() method\n    var isOperaMini = function isOperaMini() {\n        return Object.prototype.toString.call(window.operamini) === '[object OperaMini]';\n    };\n    var hasPromises = function hasPromises() {\n        return 'Promise' in window;\n    };\n    var hasBlobSlice = function hasBlobSlice() {\n        return 'slice' in Blob.prototype;\n    };\n    var hasCreateObjectURL = function hasCreateObjectURL() {\n        return 'URL' in window && 'createObjectURL' in window.URL;\n    };\n    var hasVisibility = function hasVisibility() {\n        return 'visibilityState' in document;\n    };\n    var hasTiming = function hasTiming() {\n        return 'performance' in window;\n    }; // iOS 8.x\n    var hasCSSSupports = function hasCSSSupports() {\n        return 'supports' in (window.CSS || {});\n    }; // use to detect Safari 9+\n    var isIE11 = function isIE11() {\n        return /MSIE|Trident/.test(window.navigator.userAgent);\n    };\n\n    var supported = (function() {\n        // Runs immediately and then remembers result for subsequent calls\n        var isSupported =\n            // Has to be a browser\n            isBrowser() &&\n            // Can't run on Opera Mini due to lack of everything\n            !isOperaMini() &&\n            // Require these APIs to feature detect a modern browser\n            hasVisibility() &&\n            hasPromises() &&\n            hasBlobSlice() &&\n            hasCreateObjectURL() &&\n            hasTiming() &&\n            // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n            (hasCSSSupports() || isIE11());\n\n        return function() {\n            return isSupported;\n        };\n    })();\n\n    /**\n     * Plugin internal state (over all instances)\n     */\n    var state = {\n        // active app instances, used to redraw the apps and to find the later\n        apps: [],\n    };\n\n    // plugin name\n    var name = 'filepond';\n\n    /**\n     * Public Plugin methods\n     */\n    var fn = function fn() {};\n    exports.Status = {};\n    exports.FileStatus = {};\n    exports.FileOrigin = {};\n    exports.OptionTypes = {};\n    exports.create = fn;\n    exports.destroy = fn;\n    exports.parse = fn;\n    exports.find = fn;\n    exports.registerPlugin = fn;\n    exports.getOptions = fn;\n    exports.setOptions = fn;\n\n    // if not supported, no API\n    if (supported()) {\n        // start painter and fire load event\n        createPainter(\n            function() {\n                state.apps.forEach(function(app) {\n                    return app._read();\n                });\n            },\n            function(ts) {\n                state.apps.forEach(function(app) {\n                    return app._write(ts);\n                });\n            }\n        );\n\n        // fire loaded event so we know when FilePond is available\n        var dispatch = function dispatch() {\n            // let others know we have area ready\n            document.dispatchEvent(\n                new CustomEvent('FilePond:loaded', {\n                    detail: {\n                        supported: supported,\n                        create: exports.create,\n                        destroy: exports.destroy,\n                        parse: exports.parse,\n                        find: exports.find,\n                        registerPlugin: exports.registerPlugin,\n                        setOptions: exports.setOptions,\n                    },\n                })\n            );\n\n            // clean up event\n            document.removeEventListener('DOMContentLoaded', dispatch);\n        };\n\n        if (document.readyState !== 'loading') {\n            // move to back of execution queue, FilePond should have been exported by then\n            setTimeout(function() {\n                return dispatch();\n            }, 0);\n        } else {\n            document.addEventListener('DOMContentLoaded', dispatch);\n        }\n\n        // updates the OptionTypes object based on the current options\n        var updateOptionTypes = function updateOptionTypes() {\n            return forin(getOptions(), function(key, value) {\n                exports.OptionTypes[key] = value[1];\n            });\n        };\n\n        exports.Status = Object.assign({}, Status);\n        exports.FileOrigin = Object.assign({}, FileOrigin);\n        exports.FileStatus = Object.assign({}, ItemStatus);\n\n        exports.OptionTypes = {};\n        updateOptionTypes();\n\n        // create method, creates apps and adds them to the app array\n        exports.create = function create() {\n            var app = createApp$1.apply(void 0, arguments);\n            app.on('destroy', exports.destroy);\n            state.apps.push(app);\n            return createAppAPI(app);\n        };\n\n        // destroys apps and removes them from the app array\n        exports.destroy = function destroy(hook) {\n            // returns true if the app was destroyed successfully\n            var indexToRemove = state.apps.findIndex(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (indexToRemove >= 0) {\n                // remove from apps\n                var app = state.apps.splice(indexToRemove, 1)[0];\n\n                // restore original dom element\n                app.restoreElement();\n\n                return true;\n            }\n\n            return false;\n        };\n\n        // parses the given context for plugins (does not include the context element itself)\n        exports.parse = function parse(context) {\n            // get all possible hooks\n            var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n            // filter out already active hooks\n            var newHooks = matchedHooks.filter(function(newHook) {\n                return !state.apps.find(function(app) {\n                    return app.isAttachedTo(newHook);\n                });\n            });\n\n            // create new instance for each hook\n            return newHooks.map(function(hook) {\n                return exports.create(hook);\n            });\n        };\n\n        // returns an app based on the given element hook\n        exports.find = function find(hook) {\n            var app = state.apps.find(function(app) {\n                return app.isAttachedTo(hook);\n            });\n            if (!app) {\n                return null;\n            }\n            return createAppAPI(app);\n        };\n\n        // adds a plugin extension\n        exports.registerPlugin = function registerPlugin() {\n            for (\n                var _len = arguments.length, plugins = new Array(_len), _key = 0;\n                _key < _len;\n                _key++\n            ) {\n                plugins[_key] = arguments[_key];\n            }\n\n            // register plugins\n            plugins.forEach(createAppPlugin);\n\n            // update OptionTypes, each plugin might have extended the default options\n            updateOptionTypes();\n        };\n\n        exports.getOptions = function getOptions$1() {\n            var opts = {};\n            forin(getOptions(), function(key, value) {\n                opts[key] = value[0];\n            });\n            return opts;\n        };\n\n        exports.setOptions = function setOptions$1(opts) {\n            if (isObject(opts)) {\n                // update existing plugins\n                state.apps.forEach(function(app) {\n                    app.setOptions(opts);\n                });\n\n                // override defaults\n                setOptions(opts);\n            }\n\n            // return new options\n            return exports.getOptions();\n        };\n    }\n\n    exports.supported = supported;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRTtBQUNBLFVBQVUsQ0FFNEQ7QUFDdEUsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RCxTQUFTOztBQUVUO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQywyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhOztBQUVuQztBQUNBLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFD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NkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQsa0NBQWtDO0FBQzlGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx3QkFBd0IsMkJBQTJCO0FBQ25HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSSxJQUFJO0FBQzVELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRCx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTs7QUFFQTtBQUNBLDRFQUE0RSxvQkFBb0I7O0FBRWhHO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0Qzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFD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QUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQsYUFBYTtBQUNoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQuanM/ZDQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kIDQuMzIuNlxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZmFjdG9yeShleHBvcnRzKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSlcbiAgICAgICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSwgZmFjdG9yeSgoZ2xvYmFsLkZpbGVQb25kID0ge30pKSk7XG59KSh0aGlzLCBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGlzTm9kZSA9IGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVN0b3JlID0gZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIHZhciBxdWVyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgICAgIC8vIGNvbnRhaW5zIGFsbCBhY3Rpb25zIGZvciBuZXh0IGZyYW1lLCBpcyBjbGVhciB3aGVuIGFjdGlvbnMgYXJlIHJlcXVlc3RlZFxuICAgICAgICB2YXIgYWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcblxuICAgICAgICAvLyByZXR1cm5zIGEgZHVwbGljYXRlIG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGEgZHVwbGljYXRlIG9mIHRoZSBhY3Rpb25zIGFycmF5IGFuZCBjbGVhcnMgdGhlIGFjdGlvbnMgYXJyYXlcbiAgICAgICAgdmFyIHByb2Nlc3NBY3Rpb25RdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NBY3Rpb25RdWV1ZSgpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjb3B5IG9mIGFjdGlvbnMgcXVldWVcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChhY3Rpb25RdWV1ZSk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGFjdGlvbnMgcXVldWUgKHdlIGRvbid0IHdhbnQgbm8gZG91YmxlIGFjdGlvbnMpXG4gICAgICAgICAgICBhY3Rpb25RdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHJvY2Vzc2VzIGFjdGlvbnMgdGhhdCBtaWdodCBibG9jayB0aGUgbWFpbiBVSSB0aHJlYWRcbiAgICAgICAgdmFyIHByb2Nlc3NEaXNwYXRjaFF1ZXVlID0gZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoZGlzcGF0Y2hRdWV1ZSk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGFjdGlvbnMgcXVldWUgKHdlIGRvbid0IHdhbnQgbm8gZG91YmxlIGFjdGlvbnMpXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vIG5vdyBkaXNwYXRjaCB0aGVzZSBhY3Rpb25zXG4gICAgICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0eXBlLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2godHlwZSwgZGF0YSwgaXNCbG9ja2luZykge1xuICAgICAgICAgICAgLy8gaXMgYmxvY2tpbmcgYWN0aW9uIChzaG91bGQgbmV2ZXIgYmxvY2sgaWYgZG9jdW1lbnQgaXMgaGlkZGVuKVxuICAgICAgICAgICAgaWYgKGlzQmxvY2tpbmcgJiYgIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGFjdGlvbiBoYXMgYSBoYW5kbGVyLCBoYW5kbGUgdGhlIGFjdGlvblxuICAgICAgICAgICAgaWYgKGFjdGlvbkhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uSGFuZGxlcnNbdHlwZV0oZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdyBhZGQgYWN0aW9uXG4gICAgICAgICAgICBhY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcXVlcnkgPSBmdW5jdGlvbiBxdWVyeShzdHIpIHtcbiAgICAgICAgICAgIHZhciBfcXVlcnlIYW5kbGVzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlc1tzdHJdXG4gICAgICAgICAgICAgICAgPyAoX3F1ZXJ5SGFuZGxlcyA9IHF1ZXJ5SGFuZGxlcylbc3RyXS5hcHBseShfcXVlcnlIYW5kbGVzLCBhcmdzKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgICAgICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlOiBwcm9jZXNzQWN0aW9uUXVldWUsXG4gICAgICAgICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZTogcHJvY2Vzc0Rpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHF1ZXJ5SGFuZGxlcyA9IHt9O1xuICAgICAgICBxdWVyaWVzLmZvckVhY2goZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5SGFuZGxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KHN0YXRlKSwge30sIHF1ZXJ5SGFuZGxlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBhY3Rpb25IYW5kbGVycyA9IHt9O1xuICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb25IYW5kbGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbihkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSwge30sIGFjdGlvbkhhbmRsZXJzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9ialtwcm9wZXJ0eV0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBPYmplY3QuYXNzaWduKHt9LCBkZWZpbml0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBmb3JpbiA9IGZ1bmN0aW9uIGZvcmluKG9iaiwgY2IpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24gY3JlYXRlT2JqZWN0KGRlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBmb3JpbihkZWZpbml0aW9uLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbiAgICB2YXIgaXNTVkdFbGVtZW50ID0gZnVuY3Rpb24gaXNTVkdFbGVtZW50KHRhZykge1xuICAgICAgICByZXR1cm4gc3ZnRWxlbWVudHMuaW5jbHVkZXModGFnKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IGlzU1ZHRWxlbWVudCh0YWcpXG4gICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKVxuICAgICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc1NWR0VsZW1lbnQodGFnKSkge1xuICAgICAgICAgICAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yaW4oYXR0cmlidXRlcywgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHIoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcGFyZW50LmNoaWxkcmVuW2luZGV4XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmRDaGlsZFZpZXcgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZFZpZXcocGFyZW50LCBjaGlsZFZpZXdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2aWV3LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShpbmRleCwgMCwgdmlldyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVDaGlsZFZpZXcgPSBmdW5jdGlvbiByZW1vdmVDaGlsZFZpZXcocGFyZW50LCBjaGlsZFZpZXdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBjaGlsZCB2aWV3c1xuICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoY2hpbGRWaWV3cy5pbmRleE9mKHZpZXcpLCAxKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpZiAodmlldy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBJU19CUk9XU0VSID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfSkoKTtcbiAgICB2YXIgaXNCcm93c2VyID0gZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgICAgICByZXR1cm4gSVNfQlJPV1NFUjtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gaXNCcm93c2VyKCkgPyBjcmVhdGVFbGVtZW50KCdzdmcnKSA6IHt9O1xuICAgIHZhciBnZXRDaGlsZENvdW50ID1cbiAgICAgICAgJ2NoaWxkcmVuJyBpbiB0ZXN0RWxlbWVudFxuICAgICAgICAgICAgPyBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgdmFyIGdldFZpZXdSZWN0ID0gZnVuY3Rpb24gZ2V0Vmlld1JlY3QoZWxlbWVudFJlY3QsIGNoaWxkVmlld3MsIG9mZnNldCwgc2NhbGUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBvZmZzZXRbMF0gfHwgZWxlbWVudFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHRvcCA9IG9mZnNldFsxXSB8fCBlbGVtZW50UmVjdC50b3A7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyBlbGVtZW50UmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCAqIChzY2FsZVsxXSB8fCAxKTtcblxuICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgaXRzZWxmXG4gICAgICAgICAgICBlbGVtZW50OiBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50UmVjdCksXG5cbiAgICAgICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4sIGRvZXMgbm90IGluY2x1ZGUgYW55IG1hcmdpbnNcbiAgICAgICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IGVsZW1lbnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogZWxlbWVudFJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBlbGVtZW50UmVjdC5ib3R0b20sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuIGluY2x1ZGluZyBvd24gbWFyZ2luIGFuZCBjaGlsZCBtYXJnaW5zXG4gICAgICAgICAgICAvLyBtYXJnaW5zIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgd2UndmUgcmVjYWxjdWxhdGVkIHRoZSBzaXplXG4gICAgICAgICAgICBvdXRlcjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBleHBhbmQgcmVjdCB0byBmaXQgYWxsIGNoaWxkIHJlY3RhbmdsZXNcbiAgICAgICAgY2hpbGRWaWV3c1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNoaWxkVmlldy5pc1JlY3RJZ25vcmVkKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3LnJlY3Q7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGRWaWV3UmVjdCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZFJlY3QocmVjdC5pbm5lciwgT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRWaWV3UmVjdC5pbm5lcikpO1xuICAgICAgICAgICAgICAgIGV4cGFuZFJlY3QocmVjdC5vdXRlciwgT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRWaWV3UmVjdC5vdXRlcikpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGlubmVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5pbm5lcik7XG5cbiAgICAgICAgLy8gYXBwZW5kIGFkZGl0aW9uYWwgbWFyZ2luICh0b3AgYW5kIGxlZnQgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW4gdG9wIGFuZCBsZWZ0IGF1dG9tYXRpY2FsbHkpXG4gICAgICAgIHJlY3Qub3V0ZXIuYm90dG9tICs9IHJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b207XG4gICAgICAgIHJlY3Qub3V0ZXIucmlnaHQgKz0gcmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvdXRlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3Qub3V0ZXIpO1xuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwYW5kUmVjdCA9IGZ1bmN0aW9uIGV4cGFuZFJlY3QocGFyZW50LCBjaGlsZCkge1xuICAgICAgICAvLyBhZGp1c3QgZm9yIHBhcmVudCBvZmZzZXRcbiAgICAgICAgY2hpbGQudG9wICs9IHBhcmVudC50b3A7XG4gICAgICAgIGNoaWxkLnJpZ2h0ICs9IHBhcmVudC5sZWZ0O1xuICAgICAgICBjaGlsZC5ib3R0b20gKz0gcGFyZW50LnRvcDtcbiAgICAgICAgY2hpbGQubGVmdCArPSBwYXJlbnQubGVmdDtcblxuICAgICAgICBpZiAoY2hpbGQuYm90dG9tID4gcGFyZW50LmJvdHRvbSkge1xuICAgICAgICAgICAgcGFyZW50LmJvdHRvbSA9IGNoaWxkLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gY2hpbGQucmlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZVJlY3RTaXplID0gZnVuY3Rpb24gY2FsY3VsYXRlUmVjdFNpemUocmVjdCkge1xuICAgICAgICByZWN0LndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgIH07XG5cbiAgICB2YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBwb3NpdGlvbiBpcyBhdCBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eVxuICAgICAqIEBwYXJhbSBlcnJvck1hcmdpblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciB0aGVyZVlldCA9IGZ1bmN0aW9uIHRoZXJlWWV0KHBvc2l0aW9uLCBkZXN0aW5hdGlvbiwgdmVsb2NpdHkpIHtcbiAgICAgICAgdmFyIGVycm9yTWFyZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwLjAwMTtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiYgTWF0aC5hYnModmVsb2NpdHkpIDwgZXJyb3JNYXJnaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwcmluZyBhbmltYXRpb25cbiAgICAgKi9cbiAgICB2YXIgc3ByaW5nID1cbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGZ1bmN0aW9uIHNwcmluZygpIC8vIG1ldGhvZCBkZWZpbml0aW9uXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmJHN0aWZmbmVzcyA9IF9yZWYuc3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgIHN0aWZmbmVzcyA9IF9yZWYkc3RpZmZuZXNzID09PSB2b2lkIDAgPyAwLjUgOiBfcmVmJHN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICBfcmVmJGRhbXBpbmcgPSBfcmVmLmRhbXBpbmcsXG4gICAgICAgICAgICAgICAgZGFtcGluZyA9IF9yZWYkZGFtcGluZyA9PT0gdm9pZCAwID8gMC43NSA6IF9yZWYkZGFtcGluZyxcbiAgICAgICAgICAgICAgICBfcmVmJG1hc3MgPSBfcmVmLm1hc3MsXG4gICAgICAgICAgICAgICAgbWFzcyA9IF9yZWYkbWFzcyA9PT0gdm9pZCAwID8gMTAgOiBfcmVmJG1hc3M7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgdmFyIHJlc3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlcyBzcHJpbmcgc3RhdGVcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgICAgICAgICBpZiAocmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZCBhdCBsZWFzdCBhIHRhcmdldCBvciBwb3NpdGlvbiB0byBkbyBzcHJpbmd5IHRoaW5nc1xuICAgICAgICAgICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHNwcmluZyBmb3JjZVxuICAgICAgICAgICAgICAgIHZhciBmID0gLShwb3NpdGlvbiAtIHRhcmdldCkgKiBzdGlmZm5lc3M7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmVsb2NpdHkgYnkgYWRkaW5nIGZvcmNlIGJhc2VkIG9uIG1hc3NcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSArPSBmIC8gbWFzcztcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB2ZWxvY2l0eTtcblxuICAgICAgICAgICAgICAgIC8vIHNsb3cgZG93biBiYXNlZCBvbiBhbW91bnQgb2YgZGFtcGluZ1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICo9IGRhbXBpbmc7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBhcnJpdmVkIGlmIHdlJ3JlIG5lYXIgdGFyZ2V0IGFuZCBvdXIgdmVsb2NpdHkgaXMgbmVhciB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKHRoZXJlWWV0KHBvc2l0aW9uLCB0YXJnZXQsIHZlbG9jaXR5KSB8fCBza2lwVG9FbmRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmVzcyB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBuZXcgdGFyZ2V0IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHNldFRhcmdldCA9IGZ1bmN0aW9uIHNldFRhcmdldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRseSBoYXMgbm8gcG9zaXRpb24sIHNldCB0YXJnZXQgYW5kIHBvc2l0aW9uIHRvIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpICYmICFpc051bWJlcihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBuZXh0IHRhcmdldCB2YWx1ZSB3aWxsIG5vdCBiZSBhbmltYXRlZCB0b1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbGV0IHN0YXJ0IG1vdmluZyB0byB0YXJnZXRcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgYXQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSB0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IHJlc3RpbmcgYXMgdGFyZ2V0IGlzIGN1cnJlbnQgcG9zaXRpb24sIHN0b3AgbW92aW5nXG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBuZWVkICdhcGknIHRvIGNhbGwgb251cGRhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIHZhciBhcGkgPSBjcmVhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBzZXRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogZnVuY3Rpb24gb251cGRhdGUodmFsdWUpIHt9LFxuICAgICAgICAgICAgICAgIG9uY29tcGxldGU6IGZ1bmN0aW9uIG9uY29tcGxldGUodmFsdWUpIHt9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICAgIH07XG5cbiAgICB2YXIgZWFzZUxpbmVhciA9IGZ1bmN0aW9uIGVhc2VMaW5lYXIodCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gICAgICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gICAgfTtcblxuICAgIHZhciB0d2VlbiA9XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGZ1bmN0aW9uIHR3ZWVuKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWYkZHVyYXRpb24gPSBfcmVmLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gX3JlZiRkdXJhdGlvbiA9PT0gdm9pZCAwID8gNTAwIDogX3JlZiRkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBfcmVmJGVhc2luZyA9IF9yZWYuZWFzaW5nLFxuICAgICAgICAgICAgICAgIGVhc2luZyA9IF9yZWYkZWFzaW5nID09PSB2b2lkIDAgPyBlYXNlSW5PdXRRdWFkIDogX3JlZiRlYXNpbmcsXG4gICAgICAgICAgICAgICAgX3JlZiRkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgdmFyIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGluZyB8fCB0YXJnZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cyAtIHN0YXJ0IDwgZGVsYXkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHQgPSB0cyAtIHN0YXJ0IC0gZGVsYXk7XG5cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBkdXJhdGlvbiB8fCBza2lwVG9FbmRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHJldmVyc2UgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHAgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKCh0ID49IDAgPyBlYXNpbmcocmV2ZXJzZSA/IDEgLSBwIDogcCkgOiAwKSAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldmVyc2UgPyAwIDogdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byB0d2VlbiB0byBhIHNtYWxsZXIgdmFsdWUgYW5kIGhhdmUgYSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgdHdlZW5pbmcgdG8gYSBzbWFsbGVyIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBnbyFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogZnVuY3Rpb24gb251cGRhdGUodmFsdWUpIHt9LFxuICAgICAgICAgICAgICAgIG9uY29tcGxldGU6IGZ1bmN0aW9uIG9uY29tcGxldGUodmFsdWUpIHt9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICAgIH07XG5cbiAgICB2YXIgYW5pbWF0b3IgPSB7XG4gICAgICAgIHNwcmluZzogc3ByaW5nLFxuICAgICAgICB0d2VlbjogdHdlZW4sXG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NwcmluZycsIHN0aWZmbmVzczogLjUsIGRhbXBpbmc6IC43NSwgbWFzczogMTAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgeDogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0gfSB9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICB2YXIgY3JlYXRlQW5pbWF0b3IgPSBmdW5jdGlvbiBjcmVhdGVBbmltYXRvcihkZWZpbml0aW9uLCBjYXRlZ29yeSwgcHJvcGVydHkpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBzaW5nbGUgZGVmaW5pdGlvblxuICAgICAgICAvLyB3ZSBjaGVjayBpZiB0cmFuc2Zvcm0gaXMgc2V0LCBpZiBzbywgd2UgY2hlY2sgaWYgcHJvcGVydHkgaXMgc2V0XG4gICAgICAgIHZhciBkZWYgPVxuICAgICAgICAgICAgZGVmaW5pdGlvbltjYXRlZ29yeV0gJiYgdHlwZW9mIGRlZmluaXRpb25bY2F0ZWdvcnldW3Byb3BlcnR5XSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICA/IGRlZmluaXRpb25bY2F0ZWdvcnldW3Byb3BlcnR5XVxuICAgICAgICAgICAgICAgIDogZGVmaW5pdGlvbltjYXRlZ29yeV0gfHwgZGVmaW5pdGlvbjtcblxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IHR5cGVvZiBkZWYgPT09ICdvYmplY3QnID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBhZGRHZXRTZXQgPSBmdW5jdGlvbiBhZGRHZXRTZXQoa2V5cywgb2JqLCBwcm9wcykge1xuICAgICAgICB2YXIgb3ZlcndyaXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgICAgb2JqID0gQXJyYXkuaXNBcnJheShvYmopID8gb2JqIDogW29ial07XG4gICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwcm9wc1trZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGtleS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGdldHRlciA9IGtleS5nZXR0ZXIgfHwgZ2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIgPSBrZXkuc2V0dGVyIHx8IHNldHRlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob1tuYW1lXSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIHRvIHN0YXRlLFxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIGludGVybmFsIGFuZCBleHRlcm5hbCBhcGkgKGlmIG5vdCBzZXQpXG4gICAgLy8gc2V0dXAgYW5pbWF0b3JzXG5cbiAgICB2YXIgYW5pbWF0aW9ucyA9IGZ1bmN0aW9uIGFuaW1hdGlvbnMoX3JlZikge1xuICAgICAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEkgPSBfcmVmLnZpZXdJbnRlcm5hbEFQSSxcbiAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSSA9IF9yZWYudmlld0V4dGVybmFsQVBJO1xuICAgICAgICAvLyBpbml0aWFsIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGluaXRpYWxQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gbGlzdCBvZiBhbGwgYWN0aXZlIGFuaW1hdGlvbnNcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcblxuICAgICAgICAvLyBzZXR1cCBhbmltYXRvcnNcbiAgICAgICAgZm9yaW4obWl4aW5Db25maWcsIGZ1bmN0aW9uKHByb3BlcnR5LCBhbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IGNyZWF0ZUFuaW1hdG9yKGFuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBhbmltYXRvciB1cGRhdGVzLCB1cGRhdGUgdGhlIHZpZXcgc3RhdGUgdmFsdWVcbiAgICAgICAgICAgIGFuaW1hdG9yLm9udXBkYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2aWV3UHJvcHNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzZXQgYW5pbWF0b3IgdGFyZ2V0XG4gICAgICAgICAgICBhbmltYXRvci50YXJnZXQgPSBpbml0aWFsUHJvcHNbcHJvcGVydHldO1xuXG4gICAgICAgICAgICAvLyB3aGVuIHZhbHVlIGlzIHNldCwgc2V0IHRoZSBhbmltYXRvciB0YXJnZXQgdmFsdWVcbiAgICAgICAgICAgIHZhciBwcm9wID0ge1xuICAgICAgICAgICAgICAgIGtleTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgc2V0dGVyOiBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBhdCB0YXJnZXQsIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRvci50YXJnZXQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhbmltYXRvci50YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldHRlcjogZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlld1Byb3BzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgICAgICAgIGFkZEdldFNldChbcHJvcF0sIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0b3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBleHBvc2UgaW50ZXJuYWwgd3JpdGUgYXBpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcFRvRW5kU3RhdGUgPSBkb2N1bWVudC5oaWRkZW47XG4gICAgICAgICAgICAgICAgdmFyIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmltYXRpb24ucmVzdGluZykgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge30sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uIGFkZEV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gbWl4aW5cbiAgICB2YXIgbGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKF9yZWYpIHtcbiAgICAgICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgICAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgICAgICAgIHZpZXdTdGF0ZSA9IF9yZWYudmlld1N0YXRlLFxuICAgICAgICAgICAgdmlldyA9IF9yZWYudmlldztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBhZGQgPSBhZGRFdmVudCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICB2YXIgcmVtb3ZlID0gcmVtb3ZlRXZlbnQodmlldy5lbGVtZW50KTtcblxuICAgICAgICB2aWV3RXh0ZXJuYWxBUEkub24gPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZm46IGZuLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFkZCh0eXBlLCBmbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmlld0V4dGVybmFsQVBJLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBldmVudHMuc3BsaWNlKFxuICAgICAgICAgICAgICAgIGV2ZW50cy5maW5kSW5kZXgoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IHR5cGUgJiYgZXZlbnQuZm4gPT09IGZuO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJlbW92ZSh0eXBlLCBmbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYnVzeVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGV2ZW50LnR5cGUsIGV2ZW50LmZuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGFkZCB0byBleHRlcm5hbCBhcGkgYW5kIGxpbmsgdG8gcHJvcHNcblxuICAgIHZhciBhcGlzID0gZnVuY3Rpb24gYXBpcyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSSA9IF9yZWYudmlld0V4dGVybmFsQVBJO1xuICAgICAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRGVmaW5lZCA9IGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gYWRkIHRvIHN0YXRlLFxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIGludGVybmFsIGFuZCBleHRlcm5hbCBhcGkgKGlmIG5vdCBzZXQpXG4gICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgYmFzZWQgb24gcHJvcHMgaW4gdmlld1Byb3BzXG4gICAgLy8gYXBwbHkgYXMgdHJhbnNmb3JtcyBlYWNoIGZyYW1lXG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgc2NhbGVZOiAxLFxuICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICByb3RhdGVYOiAwLFxuICAgICAgICByb3RhdGVZOiAwLFxuICAgICAgICByb3RhdGVaOiAwLFxuICAgICAgICBvcmlnaW5YOiAwLFxuICAgICAgICBvcmlnaW5ZOiAwLFxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKF9yZWYpIHtcbiAgICAgICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgICAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgICAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgICAgIC8vIGluaXRpYWwgcHJvcHNcbiAgICAgICAgdmFyIGluaXRpYWxQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gY3VycmVudCBwcm9wc1xuICAgICAgICB2YXIgY3VycmVudFByb3BzID0ge307XG5cbiAgICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhvc2UgcHJvcGVydGllcyB0byB0aGUgZXh0ZXJuYWwgQVBJIGFuZCBsaW5rIHRoZW0gdG8gdGhlIHZpZXdTdGF0ZVxuICAgICAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcmVjdCBvbiBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgcmVjdCBnZXR0ZXIgc28gaXQgdGFrZXMgaW4gYWNjb3VudCB0cmFuc2Zvcm1zXG4gICAgICAgIHZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiBnZXRPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZpZXdQcm9wc1sndHJhbnNsYXRlWCddIHx8IDAsIHZpZXdQcm9wc1sndHJhbnNsYXRlWSddIHx8IDBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3NjYWxlWCddIHx8IDAsIHZpZXdQcm9wc1snc2NhbGVZJ10gfHwgMF07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LnJlY3RcbiAgICAgICAgICAgICAgICA/IGdldFZpZXdSZWN0KHZpZXcucmVjdCwgdmlldy5jaGlsZFZpZXdzLCBnZXRPZmZzZXQoKSwgZ2V0U2NhbGUoKSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZpZXdJbnRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcbiAgICAgICAgdmlld0V4dGVybmFsQVBJLnJlY3QgPSB7IGdldDogZ2V0UmVjdCB9O1xuXG4gICAgICAgIC8vIGFwcGx5IHZpZXcgcHJvcHNcbiAgICAgICAgbWl4aW5Db25maWcuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZpZXdQcm9wc1trZXldID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5pdGlhbFByb3BzW2tleV0gPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHNba2V5XSA6IGluaXRpYWxQcm9wc1trZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBleHBvc2UgYXBpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNIYXZlQ2hhbmdlZChjdXJyZW50UHJvcHMsIHZpZXdQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIGVsZW1lbnQgdG8gY29ycmVjdCBwb3NpdGlvbiBvbiBzY3JlZW5cbiAgICAgICAgICAgICAgICBhcHBseVN0eWxlcyh2aWV3LmVsZW1lbnQsIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBuZXcgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3VycmVudFByb3BzLCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKTtcblxuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciBidXN5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHt9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcHJvcHNIYXZlQ2hhbmdlZCA9IGZ1bmN0aW9uIHByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGN1cnJlbnRQcm9wcykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhuZXdQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldHMgYW5hbHl6ZSB0aGUgaW5kaXZpZHVhbCBwcm9wc1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAobmV3UHJvcHNbcHJvcF0gIT09IGN1cnJlbnRQcm9wc1twcm9wXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiBhcHBseVN0eWxlcyhlbGVtZW50LCBfcmVmMikge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IF9yZWYyLm9wYWNpdHksXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZSA9IF9yZWYyLnBlcnNwZWN0aXZlLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IF9yZWYyLnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gX3JlZjIudHJhbnNsYXRlWSxcbiAgICAgICAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgICAgICAgIHJvdGF0ZVggPSBfcmVmMi5yb3RhdGVYLFxuICAgICAgICAgICAgcm90YXRlWSA9IF9yZWYyLnJvdGF0ZVksXG4gICAgICAgICAgICByb3RhdGVaID0gX3JlZjIucm90YXRlWixcbiAgICAgICAgICAgIG9yaWdpblggPSBfcmVmMi5vcmlnaW5YLFxuICAgICAgICAgICAgb3JpZ2luWSA9IF9yZWYyLm9yaWdpblksXG4gICAgICAgICAgICB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm1zID0gJyc7XG4gICAgICAgIHZhciBzdHlsZXMgPSAnJztcblxuICAgICAgICAvLyBoYW5kbGUgdHJhbnNmb3JtIG9yaWdpblxuICAgICAgICBpZiAoaXNEZWZpbmVkKG9yaWdpblgpIHx8IGlzRGVmaW5lZChvcmlnaW5ZKSkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICd0cmFuc2Zvcm0tb3JpZ2luOiAnICsgKG9yaWdpblggfHwgMCkgKyAncHggJyArIChvcmlnaW5ZIHx8IDApICsgJ3B4Oyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gb3JkZXIgaXMgcmVsZXZhbnRcbiAgICAgICAgLy8gMC4gcGVyc3BlY3RpdmVcbiAgICAgICAgaWYgKGlzRGVmaW5lZChwZXJzcGVjdGl2ZSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz0gJ3BlcnNwZWN0aXZlKCcgKyBwZXJzcGVjdGl2ZSArICdweCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIHRyYW5zbGF0ZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHRyYW5zbGF0ZVgpIHx8IGlzRGVmaW5lZCh0cmFuc2xhdGVZKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPVxuICAgICAgICAgICAgICAgICd0cmFuc2xhdGUzZCgnICsgKHRyYW5zbGF0ZVggfHwgMCkgKyAncHgsICcgKyAodHJhbnNsYXRlWSB8fCAwKSArICdweCwgMCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIHNjYWxlXG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NhbGVYKSB8fCBpc0RlZmluZWQoc2NhbGVZKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPVxuICAgICAgICAgICAgICAgICdzY2FsZTNkKCcgK1xuICAgICAgICAgICAgICAgIChpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDEpICtcbiAgICAgICAgICAgICAgICAnLCAnICtcbiAgICAgICAgICAgICAgICAoaXNEZWZpbmVkKHNjYWxlWSkgPyBzY2FsZVkgOiAxKSArXG4gICAgICAgICAgICAgICAgJywgMSkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIHJvdGF0ZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVopKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVaKCcgKyByb3RhdGVaICsgJ3JhZCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocm90YXRlWCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz0gJ3JvdGF0ZVgoJyArIHJvdGF0ZVggKyAncmFkKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChyb3RhdGVZKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPSAncm90YXRlWSgnICsgcm90YXRlWSArICdyYWQpICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAndHJhbnNmb3JtOicgKyB0cmFuc2Zvcm1zICsgJzsnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG9wYWNpdHlcbiAgICAgICAgaWYgKGlzRGVmaW5lZChvcGFjaXR5KSkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICdvcGFjaXR5OicgKyBvcGFjaXR5ICsgJzsnO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSByZWFjaCB6ZXJvLCB3ZSBtYWtlIHRoZSBlbGVtZW50IGluYWNjZXNzaWJsZVxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMgKz0gJ3Zpc2liaWxpdHk6aGlkZGVuOyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGJlbG93IDEwMCUgb3BhY2l0eSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgY2xpY2tlZFxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9ICdwb2ludGVyLWV2ZW50czpub25lOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaGVpZ2h0XG4gICAgICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICdoZWlnaHQ6JyArIGhlaWdodCArICdweDsnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHdpZHRoXG4gICAgICAgIGlmIChpc0RlZmluZWQod2lkdGgpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ3dpZHRoOicgKyB3aWR0aCArICdweDsnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgc3R5bGVzXG4gICAgICAgIHZhciBlbGVtZW50Q3VycmVudFN0eWxlID0gZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlIHx8ICcnO1xuXG4gICAgICAgIC8vIGlmIG5ldyBzdHlsZXMgZG9lcyBub3QgbWF0Y2ggY3VycmVudCBzdHlsZXMsIGxldHMgdXBkYXRlIVxuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZS5sZW5ndGggfHwgc3R5bGVzICE9PSBlbGVtZW50Q3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgICAgICAvLyBzdG9yZSBjdXJyZW50IHN0eWxlcyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIHRvIG5ldyBzdHlsZXMgbGF0ZXIgb25cbiAgICAgICAgICAgIC8vIF9ub3RfIGdldHRpbmcgdGhlIHN0eWxlIHZhbHVlIGlzIGZhc3RlclxuICAgICAgICAgICAgZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBNaXhpbnMgPSB7XG4gICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICAgICAgYXBpczogYXBpcyxcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVJlY3QgPSBmdW5jdGlvbiB1cGRhdGVSZWN0KCkge1xuICAgICAgICB2YXIgcmVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCkge1xuICAgICAgICAgICAgcmVjdC5wYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgICAgICByZWN0Lm1hcmdpblRvcCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApIHx8IDA7XG4gICAgICAgICAgICByZWN0Lm1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5Cb3R0b20gPSBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5MZWZ0ID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApIHx8IDA7XG4gICAgICAgICAgICBlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdC5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgIHJlY3QudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgcmVjdC53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuXG4gICAgICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgICAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgcmVjdC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICByZWN0LmhpZGRlbiA9IGVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVmlldyA9XG4gICAgICAgIC8vIGRlZmF1bHQgdmlldyBkZWZpbml0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVZpZXcoKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZiR0YWcgPSBfcmVmLnRhZyxcbiAgICAgICAgICAgICAgICB0YWcgPSBfcmVmJHRhZyA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcmVmJHRhZyxcbiAgICAgICAgICAgICAgICBfcmVmJG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZSA9IF9yZWYkbmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkbmFtZSxcbiAgICAgICAgICAgICAgICBfcmVmJGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IF9yZWYkYXR0cmlidXRlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgX3JlZiRyZWFkID0gX3JlZi5yZWFkLFxuICAgICAgICAgICAgICAgIHJlYWQgPSBfcmVmJHJlYWQgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJHJlYWQsXG4gICAgICAgICAgICAgICAgX3JlZiR3cml0ZSA9IF9yZWYud3JpdGUsXG4gICAgICAgICAgICAgICAgd3JpdGUgPSBfcmVmJHdyaXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiR3cml0ZSxcbiAgICAgICAgICAgICAgICBfcmVmJGNyZWF0ZSA9IF9yZWYuY3JlYXRlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZSA9IF9yZWYkY3JlYXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRjcmVhdGUsXG4gICAgICAgICAgICAgICAgX3JlZiRkZXN0cm95ID0gX3JlZi5kZXN0cm95LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSBfcmVmJGRlc3Ryb3kgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgX3JlZiRmaWx0ZXJGcmFtZUFjdGlvID0gX3JlZi5maWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9XG4gICAgICAgICAgICAgICAgICAgIF9yZWYkZmlsdGVyRnJhbWVBY3RpbyA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGNoaWxkLCBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfcmVmJGZpbHRlckZyYW1lQWN0aW8sXG4gICAgICAgICAgICAgICAgX3JlZiRkaWRDcmVhdGVWaWV3ID0gX3JlZi5kaWRDcmVhdGVWaWV3LFxuICAgICAgICAgICAgICAgIGRpZENyZWF0ZVZpZXcgPSBfcmVmJGRpZENyZWF0ZVZpZXcgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGRpZENyZWF0ZVZpZXcsXG4gICAgICAgICAgICAgICAgX3JlZiRkaWRXcml0ZVZpZXcgPSBfcmVmLmRpZFdyaXRlVmlldyxcbiAgICAgICAgICAgICAgICBkaWRXcml0ZVZpZXcgPSBfcmVmJGRpZFdyaXRlVmlldyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZGlkV3JpdGVWaWV3LFxuICAgICAgICAgICAgICAgIF9yZWYkaWdub3JlUmVjdCA9IF9yZWYuaWdub3JlUmVjdCxcbiAgICAgICAgICAgICAgICBpZ25vcmVSZWN0ID0gX3JlZiRpZ25vcmVSZWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVjdCxcbiAgICAgICAgICAgICAgICBfcmVmJGlnbm9yZVJlY3RVcGRhdGUgPSBfcmVmLmlnbm9yZVJlY3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgaWdub3JlUmVjdFVwZGF0ZSA9IF9yZWYkaWdub3JlUmVjdFVwZGF0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgX3JlZiRtaXhpbnMgPSBfcmVmLm1peGlucyxcbiAgICAgICAgICAgICAgICBtaXhpbnMgPSBfcmVmJG1peGlucyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJG1peGlucztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAvLyBlYWNoIHZpZXcgcmVxdWlyZXMgcmVmZXJlbmNlIHRvIHN0b3JlXG4gICAgICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICAgICAgLy8gcm9vdCBlbGVtZW50IHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcsICdmaWxlcG9uZC0tJyArIG5hbWUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3R5bGUgcmVmZXJlbmNlIHNob3VsZCBhbHNvIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdXBkYXRlUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzdCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBpc1Jlc3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXR0eSBzZWxmIGV4cGxhbmF0b3J5XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVmlld3MgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIGxvYWRlZCBtaXhpbnNcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2VzIHRvIGNyZWF0ZWQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB2YXIgcmVmID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBzdGF0ZSB1c2VkIGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIHdyaXRlcnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhpcyB2aWV3XG4gICAgICAgICAgICAgICAgdmFyIHdyaXRlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlLCAvLyBkZWZhdWx0IHdyaXRlclxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgcmVhZCwgLy8gZGVmYXVsdCByZWFkZXJcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlc3Ryb3llcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3ksIC8vIGRlZmF1bHQgZGVzdHJveVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAvLyBjb3JlIHZpZXcgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0Q2hpbGRWaWV3cyA9IGZ1bmN0aW9uIGdldENoaWxkVmlld3MoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZpZXdzLmNvbmNhdCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGdldFJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVDaGlsZFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVDaGlsZFZpZXcoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGdldFJlY3QgPSBmdW5jdGlvbiBnZXRSZWN0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lUmVjdCA9IGdldFZpZXdSZWN0KHJlY3QsIGNoaWxkVmlld3MsIFswLCAwXSwgWzEsIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlYWQgZGF0YSBmcm9tIERPTVxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIF9yZWFkID0gZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBjaGlsZCB2aWV3c1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5fcmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gIShpZ25vcmVSZWN0VXBkYXRlICYmIHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZWN0KHJlY3QsIGVsZW1lbnQsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcywgcmVjdDogcmVjdCB9O1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyKGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXcml0ZSBkYXRhIHRvIERPTVxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIF93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSh0cywgZnJhbWVBY3Rpb25zLCBzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBhY3Rpb25zLCB3ZSBhc3N1bWUgdGhhdCB0aGUgdmlldyBpcyByZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN0aW5nID0gZnJhbWVBY3Rpb25zLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3cml0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlcnMuZm9yRWFjaChmdW5jdGlvbih3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cml0ZXJSZXN0aW5nID0gd3JpdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cml0ZXJSZXN0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIG1peGluc1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtaXhpbnMgaXMgc3RpbGwgYnVzeSBhZnRlciB3cml0ZSBvcGVyYXRpb24sIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1peGluUmVzdGluZyA9IG1peGluLndyaXRlKHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGNoaWxkIHZpZXdzIHRoYXQgYXJlIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlc3RpbmcgPSBjaGlsZC5fd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZChjaGlsZCwgZnJhbWVBY3Rpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBuZXcgZWxlbWVudHMgdG8gRE9NIGFuZCB1cGRhdGUgdGhvc2VcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIHRvIERPTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQVBJLmFwcGVuZENoaWxkKGNoaWxkLmVsZW1lbnQsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9yZWFkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1jYWxsIHdyaXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQoY2hpbGQsIGZyYW1lQWN0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgYWRkZWQgc29tdGhpbmcgdG8gdGhlIGRvbSwgbm8gcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSByZXN0aW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHJlc3Rpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlkV3JpdGVWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZXJzLmZvckVhY2goZnVuY3Rpb24oZGVzdHJveWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZXIoeyByb290OiBpbnRlcm5hbEFQSSwgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHNoYXJlZEFQSVxuICAgICAgICAgICAgICAgIHZhciBzaGFyZWRBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBwcml2YXRlIEFQSSBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsQVBJRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZEFQSURlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VzcyB0byBjdXN0b20gY2hpbGRyZW4gcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICByZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0UmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbSBtb2RpZmllcnNcbiAgICAgICAgICAgICAgICAgICAgaXM6IGZ1bmN0aW9uIGlzKG5lZWRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IG5lZWRsZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtWaWV3OiBmdW5jdGlvbiBsaW5rVmlldyh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdW5saW5rVmlldzogZnVuY3Rpb24gdW5saW5rVmlldyh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShjaGlsZFZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZFZpZXc6IGFwcGVuZENoaWxkVmlldyhlbGVtZW50LCBjaGlsZFZpZXdzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRWaWV3OiByZW1vdmVDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyV3JpdGVyOiBmdW5jdGlvbiByZWdpc3RlcldyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXJzLnB1c2god3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckRlc3Ryb3llcjogZnVuY3Rpb24gcmVnaXN0ZXJEZXN0cm95ZXIoZGVzdHJveWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzdHJveWVycy5wdXNoKGRlc3Ryb3llcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVMYXlvdXQ6IGZ1bmN0aW9uIGludmFsaWRhdGVMYXlvdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgdG8gZGF0YSBzdG9yZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaDogc3RvcmUuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBzdG9yZS5xdWVyeSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHB1YmxpYyB2aWV3IEFQSSBtZXRob2RzXG4gICAgICAgICAgICAgICAgdmFyIGV4dGVybmFsQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0Q2hpbGRWaWV3cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgaXNSZWN0SWdub3JlZDogZnVuY3Rpb24gaXNSZWN0SWdub3JlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZ25vcmVSZWN0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBfcmVhZDogX3JlYWQsXG4gICAgICAgICAgICAgICAgICAgIF93cml0ZTogX3dyaXRlLFxuICAgICAgICAgICAgICAgICAgICBfZGVzdHJveTogX2Rlc3Ryb3ksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgICAgICAgICAgdmFyIG1peGluQVBJRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZEFQSURlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIG1peGluIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtaXhpbnMpXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaXhpbkFQSSA9IE1peGluc1trZXldKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhpbkNvbmZpZzogbWl4aW5zW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1Byb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3U3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSTogaW50ZXJuYWxBUElEZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSTogZXh0ZXJuYWxBUElEZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGNyZWF0ZU9iamVjdChtaXhpbkFQSURlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXhpbkFQSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5wdXNoKG1peGluQVBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3QgcHJpdmF0ZSBhcGlcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxBUEkgPSBjcmVhdGVPYmplY3QoaW50ZXJuYWxBUElEZWZpbml0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgY3JlYXRlZCBjaGlsZCB2aWV3cyB0byByb290IG5vZGVcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBkaWQgY3JlYXRlXG4gICAgICAgICAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgICAgICAgICAvLyBleHBvc2UgcHVibGljIGFwaVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3QoZXh0ZXJuYWxBUElEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFpbnRlciA9IGZ1bmN0aW9uIGNyZWF0ZVBhaW50ZXIocmVhZCwgd3JpdGUpIHtcbiAgICAgICAgdmFyIGZwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNjA7XG5cbiAgICAgICAgdmFyIG5hbWUgPSAnX19mcmFtZVBhaW50ZXInO1xuXG4gICAgICAgIC8vIHNldCBnbG9iYWwgcGFpbnRlclxuICAgICAgICBpZiAod2luZG93W25hbWVdKSB7XG4gICAgICAgICAgICB3aW5kb3dbbmFtZV0ucmVhZGVycy5wdXNoKHJlYWQpO1xuICAgICAgICAgICAgd2luZG93W25hbWVdLndyaXRlcnMucHVzaCh3cml0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3dbbmFtZV0gPSB7XG4gICAgICAgICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICAgICAgICB3cml0ZXJzOiBbd3JpdGVdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYWludGVyID0gd2luZG93W25hbWVdO1xuXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG4gICAgICAgIHZhciBsYXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGlkID0gbnVsbDtcbiAgICAgICAgdmFyIHJlcXVlc3RUaWNrID0gbnVsbDtcbiAgICAgICAgdmFyIGNhbmNlbFRpY2sgPSBudWxsO1xuXG4gICAgICAgIHZhciBzZXRUaW1lclR5cGUgPSBmdW5jdGlvbiBzZXRUaW1lclR5cGUoKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYW5jZWxUaWNrID0gZnVuY3Rpb24gY2FuY2VsVGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbFRpY2spIGNhbmNlbFRpY2soKTtcbiAgICAgICAgICAgIHNldFRpbWVyVHlwZSgpO1xuICAgICAgICAgICAgdGljayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gdGljayh0cykge1xuICAgICAgICAgICAgLy8gcXVldWUgbmV4dCB0aWNrXG4gICAgICAgICAgICBpZCA9IHJlcXVlc3RUaWNrKHRpY2spO1xuXG4gICAgICAgICAgICAvLyBsaW1pdCBmcHNcbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICAgICAgICBpZiAoZGVsdGEgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGZyYW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbGlnbiBuZXh0IGZyYW1lXG4gICAgICAgICAgICBsYXN0ID0gdHMgLSAoZGVsdGEgJSBpbnRlcnZhbCk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB2aWV3XG4gICAgICAgICAgICBwYWludGVyLnJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihyZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFpbnRlci53cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGUodHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0VGltZXJUeXBlKCk7XG4gICAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsVGljayhpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUm91dGUgPSBmdW5jdGlvbiBjcmVhdGVSb3V0ZShyb3V0ZXMsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgICAgICAgX3JlZiRhY3Rpb25zID0gX3JlZi5hY3Rpb25zLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmJGFjdGlvbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRhY3Rpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IF9yZWYudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZi5zaG91bGRPcHRpbWl6ZTtcbiAgICAgICAgICAgIGFjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVzW2FjdGlvbi50eXBlXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oe1xuICAgICAgICAgICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZTogc2hvdWxkT3B0aW1pemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH07XG5cbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJywnO1xuICAgICAgICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAuc3BsaXQoc3BsaXR0ZXIpXG4gICAgICAgICAgICAubWFwKHRyaW0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH07XG5cbiAgICB2YXIgdG9Cb29sZWFuID0gZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgIH07XG5cbiAgICB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9O1xuXG4gICAgdmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBpc1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgID8gdG9TdHJpbmcodmFsdWUpLnJlcGxhY2UoL1thLXpdKy9naSwgJycpXG4gICAgICAgICAgICA6IDA7XG4gICAgfTtcblxuICAgIHZhciB0b0ludCA9IGZ1bmN0aW9uIHRvSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0b051bWJlcih2YWx1ZSksIDEwKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvRmxvYXQgPSBmdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvTnVtYmVyKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHZhciBpc0ludCA9IGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgICAgIHZhciBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDAwO1xuICAgICAgICAvLyBpcyBpbiBieXRlc1xuICAgICAgICBpZiAoaXNJbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpcyBuYXR1cmFsIGZpbGUgc2l6ZVxuICAgICAgICB2YXIgbmF0dXJhbEZpbGVTaXplID0gdG9TdHJpbmcodmFsdWUpLnRyaW0oKTtcblxuICAgICAgICAvLyBpZiBpcyB2YWx1ZSBpbiBtZWdhYnl0ZXNcbiAgICAgICAgaWYgKC9NQiQvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZSAqIGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyB2YWx1ZSBpbiBraWxvYnl0ZXNcbiAgICAgICAgaWYgKC9LQi9pLnRlc3QobmF0dXJhbEZpbGVTaXplKSkge1xuICAgICAgICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL0tCJGkvLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSk7XG4gICAgfTtcblxuICAgIHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICB2YXIgdG9GdW5jdGlvblJlZmVyZW5jZSA9IGZ1bmN0aW9uIHRvRnVuY3Rpb25SZWZlcmVuY2Uoc3RyaW5nKSB7XG4gICAgICAgIHZhciByZWYgPSBzZWxmO1xuICAgICAgICB2YXIgbGV2ZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBsZXZlbCA9IG51bGw7XG4gICAgICAgIHdoaWxlICgobGV2ZWwgPSBsZXZlbHMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIHJlZiA9IHJlZltsZXZlbF07XG4gICAgICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcblxuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgICBwcm9jZXNzOiAnUE9TVCcsXG4gICAgICAgIHBhdGNoOiAnUEFUQ0gnLFxuICAgICAgICByZXZlcnQ6ICdERUxFVEUnLFxuICAgICAgICBmZXRjaDogJ0dFVCcsXG4gICAgICAgIHJlc3RvcmU6ICdHRVQnLFxuICAgICAgICBsb2FkOiAnR0VUJyxcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNlcnZlckFQSSA9IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckFQSShvdXRsaW5lKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcblxuICAgICAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgICAgIGFwaS50aW1lb3V0ID0gb3V0bGluZS50aW1lb3V0ID8gcGFyc2VJbnQob3V0bGluZS50aW1lb3V0LCAxMCkgOiAwO1xuICAgICAgICBhcGkuaGVhZGVycyA9IG91dGxpbmUuaGVhZGVycyA/IG91dGxpbmUuaGVhZGVycyA6IHt9O1xuXG4gICAgICAgIGZvcmluKG1ldGhvZHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgYXBpW2tleV0gPSBjcmVhdGVBY3Rpb24oa2V5LCBvdXRsaW5lW2tleV0sIG1ldGhvZHNba2V5XSwgYXBpLnRpbWVvdXQsIGFwaS5oZWFkZXJzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByb2Nlc3MgaWYgbm8gdXJsIG9yIHByb2Nlc3Mgb24gb3V0bGluZVxuICAgICAgICBhcGkucHJvY2VzcyA9IG91dGxpbmUucHJvY2VzcyB8fCBpc1N0cmluZyhvdXRsaW5lKSB8fCBvdXRsaW5lLnVybCA/IGFwaS5wcm9jZXNzIDogbnVsbDtcblxuICAgICAgICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3IgcmVtb3ZlXG4gICAgICAgIGFwaS5yZW1vdmUgPSBvdXRsaW5lLnJlbW92ZSB8fCBudWxsO1xuXG4gICAgICAgIC8vIHJlbW92ZSBnZW5lcmljIGhlYWRlcnMgZnJvbSBhcGkgb2JqZWN0XG4gICAgICAgIGRlbGV0ZSBhcGkuaGVhZGVycztcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQWN0aW9uKG5hbWUsIG91dGxpbmUsIG1ldGhvZCwgdGltZW91dCwgaGVhZGVycykge1xuICAgICAgICAvLyBpcyBleHBsaWNpdGVseSBzZXQgdG8gbnVsbCBzbyBkaXNhYmxlXG4gICAgICAgIGlmIChvdXRsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGN1c3RvbSBmdW5jdGlvbiwgZG9uZSEgRGV2IGhhbmRsZXMgZXZlcnl0aGluZy5cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRsaW5lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0bGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1aWxkIGFjdGlvbiBvYmplY3RcbiAgICAgICAgdmFyIGFjdGlvbiA9IHtcbiAgICAgICAgICAgIHVybDogbWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdQQVRDSCcgPyAnPycgKyBuYW1lICsgJz0nIDogJycsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgIG9ubG9hZDogbnVsbCxcbiAgICAgICAgICAgIG9uZGF0YTogbnVsbCxcbiAgICAgICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaXMgYSBzaW5nbGUgdXJsXG4gICAgICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgICAgICAgYWN0aW9uLnVybCA9IG91dGxpbmU7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcndyaXRlXG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWN0aW9uLCBvdXRsaW5lKTtcblxuICAgICAgICAvLyBzZWUgaWYgc2hvdWxkIHJlZm9ybWF0IGhlYWRlcnM7XG4gICAgICAgIGlmIChpc1N0cmluZyhhY3Rpb24uaGVhZGVycykpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGFjdGlvbi5oZWFkZXJzLnNwbGl0KC86KC4rKS8pO1xuICAgICAgICAgICAgYWN0aW9uLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFydHNbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICAgICAgYWN0aW9uLndpdGhDcmVkZW50aWFscyA9IHRvQm9vbGVhbihhY3Rpb24ud2l0aENyZWRlbnRpYWxzKTtcblxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgdG9TZXJ2ZXJBUEkgPSBmdW5jdGlvbiB0b1NlcnZlckFQSSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyQVBJKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgaXNBUEkgPSBmdW5jdGlvbiBpc0FQSSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICBpc1N0cmluZyh2YWx1ZS51cmwpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZS5wcm9jZXNzKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUucmV2ZXJ0KSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUucmVzdG9yZSkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLmZldGNoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eWzAtOV0rID8oPzpHQnxNQnxLQikkL2dpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J5dGVzJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FQSSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXBpJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciByZXBsYWNlU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gcmVwbGFjZVNpbmdsZVF1b3RlcyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgICAgLnJlcGxhY2UoL3tcXHMqJy9nLCAne1wiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nXFxzKn0vZywgJ1wifScpXG4gICAgICAgICAgICAucmVwbGFjZSgvJ1xccyo6L2csICdcIjonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzpcXHMqJy9nLCAnOlwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8sXFxzKicvZywgJyxcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJ1xccyosL2csICdcIiwnKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnZlcnNpb25UYWJsZSA9IHtcbiAgICAgICAgYXJyYXk6IHRvQXJyYXksXG4gICAgICAgIGJvb2xlYW46IHRvQm9vbGVhbixcbiAgICAgICAgaW50OiBmdW5jdGlvbiBpbnQodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUeXBlKHZhbHVlKSA9PT0gJ2J5dGVzJyA/IHRvQnl0ZXModmFsdWUpIDogdG9JbnQodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IHRvRmxvYXQsXG4gICAgICAgIGZsb2F0OiB0b0Zsb2F0LFxuICAgICAgICBieXRlczogdG9CeXRlcyxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogdG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbjogZnVuY3Rpb24gX2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9GdW5jdGlvblJlZmVyZW5jZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlcnZlcmFwaTogdG9TZXJ2ZXJBUEksXG4gICAgICAgIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlcGxhY2VTaW5nbGVRdW90ZXModmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIGNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyh2YWx1ZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gY29udmVyc2lvblRhYmxlW3R5cGVdKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFZhbHVlQnlUeXBlID0gZnVuY3Rpb24gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIC8vIGNhbiBhbHdheXMgYXNzaWduIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiB0aGUgbmV3IHZhbHVlXG4gICAgICAgIHZhciBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKG5ld1ZhbHVlKTtcblxuICAgICAgICAvLyBpcyB2YWxpZCB0eXBlP1xuICAgICAgICBpZiAobmV3VmFsdWVUeXBlICE9PSB2YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIC8vIGlzIHN0cmluZyBpbnB1dCwgbGV0J3MgYXR0ZW1wdCB0byBjb252ZXJ0XG4gICAgICAgICAgICB2YXIgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0VG8obmV3VmFsdWUsIHZhbHVlVHlwZSk7XG5cbiAgICAgICAgICAgIC8vIHdoYXQgaXMgdGhlIHR5cGUgbm93XG4gICAgICAgICAgICBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKGNvbnZlcnRlZFZhbHVlKTtcblxuICAgICAgICAgICAgLy8gbm8gdmFsaWQgY29udmVyc2lvbnMgZm91bmRcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdUcnlpbmcgdG8gYXNzaWduIHZhbHVlIHdpdGggaW5jb3JyZWN0IHR5cGUgdG8gXCInICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiLCBhbGxvd2VkIHR5cGU6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVHlwZSArXG4gICAgICAgICAgICAgICAgICAgICdcIic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbihkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSkge1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBnZXRWYWx1ZUJ5VHlwZShuZXdWYWx1ZSwgZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvbnMgPSBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uRGVmaW5pdGlvbiA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBjcmVhdGVPcHRpb24ob3B0aW9uRGVmaW5pdGlvblswXSwgb3B0aW9uRGVmaW5pdGlvblsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KG9iaik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gbW9kZWxcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcblxuICAgICAgICAgICAgLy8gdGltZW91dCB1c2VkIGZvciBjYWxsaW5nIHVwZGF0ZSBpdGVtc1xuICAgICAgICAgICAgbGlzdFVwZGF0ZVRpbWVvdXQ6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3Igc3RhY2tpbmcgbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgaXRlbVVwZGF0ZVRpbWVvdXQ6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIHF1ZXVlIG9mIGl0ZW1zIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgICBwcm9jZXNzaW5nUXVldWU6IFtdLFxuXG4gICAgICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgICAgICBvcHRpb25zOiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZnJvbUNhbWVscyA9IGZ1bmN0aW9uIGZyb21DYW1lbHMoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICctJztcbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAgICAgLnNwbGl0KC8oPz1bQS1aXSkvKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9uQVBJID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1NFVF8nICsgZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb25BY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQWN0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICBvYmpbJ1NFVF8nICsgbmFtZV0gPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gLy8gbm9wZSwgZmFpbGVkXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHNldCB0aGUgdmFsdWUgb2YgdGhpcyBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TRVRfJyArIG5hbWUsIHsgdmFsdWU6IHN0YXRlLm9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9uUXVlcmllcyA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvblF1ZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIG9ialsnR0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpXSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICAgICAgQVBJOiAxLFxuICAgICAgICBEUk9QOiAyLFxuICAgICAgICBCUk9XU0U6IDMsXG4gICAgICAgIFBBU1RFOiA0LFxuICAgICAgICBOT05FOiA1LFxuICAgIH07XG5cbiAgICB2YXIgZ2V0VW5pcXVlSWQgPSBmdW5jdGlvbiBnZXRVbmlxdWVJZCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKClcbiAgICAgICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMiwgMTEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gICAgfVxuXG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICAgIGZ1bmN0aW9uIF9qc3godHlwZSwgcHJvcHMsIGtleSwgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgICAgICAgICAgICAgMHhlYWM3O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgICAgIGlmICghcHJvcHMgJiYgY2hpbGRyZW5MZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB2b2lkIDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBrZXk6IGtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsga2V5LFxuICAgICAgICAgICAgcmVmOiBudWxsLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgX293bmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY0l0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBtZXRob2Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgICAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gJ3JldHVybicgOiAnbm9ybWFsJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgICAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgICB9O1xuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gICAgfTtcblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3JldHVybicsIGFyZyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoaW5uZXIsIGF3YWl0V3JhcCkge1xuICAgICAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAod2FpdGluZykge1xuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXIudGhyb3cgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3JldHVybicsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAnbmV4dCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBvYmplY3RTeW1ib2xzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICBfZXh0ZW5kcyA9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KVxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICAgICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgICAgICAgID8gb2JqXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG9iaixcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25ld0Fycm93Q2hlY2soaW5uZXJUaGlzLCBib3VuZFRoaXMpIHtcbiAgICAgICAgaWYgKGlubmVyVGhpcyAhPT0gYm91bmRUaGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgYW4gYXJyb3cgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3REZXN0cnVjdHVyaW5nRW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGRlc3RydWN0dXJlIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgICAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjYWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlc2M7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICAgICAgICB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcblxuICAgICAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGVtcG9yYWxSZWYodmFsLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgaXMgcmVhZC1vbmx5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzTmFtZVREWkVycm9yKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBcIicgKyBuYW1lICsgJ1wiIGNhbm5vdCBiZSByZWZlcmVuY2VkIGluIGNvbXB1dGVkIHByb3BlcnR5IGtleXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIF90ZW1wb3JhbFVuZGVmaW5lZCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgICAgICAgcmV0dXJuIGFycjI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgICAgICB2YXIgX2FyciA9IFtdO1xuICAgICAgICB2YXIgX24gPSB0cnVlO1xuICAgICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgICAgICBfZSA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10gIT0gbnVsbCkgX2lbJ3JldHVybiddKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHtcbiAgICAgICAgdmFyIF9hcnIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7ICkge1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaXQubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgICAgICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cbiAgICAgICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoaGludCA9PT0gJ3N0cmluZycgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICAgICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsICdzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArXG4gICAgICAgICAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgICAgICAgICAnVG8gdXNlIHByb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaW4gc3BlYyBtb2RlIHdpdGggZGVjb3JhdG9ycywgd2FpdCBmb3IgJyArXG4gICAgICAgICAgICAgICAgJ3RoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgZGVjb3JhdG9ycyBpbiBzdGFnZSAyLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVzYyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IGRlY29yYXRvcnNcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGRlc2MsIGRlY29yYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgIH0sIGRlc2MpO1xuXG4gICAgICAgIGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgZGVzYyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG5cbiAgICB2YXIgaWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VCYXNlKHJlY2VpdmVyLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlY2VpdmVyLCBwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHVzZSBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkRGVzdHJ1Y3R1cmVTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgaWYgKCEoJ19fZGVzdHJPYmonIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5fX2Rlc3RyT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXQgdmFsdWUodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlRmllbGRTcGVjR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNTZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7XG4gICAgICAgIHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpO1xuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBpID0gbWl4aW5zW2ldKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7XG4gICAgICAgICAgICBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgfSwgc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgICAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgICAgICAgIGRlY29yYXRvcnNcbiAgICAgICAgKTtcbiAgICAgICAgYXBpLmluaXRpYWxpemVDbGFzc0VsZW1lbnRzKHIuRiwgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXREZWNvcmF0b3JzQXBpKCkge1xuICAgICAgICBfZ2V0RGVjb3JhdG9yc0FwaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbJ21ldGhvZCddLCBbJ2ZpZWxkJ11dLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uKE8sIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSAnb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQua2luZCA9PT0ga2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09ICdzdGF0aWMnID8gRiA6IHByb3RvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmaW5lQ2xhc3NFbGVtZW50OiBmdW5jdGlvbihyZWNlaXZlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3duOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaGVycyA9IGZpbmlzaGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50LmtleSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKGVsZW1lbnRPYmplY3QpIHx8IGVsZW1lbnRPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFeHRyYXMgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZXh0cmFzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhcy5wdXNoLmFwcGx5KGV4dHJhcywgbmV3RXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYXM6IGV4dHJhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c0FuZEZpbmlzaGVyID0gdGhpcy50b0NsYXNzRGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9ialxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnRzW2pdLmtleSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24oZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9BcnJheShlbGVtZW50T2JqZWN0cykubWFwKGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZXh0cmFzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyAmJiBraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIGVpdGhlciBcIm1ldGhvZFwiIG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSAnc3RhdGljJyAmJiBwbGFjZW1lbnQgIT09ICdwcm90b3R5cGUnICYmIHBsYWNlbWVudCAhPT0gJ293bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFwicHJvdG90eXBlXCIgb3IgXCJvd25cIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIC5wbGFjZW1lbnQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2VsZW1lbnRzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2luaXRpYWxpemVyJywgJ0EgbWV0aG9kIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KGVsZW1lbnRPYmplY3QsICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlcixcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFzOiBleHRyYXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcob2JqLmtpbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGNyZWF0ZWQgYSBjbGFzcyBkZXNjcmlwdG9yIHdpdGggLmtpbmQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2tleScsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdkZXNjcmlwdG9yJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdpbml0aWFsaXplcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuQ2xhc3NGaW5pc2hlcnM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmaW5pc2hlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhbGxvd1Byb3BlcnR5OiBmdW5jdGlvbihvYmosIG5hbWUsIG9iamVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmplY3RUeXBlICsgXCIgY2FuJ3QgaGF2ZSBhIC5cIiArIG5hbWUgKyAnIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikge1xuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgaWYgKGRlZi5raW5kID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGdldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIHNldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBraW5kOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdmaWVsZCcgOiAnbWV0aG9kJyxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcGxhY2VtZW50OiBkZWYuc3RhdGljID8gJ3N0YXRpYycgOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdvd24nIDogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgICAgICBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikge1xuICAgICAgICBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29hbGVzY2VDbGFzc0VsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmXG4gICAgICAgICAgICAgICAgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJiAob3RoZXIgPSBuZXdFbGVtZW50cy5maW5kKGlzU2FtZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBtZXRob2RzICgnICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIHNhbWUgcHJvcGVydHkgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5rZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRlY29yYXRvcnMgJiYgZWxlbWVudC5kZWNvcmF0b3JzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNEYXRhRGVzY3JpcHRvcihkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQgJiYgIShkZXNjLnZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVzYy53cml0YWJsZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQocmVjZWl2ZXIsIHByaXZhdGVTZXQsIGZuKSB7XG4gICAgICAgIGlmICghcHJpdmF0ZVNldC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3dyYXBSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgICBfd3JhcFJlZ0V4cCA9IGZ1bmN0aW9uKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIGdyb3Vwcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9SZWdFeHAgPSBfd3JhcE5hdGl2ZVN1cGVyKFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbiAgICAgICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9SZWdFeHAuY2FsbCh0aGlzLCByZSk7XG5cbiAgICAgICAgICAgIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQuZ3JvdXBzID0gYnVpbGRHcm91cHMocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gX2dyb3Vwcy5nZXQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbi5yZXBsYWNlKC9cXCQ8KFtePl0rKT4vZywgZnVuY3Rpb24oXywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckJyArIGdyb3Vwc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbGRHcm91cHMoYXJncywgX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcbiAgICAgICAgICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZykucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgbmFtZSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlSZW1vdmUgPSBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihjYiwgc3luYykge1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQsIGNiKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZShcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50ICYmIChsaXN0ZW5lci5jYiA9PT0gY2IgfHwgIWNiKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9maXJlID0gZnVuY3Rpb24gZmlyZShldmVudCwgYXJncywgc3luYykge1xuICAgICAgICAgICAgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2I7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc3luYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJlU3luYzogZnVuY3Rpb24gZmlyZVN5bmMoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZmlyZShldmVudCwgYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gZmlyZShldmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2tleTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MisrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maXJlKGV2ZW50LCBhcmdzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBjYjogY2IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PbmNlOiBmdW5jdGlvbiBvbk9uY2UoZXZlbnQsIF9jYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYjogZnVuY3Rpb24gY2IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYoZXZlbnQsIF9jYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZjogb2ZmLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgICAgIHNyYyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBleGNsdWRlZFxuICAgICkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFleGNsdWRlZC5pbmNsdWRlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrZXkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgUFJJVkFURSA9IFtcbiAgICAgICAgJ2ZpcmUnLFxuICAgICAgICAncHJvY2VzcycsXG4gICAgICAgICdyZXZlcnQnLFxuICAgICAgICAnbG9hZCcsXG4gICAgICAgICdvbicsXG4gICAgICAgICdvZmYnLFxuICAgICAgICAnb25PbmNlJyxcbiAgICAgICAgJ3JldHJ5TG9hZCcsXG4gICAgICAgICdleHRlbmQnLFxuICAgICAgICAnYXJjaGl2ZScsXG4gICAgICAgICdhcmNoaXZlZCcsXG4gICAgICAgICdyZWxlYXNlJyxcbiAgICAgICAgJ3JlbGVhc2VkJyxcbiAgICAgICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAgICAgJ2ZyZWV6ZScsXG4gICAgXTtcblxuICAgIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcbiAgICAgICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChpdGVtLCBhcGksIFBSSVZBVEUpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVsZWFzZWRJdGVtcyA9IGZ1bmN0aW9uIHJlbW92ZVJlbGVhc2VkSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShpdGVtcywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgICAgIElOSVQ6IDEsXG4gICAgICAgIElETEU6IDIsXG4gICAgICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgICAgICBQUk9DRVNTSU5HOiAzLFxuICAgICAgICBQUk9DRVNTSU5HX0NPTVBMRVRFOiA1LFxuICAgICAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgICAgICBQUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogMTAsXG4gICAgICAgIExPQURJTkc6IDcsXG4gICAgICAgIExPQURfRVJST1I6IDgsXG4gICAgfTtcblxuICAgIHZhciBGaWxlT3JpZ2luID0ge1xuICAgICAgICBJTlBVVDogMSxcbiAgICAgICAgTElNQk86IDIsXG4gICAgICAgIExPQ0FMOiAzLFxuICAgIH07XG5cbiAgICB2YXIgZ2V0Tm9uTnVtZXJpYyA9IGZ1bmN0aW9uIGdldE5vbk51bWVyaWMoc3RyKSB7XG4gICAgICAgIHJldHVybiAvW14wLTldKy8uZXhlYyhzdHIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBnZXROb25OdW1lcmljKCgxLjEpLnRvTG9jYWxlU3RyaW5nKCkpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkge1xuICAgICAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgdGhlIG5vcm1hbCB0b1N0cmluZyBvdXRwdXQgYW5kIGlmIHRoZXkncmUgdGhlIHNhbWUgcmV0dXJuIGEgY29tbWEgd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBpcyBhIGRvdFxuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IGdldERlY2ltYWxTZXBhcmF0b3IoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciA9ICgxMDAwLjApLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yICE9PSB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Tm9uTnVtZXJpYyh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaW1hbFNlcGFyYXRvciA9PT0gJy4nID8gJywnIDogJy4nO1xuICAgIH07XG5cbiAgICB2YXIgVHlwZSA9IHtcbiAgICAgICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgICAgICBJTlQ6ICdpbnQnLFxuICAgICAgICBOVU1CRVI6ICdudW1iZXInLFxuICAgICAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgICAgICBBUlJBWTogJ2FycmF5JyxcbiAgICAgICAgT0JKRUNUOiAnb2JqZWN0JyxcbiAgICAgICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgICAgIFNFUlZFUl9BUEk6ICdzZXJ2ZXJhcGknLFxuICAgICAgICBSRUdFWDogJ3JlZ2V4JyxcbiAgICB9O1xuXG4gICAgLy8gYWxsIHJlZ2lzdGVyZWQgZmlsdGVyc1xuICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gICAgdmFyIGFwcGx5RmlsdGVyQ2hhaW4gPSBmdW5jdGlvbiBhcHBseUZpbHRlckNoYWluKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmNiO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIG5vd1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciB0byBraWNrIHRoaW5ncyBvZlxuICAgICAgICAgICAgdmFyIGluaXRpYWxGaWx0ZXIgPSBtYXRjaGluZ0ZpbHRlcnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gY2hhaW4gZmlsdGVyc1xuICAgICAgICAgICAgbWF0Y2hpbmdGaWx0ZXJzXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHByb21pc2VzIHBhc3NpbmcgdmFsdWUgdG8gbmV4dCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCh2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBpbml0aWFsIGZpbHRlciwgd2lsbCByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxGaWx0ZXIodmFsdWUsIHV0aWxzKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5rZXkgPT09IGtleTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5jYih2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBsaXN0XG4gICAgdmFyIGFkZEZpbHRlciA9IGZ1bmN0aW9uIGFkZEZpbHRlcihrZXksIGNiKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzLnB1c2goeyBrZXk6IGtleSwgY2I6IGNiIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIGZvcmluKG9wdHMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGtleSBkb2VzIG5vdCBleGlzdCwgc28gdGhpcyBvcHRpb24gY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0T3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVswXSA9IGdldFZhbHVlQnlUeXBlKFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICBpZDogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpbnB1dCBmaWVsZCBuYW1lIHRvIHVzZVxuICAgICAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGZpZWxkXG4gICAgICAgIGRpc2FibGVkOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgICAgIGNsYXNzTmFtZTogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpcyB0aGUgZmllbGQgcmVxdWlyZWRcbiAgICAgICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBBbGxvdyBtZWRpYSBjYXB0dXJlIHdoZW4gdmFsdWUgaXMgc2V0XG4gICAgICAgIGNhcHR1cmVNZXRob2Q6IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAgICAgLy8gLSBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGlwbGUgb24gYXBwbGUgZGV2aWNlc1xuICAgICAgICAvLyAtIElmIHNldCwgYWNjZXB0ZWRGaWxlVHlwZXMgbXVzdCBiZSBtYWRlIHRvIG1hdGNoIHdpdGggbWVkaWEgd2lsZGNhcmQgXCJpbWFnZS8qXCIsIFwiYXVkaW8vKlwiIG9yIFwidmlkZW8vKlwiXG5cbiAgICAgICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgICAgIGFsbG93U3luY0FjY2VwdEF0dHJpYnV0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gRmVhdHVyZSB0b2dnbGVzXG4gICAgICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93QnJvd3NlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgYnJvd3NpbmcgdGhlIGZpbGUgc3lzdGVtXG4gICAgICAgIGFsbG93UGFzdGU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBwYXN0aW5nIGZpbGVzXG4gICAgICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgICAgICBhbGxvd1JlcGxhY2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBhIGZpbGUgb24gb3RoZXIgZmlsZSB0byByZXBsYWNlIGl0IChvbmx5IHdvcmtzIHdoZW4gbXVsdGlwbGUgaXMgc2V0IHRvIGZhbHNlKVxuICAgICAgICBhbGxvd1JldmVydDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHJldmVydCBmaWxlIHVwbG9hZFxuICAgICAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgICAgICBhbGxvd1Byb2Nlc3M6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byBwcm9jZXNzIGEgZmlsZSwgd2hlbiBzZXQgdG8gZmFsc2UsIHRoaXMgcmVtb3ZlcyB0aGUgZmlsZSB1cGxvYWQgYnV0dG9uXG4gICAgICAgIGFsbG93UmVvcmRlcjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyByZW9yZGVyaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAgICAgLy8gVHJ5IHN0b3JlIGZpbGUgaWYgYHNlcnZlcmAgbm90IHNldFxuICAgICAgICBzdG9yZUFzRmlsZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIFJldmVydCBtb2RlXG4gICAgICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgICAgICAvLyBJbnB1dCByZXF1aXJlbWVudHNcbiAgICAgICAgbWF4RmlsZXM6IFtudWxsLCBUeXBlLklOVF0sIC8vIE1heCBudW1iZXIgb2YgZmlsZXNcbiAgICAgICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgICAgIC8vIFdoZXJlIHRvIHB1dCBmaWxlXG4gICAgICAgIGl0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb206IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTZXQgdG8gZmFsc2UgdG8gYWx3YXlzIGFkZCBpdGVtcyB0byBiZWdpbiBvciBlbmQgb2YgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0SW50ZXJ2YWw6IFs3NSwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIERyYWcgJ24gRHJvcCByZWxhdGVkXG4gICAgICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BPbkVsZW1lbnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBEcm9wIG5lZWRzIHRvIGhhcHBlbiBvbiBlbGVtZW50IChzZXQgdG8gZmFsc2UgdG8gYWxzbyBsb2FkIGRyb3BzIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BWYWxpZGF0aW9uOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBvciBkaXNhYmxlIHZhbGlkYXRpbmcgZmlsZXMgb24gZHJvcFxuICAgICAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAgICAgLy8gVXBsb2FkIHJlbGF0ZWRcbiAgICAgICAgaW5zdGFudFVwbG9hZDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIFNob3VsZCB1cGxvYWQgZmlsZXMgaW1tZWRpYXRlbHkgb24gZHJvcFxuICAgICAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG4gICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gaWYgdHJ1ZSB1cGxvYWRzIHRha2UgYXQgbGVhc3QgNzUwIG1zLCB0aGlzIGVuc3VyZXMgdGhlIHVzZXIgc2VlcyB0aGUgdXBsb2FkIHByb2dyZXNzIGdpdmluZyB0cnVzdCB0aGUgdXBsb2FkIGFjdHVhbGx5IGhhcHBlbmVkXG5cbiAgICAgICAgLy8gQ2h1bmtzXG4gICAgICAgIGNodW5rVXBsb2FkczogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgY2h1bmtlZCB1cGxvYWRzXG4gICAgICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICAgICAgY2h1bmtTaXplOiBbNTAwMDAwMCwgVHlwZS5JTlRdLCAvLyBTaXplIG9mIGNodW5rcyAoNU1CIGRlZmF1bHQpXG4gICAgICAgIGNodW5rUmV0cnlEZWxheXM6IFtbNTAwLCAxMDAwLCAzMDAwXSwgVHlwZS5BUlJBWV0sIC8vIEFtb3VudCBvZiB0aW1lcyB0byByZXRyeSB1cGxvYWQgb2YgYSBjaHVuayB3aGVuIGl0IGZhaWxzXG5cbiAgICAgICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgICAgIHNlcnZlcjogW251bGwsIFR5cGUuU0VSVkVSX0FQSV0sXG5cbiAgICAgICAgLy8gRmlsZSBzaXplIGNhbGN1bGF0aW9ucywgY2FuIHNldCB0byAxMDI0LCB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGlzcGxheSwgcHJvcGVydGllcyB1c2UgZmlsZSBzaXplIGJhc2UgMTAwMFxuICAgICAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTGFiZWxzIGFuZCBzdGF0dXMgbWVzc2FnZXNcbiAgICAgICAgbGFiZWxGaWxlU2l6ZUJ5dGVzOiBbJ2J5dGVzJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplS2lsb2J5dGVzOiBbJ0tCJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplTWVnYWJ5dGVzOiBbJ01CJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplR2lnYWJ5dGVzOiBbJ0dCJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsRGVjaW1hbFNlcGFyYXRvcjogW2dldERlY2ltYWxTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcbiAgICAgICAgbGFiZWxUaG91c2FuZHNTZXBhcmF0b3I6IFtnZXRUaG91c2FuZHNTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcblxuICAgICAgICBsYWJlbElkbGU6IFtcbiAgICAgICAgICAgICdEcmFnICYgRHJvcCB5b3VyIGZpbGVzIG9yIDxzcGFuIGNsYXNzPVwiZmlsZXBvbmQtLWxhYmVsLWFjdGlvblwiPkJyb3dzZTwvc3Bhbj4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgbGFiZWxJbnZhbGlkRmllbGQ6IFsnRmllbGQgY29udGFpbnMgaW52YWxpZCBmaWxlcycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlV2FpdGluZ0ZvclNpemU6IFsnV2FpdGluZyBmb3Igc2l6ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUNvdW50U2luZ3VsYXI6IFsnZmlsZSBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVDb3VudFBsdXJhbDogWydmaWxlcyBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUFkZGVkOiBbJ0FkZGVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgICAgICBsYWJlbEZpbGVMb2FkRXJyb3I6IFsnRXJyb3IgZHVyaW5nIGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICAgICAgbGFiZWxGaWxlUmVtb3ZlRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZzogWydVcGxvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdBYm9ydGVkOiBbJ1VwbG9hZCBjYW5jZWxsZWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcjogWydFcnJvciBkdXJpbmcgdXBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICBsYWJlbFRhcFRvQ2FuY2VsOiBbJ3RhcCB0byBjYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsVGFwVG9SZXRyeTogWyd0YXAgdG8gcmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsQnV0dG9uUmVtb3ZlSXRlbTogWydSZW1vdmUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtTG9hZDogWydBYm9ydCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IFsnQ2FuY2VsJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblVuZG9JdGVtUHJvY2Vzc2luZzogWydVbmRvJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uUHJvY2Vzc0l0ZW06IFsnVXBsb2FkJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3aWR0aCBhbmQgaGVpZ2h0IHBsdXMgdmlld3BveCBhcmUgZXZlbiBudW1iZXJzIHNvIGljb25zIGFyZSBuaWNlbHkgY2VudGVyZWRcbiAgICAgICAgaWNvblJlbW92ZTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25SZXRyeTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblVuZG86IFtcbiAgICAgICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBpY29uRG9uZTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgb25pbml0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ud2FybmluZzogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uYWN0aXZhdGVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uaW5pdGZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlcHJvZ3Jlc3M6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlcHJvZ3Jlc3M6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZWFib3J0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcmVwYXJlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnVwZGF0ZWZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gaG9va3NcbiAgICAgICAgYmVmb3JlRHJvcEZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBiZWZvcmVSZW1vdmVGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIGJlZm9yZVByZXBhcmVGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gc3R5bGVzXG4gICAgICAgIHN0eWxlUGFuZWxMYXlvdXQ6IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgJ2ludGVncmF0ZWQnLCAnY29tcGFjdCcsICdjaXJjbGUnXG4gICAgICAgIHN0eWxlUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCBvciAnMzoyJyBvciAxXG4gICAgICAgIHN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uOiBbJ2xlZnQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlQnV0dG9uUHJvY2Vzc0l0ZW1Qb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtQWxpZ246IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBjdXN0b20gaW5pdGlhbCBmaWxlcyBhcnJheVxuICAgICAgICBmaWxlczogW1tdLCBUeXBlLkFSUkFZXSxcblxuICAgICAgICAvLyBzaG93IHN1cHBvcnQgYnkgZGlzcGxheWluZyBjcmVkaXRzXG4gICAgICAgIGNyZWRpdHM6IFtbJ2h0dHBzOi8vcHFpbmEubmwvJywgJ1Bvd2VyZWQgYnkgUFFJTkEnXSwgVHlwZS5BUlJBWV0sXG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtQnlRdWVyeSA9IGZ1bmN0aW9uIGdldEl0ZW1CeVF1ZXJ5KGl0ZW1zLCBxdWVyeSkge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgICAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtc1swXSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVlcnkgaXMgaW5kZXhcbiAgICAgICAgaWYgKGlzSW50KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcXVlcnkgaXMgaXRlbSwgZ2V0IHRoZSBpZFxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtZSBxdWVyeSBpcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0ZW0gYnkgaWRcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBxdWVyeTtcbiAgICAgICAgICAgIH0pIHx8IG51bGxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcgPSBmdW5jdGlvbiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KGFzcGVjdFJhdGlvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvOi8udGVzdChhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMV0gLyBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhc3BlY3RSYXRpbyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRBY3RpdmVJdGVtcyA9IGZ1bmN0aW9uIGdldEFjdGl2ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVtLmFyY2hpdmVkO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFN0YXR1cyA9IHtcbiAgICAgICAgRU1QVFk6IDAsXG4gICAgICAgIElETEU6IDEsIC8vIHdhaXRpbmdcbiAgICAgICAgRVJST1I6IDIsIC8vIGEgZmlsZSBpcyBpbiBlcnJvciBzdGF0ZVxuICAgICAgICBCVVNZOiAzLCAvLyBidXN5IHByb2Nlc3Npbmcgb3IgbG9hZGluZ1xuICAgICAgICBSRUFEWTogNCwgLy8gYWxsIGZpbGVzIHVwbG9hZGVkXG4gICAgfTtcblxuICAgIHZhciByZXMgPSBudWxsO1xuICAgIHZhciBjYW5VcGRhdGVGaWxlSW5wdXQgPSBmdW5jdGlvbiBjYW5VcGRhdGVGaWxlSW5wdXQoKSB7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuaXRlbXMuYWRkKG5ldyBGaWxlKFsnaGVsbG8gd29ybGQnXSwgJ1RoaXNfV29ya3MudHh0JykpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcbiAgICAgICAgICAgICAgICBlbC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgICAgICAgICByZXMgPSBlbC5maWxlcy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICB2YXIgSVRFTV9FUlJPUiA9IFtcbiAgICAgICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1IsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IsXG4gICAgXTtcblxuICAgIHZhciBJVEVNX0JVU1kgPSBbXG4gICAgICAgIEl0ZW1TdGF0dXMuTE9BRElORyxcbiAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVELFxuICAgICAgICBJdGVtU3RhdHVzLklOSVQsXG4gICAgXTtcblxuICAgIHZhciBJVEVNX1JFQURZID0gW0l0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURV07XG5cbiAgICB2YXIgaXNJdGVtSW5FcnJvclN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5FcnJvclN0YXRlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIElURU1fRVJST1IuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICAgIH07XG4gICAgdmFyIGlzSXRlbUluQnVzeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5CdXN5U3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9CVVNZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgICB9O1xuICAgIHZhciBpc0l0ZW1JblJlYWR5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JblJlYWR5U3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9SRUFEWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gICAgfTtcblxuICAgIHZhciBpc0FzeW5jID0gZnVuY3Rpb24gaXNBc3luYyhzdGF0ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIpICYmXG4gICAgICAgICAgICAoaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIucHJvY2VzcykgfHwgaXNGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJpZXMgPSBmdW5jdGlvbiBxdWVyaWVzKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBHRVRfU1RBVFVTOiBmdW5jdGlvbiBHRVRfU1RBVFVTKCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgICAgICAgICB2YXIgRU1QVFkgPSBTdGF0dXMuRU1QVFksXG4gICAgICAgICAgICAgICAgICAgIEVSUk9SID0gU3RhdHVzLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBCVVNZID0gU3RhdHVzLkJVU1ksXG4gICAgICAgICAgICAgICAgICAgIElETEUgPSBTdGF0dXMuSURMRSxcbiAgICAgICAgICAgICAgICAgICAgUkVBRFkgPSBTdGF0dXMuUkVBRFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkVycm9yU3RhdGUpKSByZXR1cm4gRVJST1I7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkJ1c3lTdGF0ZSkpIHJldHVybiBCVVNZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5SZWFkeVN0YXRlKSkgcmV0dXJuIFJFQURZO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIElETEU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTTogZnVuY3Rpb24gR0VUX0lURU0ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9BQ1RJVkVfSVRFTTogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEl0ZW1CeVF1ZXJ5KGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSwgcXVlcnkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0FDVElWRV9JVEVNUzogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1TOiBmdW5jdGlvbiBHRVRfSVRFTVMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLml0ZW1zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fTkFNRTogZnVuY3Rpb24gR0VUX0lURU1fTkFNRShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZW5hbWUgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fU0laRTogZnVuY3Rpb24gR0VUX0lURU1fU0laRShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZVNpemUgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX1NUWUxFUzogZnVuY3Rpb24gR0VUX1NUWUxFUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGUub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvXnN0eWxlLy50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdGUub3B0aW9uc1tvcHRpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfUEFORUxfQVNQRUNUX1JBVElPKCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1NoYXBlQ2lyY2xlID0gL2NpcmNsZS8udGVzdChzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxMYXlvdXQpO1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGlzU2hhcGVDaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9JVEVNU19CWV9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9JVEVNU19CWV9TVEFUVVMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zdGF0dXMgPT09IHN0YXR1cztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9UT1RBTF9JVEVNUzogZnVuY3Rpb24gR0VUX1RPVEFMX0lURU1TKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUOiBmdW5jdGlvbiBTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuc3RvcmVBc0ZpbGUgJiYgY2FuVXBkYXRlRmlsZUlucHV0KCkgJiYgIWlzQXN5bmMoc3RhdGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgSVNfQVNZTkM6IGZ1bmN0aW9uIElTX0FTWU5DKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FzeW5jKHN0YXRlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9GSUxFX1NJWkVfTEFCRUxTOiBmdW5jdGlvbiBHRVRfRklMRV9TSVpFX0xBQkVMUyhxdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsQnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEtpbG9ieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfS0lMT0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbE1lZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfTUVHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEdpZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfR0lHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaGFzUm9vbUZvckl0ZW0gPSBmdW5jdGlvbiBoYXNSb29tRm9ySXRlbShzdGF0ZSkge1xuICAgICAgICB2YXIgY291bnQgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuXG4gICAgICAgIC8vIGlmIGNhbm5vdCBoYXZlIG11bHRpcGxlIGl0ZW1zLCB0byBhZGQgb25lIGl0ZW0gaXQgc2hvdWxkIGN1cnJlbnRseSBub3QgY29udGFpbiBpdGVtc1xuICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgICAgIHZhciBtYXhGaWxlQ291bnQgPSBzdGF0ZS5vcHRpb25zLm1heEZpbGVzO1xuICAgICAgICBpZiAobWF4RmlsZUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNvdW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4IGNvdW50LCBpZiBzbywgYW5vdGhlciBmaWxlIGNhbiBzdGlsbCBiZSBhZGRlZFxuICAgICAgICBpZiAoY291bnQgPCBtYXhGaWxlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbW9yZSByb29tIGZvciBhbm90aGVyIGZpbGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgbGltaXQgPSBmdW5jdGlvbiBsaW1pdCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heCwgdmFsdWUpLCBtaW4pO1xuICAgIH07XG5cbiAgICB2YXIgYXJyYXlJbnNlcnQgPSBmdW5jdGlvbiBhcnJheUluc2VydChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIGluc2VydEl0ZW0gPSBmdW5jdGlvbiBpbnNlcnRJdGVtKGl0ZW1zLCBpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaXNFbXB0eShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpbmRleCBpcyB1bmRlZmluZWQsIGFwcGVuZFxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQgdGhlIGluZGV4IHRvIHRoZSBzaXplIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCBpdGVtIHRvIGFycmF5XG4gICAgICAgIGFycmF5SW5zZXJ0KGl0ZW1zLCBpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICB2YXIgaXNCYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gaXNCYXNlNjREYXRhVVJJKHN0cikge1xuICAgICAgICByZXR1cm4gL15cXHMqZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16LV0rPVthLXowLTktXSspPyk/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcc10qKVxccyokL2kudGVzdChcbiAgICAgICAgICAgIHN0clxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZW5hbWVGcm9tVVJMID0gZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCkge1xuICAgICAgICByZXR1cm4gKCcnICsgdXJsKVxuICAgICAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgLnNwbGl0KCc/JylcbiAgICAgICAgICAgIC5zaGlmdCgpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lID0gZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB9O1xuXG4gICAgdmFyIGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ3Vlc3N0aW1hdGVFeHRlbnNpb24odHlwZSkge1xuICAgICAgICAvLyBpZiBubyBleHRlbnNpb24gc3VwcGxpZWQsIGV4aXQgaGVyZVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgc3VidHlwZVxuICAgICAgICB2YXIgc3VidHlwZSA9IHR5cGUuc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgICAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgICAgICBpZiAoL3N2Zy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdzdmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC96aXB8Y29tcHJlc3NlZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICd6aXAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9wbGFpbi8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICd0eHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9tc3dvcmQvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIHZhbGlkIHN1YnR5cGVcbiAgICAgICAgaWYgKC9bYS16XSsvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyB1c2UganBnIGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKHN1YnR5cGUgPT09ICdqcGVnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnanBnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuIHN1YnR5cGVcbiAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICB2YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIGxlZnRQYWQodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgICAgICByZXR1cm4gKHBhZGRpbmcgKyB2YWx1ZSkuc2xpY2UoLXBhZGRpbmcubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldERhdGVTdHJpbmcgPSBmdW5jdGlvbiBnZXREYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldERhdGUoKSwgJzAwJykgK1xuICAgICAgICAgICAgJ18nICtcbiAgICAgICAgICAgIGxlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldE1pbnV0ZXMoKSwgJzAwJykgK1xuICAgICAgICAgICAgJy0nICtcbiAgICAgICAgICAgIGxlZnRQYWQoZGF0ZS5nZXRTZWNvbmRzKCksICcwMCcpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlRnJvbUJsb2IgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJsb2IoYmxvYiwgZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICAgIHZhciBmaWxlID1cbiAgICAgICAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIHR5cGUpXG4gICAgICAgICAgICAgICAgOiBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgYmxvYi50eXBlKTtcbiAgICAgICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICAgICAgaWYgKGJsb2IuX3JlbGF0aXZlUGF0aCkgZmlsZS5fcmVsYXRpdmVQYXRoID0gYmxvYi5fcmVsYXRpdmVQYXRoO1xuXG4gICAgICAgIC8vIGlmIGJsb2IgaGFzIG5hbWUgcHJvcGVydHksIHVzZSBhcyBmaWxlbmFtZSBpZiBubyBmaWxlbmFtZSBzdXBwbGllZFxuICAgICAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBnZXREYXRlU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBmaWxlbmFtZSBzdXBwbGllZCBidXQgbm8gZXh0ZW5zaW9uIGFuZCBmaWxlbmFtZSBoYXMgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChmaWxlbmFtZSAmJiBleHRlbnNpb24gPT09IG51bGwgJiYgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24gfHwgZ3Vlc3N0aW1hdGVFeHRlbnNpb24oZmlsZS50eXBlKTtcbiAgICAgICAgICAgIGZpbGUubmFtZSA9IGZpbGVuYW1lICsgKGV4dGVuc2lvbiA/ICcuJyArIGV4dGVuc2lvbiA6ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkJ1aWxkZXIgPSBmdW5jdGlvbiBnZXRCbG9iQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuQmxvYkJ1aWxkZXIgPVxuICAgICAgICAgICAgd2luZG93LkJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgICAgIHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgd2luZG93Lk1TQmxvYkJ1aWxkZXIpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQmxvYiA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2IoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBCQiA9IGdldEJsb2JCdWlsZGVyKCk7XG5cbiAgICAgICAgaWYgKEJCKSB7XG4gICAgICAgICAgICB2YXIgYmIgPSBuZXcgQkIoKTtcbiAgICAgICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYmIuZ2V0QmxvYihtaW1lVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlID0gZnVuY3Rpb24gZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlKFxuICAgICAgICBieXRlU3RyaW5nLFxuICAgICAgICBtaW1lVHlwZVxuICAgICkge1xuICAgICAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShhYik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmVhdGVCbG9iKGFiLCBtaW1lVHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgICAgIHJldHVybiAoL15kYXRhOiguKyk7Ly5leGVjKGRhdGFVUkkpIHx8IFtdKVsxXSB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgICAgICB2YXIgZGF0YSA9IGRhdGFVUkkuc3BsaXQoJywnKVsxXTtcblxuICAgICAgICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgYXMgdGhhdCBjYXVzZXMgSW52YWxpZENoYXJhY3RlckVycm9yIGluIElFXG4gICAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICByZXR1cm4gYXRvYihnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgdmFyIG1pbWVUeXBlID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcbiAgICAgICAgdmFyIGJ5dGVTdHJpbmcgPSBnZXRCeXRlU3RyaW5nRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSk7XG5cbiAgICAgICAgcmV0dXJuIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZShieXRlU3RyaW5nLCBtaW1lVHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSwgZmlsZW5hbWUsIGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZ2V0RmlsZUZyb21CbG9iKGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSwgZmlsZW5hbWUsIG51bGwsIGV4dGVuc2lvbik7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlTmFtZUZyb21IZWFkZXIgPSBmdW5jdGlvbiBnZXRGaWxlTmFtZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgaXMgY29udGVudCBkaXNwb3NpdGlvbiBoZWFkZXIsIGlmIG5vdCBleGl0XG4gICAgICAgIGlmICghL15jb250ZW50LWRpc3Bvc2l0aW9uOi9pLnRlc3QoaGVhZGVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IGZpbGVuYW1lIHBhcnRzXG4gICAgICAgIHZhciBtYXRjaGVzID0gaGVhZGVyXG4gICAgICAgICAgICAuc3BsaXQoL2ZpbGVuYW1lPXxmaWxlbmFtZVxcKj0uKycnLylcbiAgICAgICAgICAgIC5zcGxpY2UoMSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnRyaW0oKS5yZXBsYWNlKC9eW1wiJ118WztcIiddezAsMn0kL2csICcnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPyBkZWNvZGVVUkkobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlU2l6ZUZyb21IZWFkZXIgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIGlmICgvY29udGVudC1sZW5ndGg6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlci5tYXRjaCgvWzAtOV0rLylbMF07XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSA/IHBhcnNlSW50KHNpemUsIDEwKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRUcmFuZnNlcklkRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoL3gtY29udGVudC10cmFuc2Zlci1pZDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IChoZWFkZXIuc3BsaXQoJzonKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIGlkIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzID0gZnVuY3Rpb24gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvd3MgPSBoZWFkZXJzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gcm93c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgICAgICAgICAgICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZpbGVMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWxlTG9hZGVyKGZldGNoRm4pIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBzaXplOiBudWxsLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0ICYmIHN0YXRlLnJlcXVlc3QuYWJvcnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZCBzb3VyY2VcbiAgICAgICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICAgICAgLy8gZ2V0IHF1aWNrIHJlZmVyZW5jZVxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcblxuICAgICAgICAgICAgYXBpLmZpcmUoJ2luaXQnLCBzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBMb2FkIEZpbGVzXG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgYmxvYnMsIHNldCBkZWZhdWx0IG5hbWUgdG8gY3VycmVudCBkYXRlXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBnZXRGaWxlRnJvbUJsb2Ioc291cmNlLCBzb3VyY2UubmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVhbCBhcyBpZiBpcyBleHRlcm5hbCBVUkwsIGxldCdzIGxvYWQgaXQhXG4gICAgICAgICAgICAgICAgbG9hZFVSTChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxvYWRzIGEgdXJsXG4gICAgICAgIHZhciBsb2FkVVJMID0gZnVuY3Rpb24gbG9hZFVSTCh1cmwpIHtcbiAgICAgICAgICAgIC8vIGlzIHJlbW90ZSB1cmwgYW5kIG5vIGZldGNoIG1ldGhvZCBzdXBwbGllZFxuICAgICAgICAgICAgaWYgKCFmZXRjaEZuKSB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBcIkNhbid0IGxvYWQgVVJMXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDQwMCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIGxvYWQgZmlsZVxuICAgICAgICAgICAgc3RhdGUucmVxdWVzdCA9IGZldGNoRm4oXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHR1cm4gYmxvYiByZXNwb25zZSBpbnRvIGEgZmlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGdldEZpbGVGcm9tQmxvYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgYmxvYiwgd2UgZ28gd2l0aCBibG9iLCBpZiBubyByZXNwb25zZSwgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlIGluc3RhbmNlb2YgQmxvYiA/IHJlc3BvbnNlIDogcmVzcG9uc2UgPyByZXNwb25zZS5ib2R5IDogbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0ZWQgc29tZSBtZXRhIGRhdGEgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNpemUgPSB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSBwcm9ncmVzcywgd2UncmUgbm90IGdvaW5nIHRvIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHByb2dyZXNzIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjdXJyZW50IC8gdG90YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIHN0YXRlLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlaW5mbyA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdtZXRhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBmaWxlaW5mby5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVpbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGVpbmZvLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbih7fSwgb24oKSwge1xuICAgICAgICAgICAgc2V0U291cmNlOiBmdW5jdGlvbiBzZXRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5zb3VyY2UgPSBzb3VyY2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFByb2dyZXNzOiBnZXRQcm9ncmVzcywgLy8gZmlsZSBsb2FkIHByb2dyZXNzXG4gICAgICAgICAgICBhYm9ydDogYWJvcnQsIC8vIGFib3J0IGZpbGUgbG9hZFxuICAgICAgICAgICAgbG9hZDogbG9hZCwgLy8gc3RhcnQgbG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgaXNHZXQgPSBmdW5jdGlvbiBpc0dldChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIC9HRVR8SEVBRC8udGVzdChtZXRob2QpO1xuICAgIH07XG5cbiAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiBzZW5kUmVxdWVzdChkYXRhLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIG9uaGVhZGVyczogZnVuY3Rpb24gb25oZWFkZXJzKCkge30sXG4gICAgICAgICAgICBvbnByb2dyZXNzOiBmdW5jdGlvbiBvbnByb2dyZXNzKCkge30sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICAgICAgb250aW1lb3V0OiBmdW5jdGlvbiBvbnRpbWVvdXQoKSB7fSxcbiAgICAgICAgICAgIG9uZXJyb3I6IGZ1bmN0aW9uIG9uZXJyb3IoKSB7fSxcbiAgICAgICAgICAgIG9uYWJvcnQ6IGZ1bmN0aW9uIG9uYWJvcnQoKSB7fSxcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICAgICAgdmFyIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhlYWRlcnNSZWNlaXZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZW5jb2RlIHVybFxuICAgICAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcblxuICAgICAgICAvLyBpZiBtZXRob2QgaXMgR0VULCBhZGQgYW55IHJlY2VpdmVkIGRhdGEgdG8gdXJsXG5cbiAgICAgICAgaWYgKGlzR2V0KG9wdGlvbnMubWV0aG9kKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICB1cmwgPVxuICAgICAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgICAgICB1cmwgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVlc3RcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIHByb2dyZXNzIG9mIGxvYWRcbiAgICAgICAgdmFyIHByb2Nlc3MgPSBpc0dldChvcHRpb25zLm1ldGhvZCkgPyB4aHIgOiB4aHIudXBsb2FkO1xuICAgICAgICBwcm9jZXNzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBubyBwcm9ncmVzcyBldmVudCB3aGVuIGFib3J0ZWQgKCBvbnByb2dyZXNzIGlzIGNhbGxlZCBvbmNlIGFmdGVyIGFib3J0KCkgKVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFwaS5vbnByb2dyZXNzKGUubGVuZ3RoQ29tcHV0YWJsZSwgZS5sb2FkZWQsIGUudG90YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRyaWVzIHRvIGdldCBoZWFkZXIgaW5mbyB0byB0aGUgYXBwIGFzIGZhc3QgYXMgcG9zc2libGVcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gbm90IGludGVyZXN0aW5nIGluIHRoZXNlIHN0YXRlcyAoJ3Vuc2VudCcgYW5kICdvcGVuZW5kJyBhcyB0aGV5IGRvbid0IGdpdmUgdXMgYW55IGFkZGl0aW9uYWwgaW5mbylcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHNlcnZlciByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcnNSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHdlJ3ZlIHByb2JhYmx5IHJlY2VpdmVkIHNvbWUgdXNlZnVsIGRhdGEgaW4gcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgYXBpLm9uaGVhZGVycyh4aHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxvYWQgc3VjY2Vzc2Z1bFxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpcyBjbGFzc2lmaWVkIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGFwaS5vbmxvYWQoeGhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBlcnJvciBkdXJpbmcgbG9hZFxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5vbmVycm9yKHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGFwaS5vbmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGkub250aW1lb3V0KHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb3BlbiB1cCBvcGVuIHVwIVxuICAgICAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAvLyBzZXQgdGltZW91dCBpZiBkZWZpbmVkIChkbyBpdCBhZnRlciBvcGVuIHNvIElFMTEgcGxheXMgYmFsbClcbiAgICAgICAgaWYgKGlzSW50KG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGhlYWRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaGVhZGVyc1trZXldKSk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0IHR5cGUgb2YgcmVzcG9uc2VcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY3JlZGVudGlhbHNcbiAgICAgICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCdzIHNlbmQgb3VyIGRhdGFcbiAgICAgICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlc3BvbnNlID0gZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2UodHlwZSwgY29kZSwgYm9keSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRpbWVvdXRSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShjYikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaGFzUVMgPSBmdW5jdGlvbiBoYXNRUyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIC9cXD8vLnRlc3Qoc3RyKTtcbiAgICB9O1xuICAgIHZhciBidWlsZFVSTCA9IGZ1bmN0aW9uIGJ1aWxkVVJMKCkge1xuICAgICAgICB2YXIgdXJsID0gJyc7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgdXJsICs9IGhhc1FTKHVybCkgJiYgaGFzUVMocGFydCkgPyBwYXJ0LnJlcGxhY2UoL1xcPy8sICcmJykgOiBwYXJ0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZldGNoRnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVGZXRjaEZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXBpVXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGRvIGxvY2FsIG9yIHJlbW90ZSByZXF1ZXN0IGJhc2VkIG9uIGlmIHRoZSB1cmwgaXMgZXh0ZXJuYWxcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIC8vIGdldCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGdldEZpbGVGcm9tQmxvYihvbmxvYWQoeGhyLnJlc3BvbnNlKSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzKGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgQ2h1bmtTdGF0dXMgPSB7XG4gICAgICAgIFFVRVVFRDogMCxcbiAgICAgICAgQ09NUExFVEU6IDEsXG4gICAgICAgIFBST0NFU1NJTkc6IDIsXG4gICAgICAgIEVSUk9SOiAzLFxuICAgICAgICBXQUlUSU5HOiA0LFxuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6KCkgPT4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8vIGFwaVVybCwgYWN0aW9uLCBuYW1lLCBmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnNcbiAgICB2YXIgcHJvY2Vzc0ZpbGVDaHVua2VkID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICBhcGlVcmwsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGxvYWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHRyYW5zZmVyLFxuICAgICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICAgIC8vIGFsbCBjaHVua3NcbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUcmFuc2ZlcklkID0gb3B0aW9ucy5jaHVua1RyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua1NlcnZlciA9IG9wdGlvbnMuY2h1bmtTZXJ2ZXIsXG4gICAgICAgICAgICBjaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgIGNodW5rUmV0cnlEZWxheXMgPSBvcHRpb25zLmNodW5rUmV0cnlEZWxheXM7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBzdGF0ZVxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBzZXJ2ZXJJZDogY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IG9ubG9hZCBoYW5kbGVyc1xuICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmRhdGEgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih4aHIsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QgPT09ICdIRUFEJyA/IHhoci5nZXRSZXNwb25zZUhlYWRlcignVXBsb2FkLU9mZnNldCcpIDogeGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uZXJyb3IgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICAgICAgdmFyIHJlcXVlc3RUcmFuc2ZlcklkID0gZnVuY3Rpb24gcmVxdWVzdFRyYW5zZmVySWQoY2IpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKGZpbGUsIG1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0VHJhbnNmZXJPZmZzZXQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJPZmZzZXQoY2IpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKHN0YXRlLnNlcnZlcklkKVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgcmVxdWVzdFVybCwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG9ubG9hZCh4aHIsIHJlcXVlc3RQYXJhbXMubWV0aG9kKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIGNodW5rc1xuICAgICAgICB2YXIgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3RDaHVua0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpO1xuICAgICAgICAgICAgY2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAgICAgcmV0cmllczogX3RvQ29uc3VtYWJsZUFycmF5KGNodW5rUmV0cnlEZWxheXMpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogQ2h1bmtTdGF0dXMuUVVFVUVELFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24gY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWQoc3RhdGUuc2VydmVySWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYW5Qcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBjYW5Qcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlFVRVVFRCB8fCBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBwcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3NpbmcgaXMgcGF1c2VkLCB3YWl0IGhlcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGdldCBuZXh0IGNodW5rIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsgfHwgY2h1bmtzLmZpbmQoY2FuUHJvY2Vzc0NodW5rKTtcblxuICAgICAgICAgICAgLy8gbm8gbW9yZSBjaHVua3MgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lP1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmV2ZXJ5KGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm8gY2h1bmsgdG8gaGFuZGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcHJvY2Vzc2luZyB0aGlzIGNodW5rXG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyBwYXJzaW5nIG9mIGZvcm1kYXRhXG4gICAgICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmRhdGEgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmVycm9yIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25sb2FkID0gY2h1bmtTZXJ2ZXIub25sb2FkIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gY2h1bmtTZXJ2ZXIuaGVhZGVycyhjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiBjaHVuay5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTmFtZSc6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gKGNodW5rLnJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICBvbmRhdGEoY2h1bmsuZGF0YSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVybCxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBjaHVua1NlcnZlciwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBob29raW5nIGludG8gcmVxdWVzdCByZXN1bHRcbiAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLCBjaHVuay5pbmRleCwgY2h1bmtzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIG1vcmUgY2h1bmtzXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24obGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gbGVuZ3RoQ29tcHV0YWJsZSA/IGxvYWRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2h1bmsuZXJyb3IgPSBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKSh4aHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlFVRVVFRDtcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV0cnlQcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiByZXRyeVByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgICAgICAgLy8gbm8gbW9yZSByZXRyaWVzIGxlZnRcbiAgICAgICAgICAgIGlmIChjaHVuay5yZXRyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBuZXcgcmV0cnlcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLldBSVRJTkc7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICAgICAgICBjaHVuay50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgfSwgY2h1bmsucmV0cmllcy5zaGlmdCgpKTtcblxuICAgICAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gcmV0cnlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGRhdGVUb3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdXBkYXRlVG90YWxQcm9ncmVzcygpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBwcm9ncmVzcyBmcmFjdGlvblxuICAgICAgICAgICAgdmFyIHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbihwLCBjaHVuaykge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBudWxsIHx8IGNodW5rLnByb2dyZXNzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIGNodW5rLnByb2dyZXNzO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNhbid0IGNvbXB1dGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICh0b3RhbEJ5dGVzVHJhbnNmZXJlZCA9PT0gbnVsbCkgcmV0dXJuIHByb2dyZXNzKGZhbHNlLCAwLCAwKTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICAgICAgdmFyIHRvdGFsU2l6ZSA9IGNodW5rcy5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgY2h1bmsuc2l6ZTtcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAvLyBjYW4gdXBkYXRlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgICAgICAgcHJvZ3Jlc3ModHJ1ZSwgdG90YWxCeXRlc1RyYW5zZmVyZWQsIHRvdGFsU2l6ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHJvY2VzcyBuZXcgY2h1bmtzXG4gICAgICAgIHZhciBwcm9jZXNzQ2h1bmtzID0gZnVuY3Rpb24gcHJvY2Vzc0NodW5rcygpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbFByb2Nlc3NpbmcgPSBjaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLnN0YXR1cyA9PT0gQ2h1bmtTdGF0dXMuUFJPQ0VTU0lORztcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbFByb2Nlc3NpbmcgPj0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFib3J0Q2h1bmtzID0gZnVuY3Rpb24gYWJvcnRDaHVua3MoKSB7XG4gICAgICAgICAgICBjaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjaHVuay50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbGV0J3MgZ28hXG4gICAgICAgIGlmICghc3RhdGUuc2VydmVySWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUcmFuc2ZlcklkKGZ1bmN0aW9uKHNlcnZlcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCBoZXJlIGlmIGFib3J0ZWQsIG1pZ2h0IGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiByZXF1ZXN0IGFuZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBwYXNzIGJhY2sgdG8gaXRlbSBzbyB3ZSBjYW4gdXNlIGl0IGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG4gICAgICAgICAgICAgICAgdHJhbnNmZXIoc2VydmVySWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlcklkID0gc2VydmVySWQ7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VHJhbnNmZXJPZmZzZXQoZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCBoZXJlIGlmIGFib3J0ZWQsIG1pZ2h0IGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiByZXF1ZXN0IGFuZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBtYXJrIGNodW5rcyB3aXRoIGxvd2VyIG9mZnNldCBhcyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIGNodW5rc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsub2Zmc2V0IDwgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuQ09NUExFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGNodW5rLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhYm9ydENodW5rcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDooKSA9PiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIHZhciBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oXG4gICAgICAgIGFwaVVybCxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBuYW1lLFxuICAgICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIC8vIG5vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBpZiB3YXMgcGFzc2VkIGEgZmlsZSwgYW5kIHdlIGNhbiBjaHVuayBpdCwgZXhpdCBoZXJlXG4gICAgICAgICAgICB2YXIgY2FuQ2h1bmtVcGxvYWQgPSBvcHRpb25zLmNodW5rVXBsb2FkcztcbiAgICAgICAgICAgIHZhciBzaG91bGRDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIGZpbGUuc2l6ZSA+IG9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIHdpbGxDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIChzaG91bGRDaHVua1VwbG9hZCB8fCBvcHRpb25zLmNodW5rRm9yY2UpO1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iICYmIHdpbGxDaHVua1VwbG9hZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gc2V0IGhhbmRsZXJzXG4gICAgICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgICAgICBhY3Rpb24ub25kYXRhIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGZvcm1kYXRhIG9iamVjdFxuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgICAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHVybiBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHMgc28gbm8gbWF0dGVyIHdoYXQgdGhlIGlucHV0LCB3ZSBjYW4gaGFuZGxlIGl0IHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgKGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gW3sgbmFtZTogbnVsbCwgZmlsZTogZmlsZSB9XSA6IGZpbGUpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5maWxlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtLm5hbWUgPT09IG51bGwgPyBpdGVtLmZpbGUubmFtZSA6ICcnICsgaXRlbS5uYW1lICsgaXRlbS5maWxlLm5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgb25kYXRhKGZvcm1EYXRhKSxcbiAgICAgICAgICAgICAgICBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFwaVVybCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uYXBwbHkodm9pZCAwLCBbbmFtZV0uY29uY2F0KHBhcmFtcywgW29wdGlvbnNdKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIG5vIGFjdGlvbiBzdXBwbGllZFxuICAgICAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbihhcGlVcmwsIGFjdGlvbiwgbmFtZSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikgPT4geyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIHZhciBjcmVhdGVSZXZlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVJldmVydEZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXBpVXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBpcyBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWQsIHJldHVybiBzdHViIGZ1bmN0aW9uLCBpbnRlcmZhY2Ugd2lsbCB3b3JrLCBidXQgZmlsZSB3b24ndCBiZSByZW1vdmVkXG4gICAgICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVuaXF1ZUZpbGVJZCwgbG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IG9ubG9hZCBoYW5sZGVyXG4gICAgICAgIHZhciBvbmxvYWQgPVxuICAgICAgICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgdW5pcXVlRmlsZUlkLFxuICAgICAgICAgICAgICAgIGFwaVVybCArIGFjdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgYWN0aW9uIC8vIGNvbnRhaW5zIG1ldGhvZCwgaGVhZGVycyBhbmQgd2l0aENyZWRlbnRpYWxzIHByb3BlcnRpZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UmFuZG9tTnVtYmVyID0gZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyKCkge1xuICAgICAgICB2YXIgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICByZXR1cm4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyID0gZnVuY3Rpb24gY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyKGNiKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIHRpY2tNaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDI1O1xuICAgICAgICB2YXIgdGlja01heCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMjUwO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBnZXRSYW5kb21OdW1iZXIodGlja01pbiwgdGlja01heCk7XG5cbiAgICAgICAgICAgIGlmIChydW50aW1lICsgZGVsYXkgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gcnVudGltZSArIGRlbGF5IC0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBkdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAxIHx8IGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNiKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2IocHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh0aWNrLCBkZWxheSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkgdGljaygpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZpbGVQcm9jZXNzb3IgPSBmdW5jdGlvbiBjcmVhdGVGaWxlUHJvY2Vzc29yKHByb2Nlc3NGbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBwZXJjZWl2ZWRQcm9ncmVzczogMCxcbiAgICAgICAgICAgIHBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcjogbnVsbCxcbiAgICAgICAgICAgIHByb2dyZXNzOiBudWxsLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgcGVyY2VpdmVkRHVyYXRpb246IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICByZXNwb25zZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uID0gb3B0aW9ucy5hbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjtcblxuICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoZmlsZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0ZuID0gZnVuY3Rpb24gcHJvZ3Jlc3NGbigpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBub3QgeWV0IHN0YXJ0ZWQgdGhlIHJlYWwgZG93bmxvYWQsIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IG1pZ2h0IG5vdCBnbyB0aHJvdWdoLCBmb3IgaW5zdGFuY2UsIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc2VydmVyIHRyb3VibGVcbiAgICAgICAgICAgICAgICAvLyBpZiBzdGF0ZS5wcm9ncmVzcyBpcyBudWxsLCB0aGUgc2VydmVyIGRvZXMgbm90IGFsbG93IGNvbXB1dGluZyBwcm9ncmVzcyBhbmQgd2Ugc2hvdyB0aGUgc3Bpbm5lciBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmR1cmF0aW9uID09PSAwIHx8IHN0YXRlLnByb2dyZXNzID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBhcyB3ZSdyZSBub3cgcHJvY2Vzc2luZywgZmlyZSB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBhcGkuZ2V0UHJvZ3Jlc3MoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uIGNvbXBsZXRlRm4oKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkLXBlcmNlaXZlZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RhcnQgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgYXBpLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIHNldCByZXF1ZXN0IHN0YXJ0XG4gICAgICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcGVyY2VpdmVkIHBlcmZvcm1hbmNlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyID0gY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmFrZSBwcm9ncmVzcyBpcyBkb25lLCBhbmQgYSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlJ3ZlIG5vdCB5ZXQgY2FsbGVkIHRoZSBjb21wbGV0ZSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlc3BvbnNlICYmIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxICYmICFzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gcmFuZG9tIGRlbGF5IGFzIGluIGEgbGlzdCBvZiBmaWxlcyB5b3Ugc3RhcnQgbm90aWNpbmdcbiAgICAgICAgICAgICAgICAvLyBmaWxlcyB1cGxvYWRpbmcgYXQgdGhlIGV4YWN0IHNhbWUgc3BlZWRcbiAgICAgICAgICAgICAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiA/IGdldFJhbmRvbU51bWJlcig3NTAsIDE1MDApIDogMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgcmVxdWVzdCBzbyB3ZSBjYW4gYWJvcnQgaXQgbGF0ZXJcbiAgICAgICAgICAgIHN0YXRlLnJlcXVlc3QgPSBwcm9jZXNzRm4oXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpbGUgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGZpbGUsXG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbWV0YWRhdGEgdG8gc2VuZCBhbG9uZ1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuXG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIChsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2ZlcilcbiAgICAgICAgICAgICAgICAvLyBsb2FkIGV4cGVjdHMgdGhlIGJvZHkgdG8gYmUgYSBzZXJ2ZXIgaWQgaWZcbiAgICAgICAgICAgICAgICAvLyB5b3Ugd2FudCB0byBtYWtlIHVzZSBvZiByZXZlcnRcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBwdXQgdGhlIHJlc3BvbnNlIGluIHN0YXRlIHNvIHdlIGNhbiBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgb3V0c2lkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZXNwb25zZSA9IGlzT2JqZWN0KHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAnJyArIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBwcm9ncmVzcyB0byAxIGFzIHdlJ3JlIG5vdyBkb25lXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWwgbG9hZCBpcyBkb25lIGxldCdzIHNoYXJlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcmVhbGx5IGRvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcGVyY2VpdmVkIHByb2dyZXNzIGlzIDEgKCB3YWl0IGZvciBwZXJjZWl2ZWQgcHJvZ3Jlc3MgdG8gY29tcGxldGUgKVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBwcm9ncmVzcyAoIG51bGwgKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiAmJiBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdHlwZSwgY29kZSwgYm9keVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbCB1cGRhdGVyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvdGhlcnMgYWJvdXQgdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc09iamVjdChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBwcm9jZXNzaW5nIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGFjdHVhbCBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGFjdHVhbCBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IGNvbXB1dGFibGUgPyBjdXJyZW50IC8gdG90YWwgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzRm4oKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gYWJvcnQgZG9lcyBub3QgZXhwZWN0IGEgdmFsdWVcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCB1cGRhdGVyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgdGhlIGFib3J0IGV2ZW50IHNvIHdlIGNhbiBzd2l0Y2ggdmlzdWFsc1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnLCBzdGF0ZS5yZXNwb25zZSA/IHN0YXRlLnJlc3BvbnNlLmJvZHkgOiBudWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGlkIGZvciB0aGlzIHRyYW5zZmVyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odHJhbnNmZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZSgndHJhbnNmZXInLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgLy8gbm8gcmVxdWVzdCBydW5uaW5nLCBjYW4ndCBhYm9ydFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5yZXF1ZXN0KSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIC8vIGFib3J0IGFjdHVhbCByZXF1ZXN0XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVxdWVzdC5hYm9ydCkgc3RhdGUucmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgcmVzcG9uc2Ugb2JqZWN0LCB3ZSd2ZSBjb21wbGV0ZWQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgc3RhdGUudGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHN0YXRlLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRQcm9ncmVzcyA9IGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uXG4gICAgICAgICAgICA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzID8gTWF0aC5taW4oc3RhdGUucHJvZ3Jlc3MsIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzKSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3MgfHwgbnVsbDtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0RHVyYXRpb24gPSBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvblxuICAgICAgICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihzdGF0ZS5kdXJhdGlvbiwgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmR1cmF0aW9uO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKHt9LCBvbigpLCB7XG4gICAgICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLCAvLyBzdGFydCBwcm9jZXNzaW5nIGZpbGVcbiAgICAgICAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgYWN0aXZlIHByb2Nlc3MgcmVxdWVzdFxuICAgICAgICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLFxuICAgICAgICAgICAgZ2V0RHVyYXRpb246IGdldER1cmF0aW9uLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGFzdEluZGV4T2YoJy4nKSkgfHwgbmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUZpbGVTdHViID0gZnVuY3Rpb24gY3JlYXRlRmlsZVN0dWIoc291cmNlKSB7XG4gICAgICAgIHZhciBkYXRhID0gW3NvdXJjZS5uYW1lLCBzb3VyY2Uuc2l6ZSwgc291cmNlLnR5cGVdO1xuXG4gICAgICAgIC8vIGlzIGJsb2Igb3IgYmFzZTY0LCB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoZSBuYW1lXG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iIHx8IGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgICAgICBkYXRhWzBdID0gc291cmNlLm5hbWUgfHwgZ2V0RGF0ZVN0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgICAgICAvLyBpZiBpcyBiYXNlNjQgZGF0YSB1cmkgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlIGF2ZXJhZ2Ugc2l6ZSBhbmQgdHlwZVxuICAgICAgICAgICAgZGF0YVsxXSA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBkYXRhWzJdID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIHVybFxuICAgICAgICAgICAgZGF0YVswXSA9IGdldEZpbGVuYW1lRnJvbVVSTChzb3VyY2UpO1xuICAgICAgICAgICAgZGF0YVsxXSA9IDA7XG4gICAgICAgICAgICBkYXRhWzJdID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogZGF0YVswXSxcbiAgICAgICAgICAgIHNpemU6IGRhdGFbMV0sXG4gICAgICAgICAgICB0eXBlOiBkYXRhWzJdLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaXNGaWxlID0gZnVuY3Rpb24gaXNGaWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUgfHwgKHZhbHVlIGluc3RhbmNlb2YgQmxvYiAmJiB2YWx1ZS5uYW1lKSk7XG4gICAgfTtcblxuICAgIHZhciBkZWVwQ2xvbmVPYmplY3QgPSBmdW5jdGlvbiBkZWVwQ2xvbmVPYmplY3Qoc3JjKSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoc3JjKSkgcmV0dXJuIHNyYztcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzQXJyYXkoc3JjKSA/IFtdIDoge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHYgPSBzcmNba2V5XTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdiAmJiBpc09iamVjdCh2KSA/IGRlZXBDbG9uZU9iamVjdCh2KSA6IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiBjcmVhdGVJdGVtKCkge1xuICAgICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgICB2YXIgc2VydmVyRmlsZVJlZmVyZW5jZSA9XG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgIHZhciBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgaXRlbSwgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgaXRlbSBhY3Jvc3Mgdmlld3NcbiAgICAgICAgdmFyIGlkID0gZ2V0VW5pcXVlSWQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgaXRlbSBzdGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgLy8gaXMgYXJjaGl2ZWRcbiAgICAgICAgICAgIGFyY2hpdmVkOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gaWYgaXMgZnJvemVuLCBubyBsb25nZXIgZmlyZXMgZXZlbnRzXG4gICAgICAgICAgICBmcm96ZW46IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyByZW1vdmVkIGZyb20gdmlld1xuICAgICAgICAgICAgcmVsZWFzZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcblxuICAgICAgICAgICAgLy8gZmlsZSBtb2RlbCByZWZlcmVuY2VcbiAgICAgICAgICAgIGZpbGU6IGZpbGUsXG5cbiAgICAgICAgICAgIC8vIGlkIG9mIGZpbGUgb24gc2VydmVyXG4gICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuXG4gICAgICAgICAgICAvLyBpZCBvZiBmaWxlIHRyYW5zZmVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdHJhbnNmZXJJZDogbnVsbCxcblxuICAgICAgICAgICAgLy8gaXMgYWJvcnRlZFxuICAgICAgICAgICAgcHJvY2Vzc2luZ0Fib3J0ZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBjdXJyZW50IGl0ZW0gc3RhdHVzXG4gICAgICAgICAgICBzdGF0dXM6IHNlcnZlckZpbGVSZWZlcmVuY2UgPyBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgOiBJdGVtU3RhdHVzLklOSVQsXG5cbiAgICAgICAgICAgIC8vIGFjdGl2ZSBwcm9jZXNzZXNcbiAgICAgICAgICAgIGFjdGl2ZUxvYWRlcjogbnVsbCxcbiAgICAgICAgICAgIGFjdGl2ZVByb2Nlc3NvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjYWxsYmFjayB1c2VkIHdoZW4gYWJvcnQgcHJvY2Vzc2luZyBpcyBjYWxsZWQgdG8gbGluayBiYWNrIHRvIHRoZSByZXNvbHZlIG1ldGhvZFxuICAgICAgICB2YXIgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZXJuYWxseSBhZGRlZCBpdGVtIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAgICAgICAvLyBpdGVtIGRhdGFcbiAgICAgICAgdmFyIHNldFN0YXR1cyA9IGZ1bmN0aW9uIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3RhdGUuc3RhdHVzID0gc3RhdHVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaXJlIGV2ZW50IHVubGVzcyB0aGUgaXRlbSBoYXMgYmVlbiBhcmNoaXZlZFxuICAgICAgICB2YXIgZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZWxlYXNlZCB8fCBzdGF0ZS5mcm96ZW4pIHJldHVybjtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuZmlyZS5hcHBseShhcGksIFtldmVudF0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZpbGUgZGF0YVxuICAgICAgICB2YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRGaWxlVHlwZSA9IGZ1bmN0aW9uIGdldEZpbGVUeXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUudHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEZpbGVTaXplID0gZnVuY3Rpb24gZ2V0RmlsZVNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5zaXplO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0RmlsZSA9IGZ1bmN0aW9uIGdldEZpbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBsb2dpYyB0byBsb2FkIGEgZmlsZVxuICAgICAgICAvL1xuICAgICAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoc291cmNlLCBsb2FkZXIsIG9ubG9hZCkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIGl0ZW0gc291cmNlXG4gICAgICAgICAgICBzdGF0ZS5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgICAgICAgIC8vIHNvdXJjZSBpcyBrbm93blxuICAgICAgICAgICAgYXBpLmZpcmVTeW5jKCdpbml0Jyk7XG5cbiAgICAgICAgICAgIC8vIGZpbGUgc3R1YiBpcyBhbHJlYWR5IHRoZXJlXG4gICAgICAgICAgICBpZiAoc3RhdGUuZmlsZSkge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlU3luYygnbG9hZC1za2lwJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgYSBzdHViIGZpbGUgb2JqZWN0IHdoaWxlIGxvYWRpbmcgdGhlIGFjdHVhbCBkYXRhXG4gICAgICAgICAgICBzdGF0ZS5maWxlID0gY3JlYXRlRmlsZVN0dWIoc291cmNlKTtcblxuICAgICAgICAgICAgLy8gc3RhcnRzIGxvYWRpbmdcbiAgICAgICAgICAgIGxvYWRlci5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtaW5pdCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdlJ2V2ZSByZWNlaXZlZCBhIHNpemUgaW5kaWNhdGlvbiwgbGV0J3MgdXBkYXRlIHRoZSBzdHViXG4gICAgICAgICAgICBsb2FkZXIub24oJ21ldGEnLCBmdW5jdGlvbihtZXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHNpemUgb2YgZmlsZSBzdHViXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZS5zaXplID0gbWV0YS5zaXplO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5hbWUgb2YgZmlsZSBzdHViXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZS5maWxlbmFtZSA9IG1ldGEuZmlsZW5hbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgc291cmNlLCB3ZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKG1ldGEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9IEZpbGVPcmlnaW4uTElNQk87XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBtZXRhLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzID0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtbWV0YScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHRoZSBmaWxlIGlzIG5vdyBsb2FkaW5nIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgICAgICAgICBsb2FkZXIub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FESU5HKTtcblxuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYW4gZXJyb3Igd2FzIHRocm93biB3aGlsZSBsb2FkaW5nIHRoZSBmaWxlLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBlcnJvciBzdGF0ZVxuICAgICAgICAgICAgbG9hZGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRF9FUlJPUik7XG5cbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXNlciBvciBhbm90aGVyIHByb2Nlc3MgYWJvcnRlZCB0aGUgZmlsZSBsb2FkIChjYW5ub3QgcmV0cnkpXG4gICAgICAgICAgICBsb2FkZXIub24oJ2Fib3J0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1hYm9ydCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRvbmUgbG9hZGluZ1xuICAgICAgICAgICAgbG9hZGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlJ3ZlIG5vdyBsb2FkZWQgdGhlIGZpbGUgdGhlIGxvYWRlciBpcyBubyBsb25nZXIgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc2Z1bGx5XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiBzdWNjZXNzKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgKHBvc3NpYmx5KSB0cmFuc2Zvcm1lZCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUgPSBpc0ZpbGUocmVzdWx0KSA/IHJlc3VsdCA6IHN0YXRlLmZpbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPICYmIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaXJlKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb3JpZ2luYWwgZmlsZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlID0gZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRF9FUlJPUik7XG4gICAgICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtZmlsZS1lcnJvcicsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoZSBvbmxvYWQgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vIHNlcnZlciBpZCwgbGV0J3MgZ2l2ZSB0aGlzIGZpbGUgdGhlIGZ1bGwgdHJlYXRtZW50XG4gICAgICAgICAgICAgICAgb25sb2FkKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgbG9hZGVyIHNvdXJjZSBkYXRhXG4gICAgICAgICAgICBsb2FkZXIuc2V0U291cmNlKHNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIHNldCBhcyBhY3RpdmUgbG9hZGVyXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBsb2FkZXI7XG5cbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIHNvdXJjZSBkYXRhXG4gICAgICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXRyeUxvYWQgPSBmdW5jdGlvbiByZXRyeUxvYWQoKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFib3J0TG9hZCA9IGZ1bmN0aW9uIGFib3J0TG9hZCgpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmVMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBsb2dpYyB0byBwcm9jZXNzIGEgZmlsZVxuICAgICAgICAvL1xuICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MocHJvY2Vzc29yLCBvbnByb2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3Npbmcgd2FzIGFib3J0ZWRcbiAgICAgICAgICAgIGlmIChzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGFib3J0IGNhbGxiYWNrXG4gICAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiBubyBmaWxlIGxvYWRlZCB3ZSdsbCB3YWl0IGZvciB0aGUgbG9hZCBldmVudFxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgICAgYXBpLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MocHJvY2Vzc29yLCBvbnByb2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0dXAgcHJvY2Vzc29yXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2xvYWQnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZWdpc3RlciB0cmFuc2ZlciBpZFxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCd0cmFuc2ZlcicsIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdGhlIHVwbG9hZFxuICAgICAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSB0cmFuc2ZlcklkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbignbG9hZC1wZXJjZWl2ZWQnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVyIHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1zdGFydCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUik7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1lcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2Fib3J0JywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBmaWxlIHdhcyB1cGxvYWRlZCBidXQgcHJvY2Vzc2luZyB3YXMgY2FuY2VsbGVkIGR1cmluZyBwZXJjZWl2ZWQgcHJvY2Vzc29yIHRpbWUgc3RvcmUgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgICAgIC8vIGhhcyB0aW1lb3V0IHNvIGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggcmVtb3ZlIGFjdGlvblxuICAgICAgICAgICAgICAgIGlmIChhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gd2hlbiBzdWNjZXNzZnVsbHkgdHJhbnNmb3JtZWRcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2FzIGFyY2hpdmVkIGluIHRoZSBtZWFuIHRpbWUsIGRvbid0IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgZmlsZSFcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IucHJvY2VzcyhmaWxlLCBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxuICAgICAgICAgICAgdmFyIGVycm9yID0gY29uc29sZS5lcnJvcjtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZmlsZVxuICAgICAgICAgICAgb25wcm9jZXNzKHN0YXRlLmZpbGUsIHN1Y2Nlc3MsIGVycm9yKTtcblxuICAgICAgICAgICAgLy8gc2V0IGFzIGFjdGl2ZSBwcm9jZXNzb3JcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVxdWVzdFByb2Nlc3NpbmcgPSBmdW5jdGlvbiByZXF1ZXN0UHJvY2Vzc2luZygpIHtcbiAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFib3J0UHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGFib3J0UHJvY2Vzc2luZygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5hY3RpdmVQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWFib3J0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gZnVuY3Rpb24gYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3Nvci5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9naWMgdG8gcmV2ZXJ0IGEgcHJvY2Vzc2VkIGZpbGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJldmVydCA9IGZ1bmN0aW9uIHJldmVydChyZXZlcnRGaWxlVXBsb2FkLCBmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGEgY29tcGxldGVkIHVwbG9hZCB3aWxsIGhhdmUgYSBzZXJ2ZXJGaWxlUmVmZXJlbmNlLCBhIGZhaWxlZCBjaHVua2VkIHVwbG9hZCB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIGdldHRpbmcgYSBzZXJ2ZXJJZCBzdWNjZWVkZWQgYnV0ID49MCBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkIHdpbGwgaGF2ZSB0cmFuc2ZlcklkIHNldFxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJUcmFuc2ZlcklkID1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN0YXRlLnRyYW5zZmVySWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjYW5ub3QgcmV2ZXJ0IHdpdGhvdXQgYSBzZXJ2ZXIgaWQgZm9yIHRoaXMgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJUcmFuc2ZlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJldmVydCB0aGUgdXBsb2FkIChmaXJlIGFuZCBmb3JnZXQpXG4gICAgICAgICAgICAgICAgcmV2ZXJ0RmlsZVVwbG9hZChcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyVHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBmaWxlIHNlcnZlciBpZCBhbmQgdHJhbnNmZXIgaWQgYXMgbm93IGl0J3Mgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGVycm9yIHN0YXRlIHdoZW4gcmV2ZXJ0aW5nIGlzIG9wdGlvbmFsLCBpdCB3aWxsIGFsd2F5cyByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2ggbm8gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydC1lcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIGV2ZW50XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGV4cG9zZWQgbWV0aG9kc1xuICAgICAgICB2YXIgX3NldE1ldGFkYXRhID0gZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBrZXlzWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhdGEgPSBkYXRhW2tleV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbXBhcmUgb2xkIHZhbHVlIGFnYWluc3QgbmV3IHZhbHVlLCBpZiB0aGV5J3JlIHRoZSBzYW1lLCB3ZSdyZSBub3QgdXBkYXRpbmdcbiAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShkYXRhW2xhc3RdKSA9PT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB2YWx1ZVxuICAgICAgICAgICAgZGF0YVtsYXN0XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHVwZGF0ZVxuICAgICAgICAgICAgZmlyZSgnbWV0YWRhdGEtdXBkYXRlJywge1xuICAgICAgICAgICAgICAgIGtleTogcm9vdCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFbcm9vdF0sXG4gICAgICAgICAgICAgICAgc2lsZW50OiBzaWxlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmVPYmplY3Qoa2V5ID8gbWV0YWRhdGFba2V5XSA6IG1ldGFkYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9yaWdpbiA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlcnZlcklkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcklkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRyYW5zZmVySWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihzdGF0ZS5maWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsZUV4dGVuc2lvbjogeyBnZXQ6IGdldEZpbGVFeHRlbnNpb24gfSxcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogeyBnZXQ6IGdldEZpbGVUeXBlIH0sXG4gICAgICAgICAgICAgICAgZmlsZVNpemU6IHsgZ2V0OiBnZXRGaWxlU2l6ZSB9LFxuICAgICAgICAgICAgICAgIGZpbGU6IHsgZ2V0OiBnZXRGaWxlIH0sXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUuX3JlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZ2V0TWV0YWRhdGE6IGdldE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHNldE1ldGFkYXRhOiBmdW5jdGlvbiBzZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0TWV0YWRhdGEoa2V5LCBkYXRhW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbUFQSVtuYW1lXSA9IGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBhYm9ydExvYWQ6IGFib3J0TG9hZCxcbiAgICAgICAgICAgICAgICByZXRyeUxvYWQ6IHJldHJ5TG9hZCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UHJvY2Vzc2luZzogcmVxdWVzdFByb2Nlc3NpbmcsXG4gICAgICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nOiBhYm9ydFByb2Nlc3NpbmcsXG5cbiAgICAgICAgICAgICAgICBsb2FkOiBsb2FkLFxuICAgICAgICAgICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbigpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyZWV6ZTogZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLmZyb3plbiA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLnJlbGVhc2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWxlYXNlZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yZWxlYXNlZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYXJjaGl2ZTogZnVuY3Rpb24gYXJjaGl2ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5hcmNoaXZlZCA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJjaGl2ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuYXJjaGl2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2Ugc291cmNlIGFuZCBmaWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIHNldEZpbGU6IGZ1bmN0aW9uIHNldEZpbGUoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLmZpbGUgPSBmaWxlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgICAgIHZhciBpdGVtQVBJID0gY3JlYXRlT2JqZWN0KGFwaSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1BUEk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlRdWVyeShpdGVtcywgcXVlcnkpIHtcbiAgICAgICAgLy8ganVzdCByZXR1cm4gZmlyc3QgaW5kZXhcbiAgICAgICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGludmFsaWQgcXVlcmllc1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGl0ZW0gYnkgaWQgKG9yIC0xIGlmIG5vdCBmb3VuZClcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gcXVlcnk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUJ5SWQgPSBmdW5jdGlvbiBnZXRJdGVtQnlJZChpdGVtcywgaXRlbUlkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEl0ZW1JbmRleEJ5UXVlcnkoaXRlbXMsIGl0ZW1JZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXNbaW5kZXhdIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBmZXRjaEJsb2IgPSBmdW5jdGlvbiBmZXRjaEJsb2IodXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYicsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhoZWFkZXJzKS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoJ2xvYWQnLCB4aHIuc3RhdHVzLCBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksIGhlYWRlcnMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgZXJyb3IoY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25oZWFkZXJzID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICBoZWFkZXJzKGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RG9tYWluRnJvbVVSTCA9IGZ1bmN0aW9uIGdldERvbWFpbkZyb21VUkwodXJsKSB7XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgdXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKCdibG9iOicsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XSk/OlxcL1xcLy8sICckMScpXG4gICAgICAgICAgICAuc3BsaXQoJy8nKVswXTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRXh0ZXJuYWxVUkwgPSBmdW5jdGlvbiBpc0V4dGVybmFsVVJMKHVybCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHVybC5pbmRleE9mKCc6JykgPiAtMSB8fCB1cmwuaW5kZXhPZignLy8nKSA+IC0xKSAmJlxuICAgICAgICAgICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkeW5hbWljTGFiZWwgPSBmdW5jdGlvbiBkeW5hbWljTGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24obGFiZWwpID8gbGFiZWwuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpIDogbGFiZWw7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc01vY2tJdGVtID0gZnVuY3Rpb24gaXNNb2NrSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0VXBkYXRlZCA9IGZ1bmN0aW9uIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICBzdGF0ZS5saXN0VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNUycsIHsgaXRlbXM6IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIHZhciBvcHRpb25hbFByb21pc2UgPSBmdW5jdGlvbiBvcHRpb25hbFByb21pc2UoZm4pIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgc29ydEl0ZW1zID0gZnVuY3Rpb24gc29ydEl0ZW1zKHN0YXRlLCBjb21wYXJlKSB7XG4gICAgICAgIHN0YXRlLml0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoY3JlYXRlSXRlbUFQSShhKSwgY3JlYXRlSXRlbUFQSShiKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIGl0ZW0gYmFzZWQgb24gc3RhdGVcbiAgICB2YXIgZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUgPSBmdW5jdGlvbiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeSxcbiAgICAgICAgICAgICAgICBfcmVmJHN1Y2Nlc3MgPSBfcmVmLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBfcmVmJGZhaWx1cmUgPSBfcmVmLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9IF9yZWYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncXVlcnknLCAnc3VjY2VzcycsICdmYWlsdXJlJ10pO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1IYW5kbGVyKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWN0aW9ucyA9IGZ1bmN0aW9uIGFjdGlvbnMoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBYm9ydHMgYWxsIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFCT1JUX0FMTDogZnVuY3Rpb24gQUJPUlRfQUxMKCkge1xuICAgICAgICAgICAgICAgIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5mcmVlemUoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyBpbml0aWFsIGZpbGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERJRF9TRVRfRklMRVM6IGZ1bmN0aW9uIERJRF9TRVRfRklMRVMoX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjIkdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMiR2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBfcmVmMiR2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBtYXAgdmFsdWVzIHRvIGZpbGUgb2JqZWN0c1xuICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IHZhbHVlLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGUuc291cmNlID8gZmlsZS5zb3VyY2UgOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZmlsZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGZpbGVzLCBpZiBmaWxlIGlzIGluIGxpc3QsIGxlYXZlIGl0IGJlLCBpZiBub3QsIHJlbW92ZVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXRlbXMgc2hvdWxkIGJlIG1vdmVkXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgICAgICAgICAgYWN0aXZlSXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0ZW0gbm90IGlzIGluIG5ldyB2YWx1ZSwgcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICFmaWxlcy5maW5kKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHJlbW92ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBuZXcgZmlsZXNcbiAgICAgICAgICAgICAgICBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpbGUgaXMgYWxyZWFkeSBpbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNvdXJjZSA9PT0gZmlsZS5zb3VyY2UgfHwgaXRlbS5maWxlID09PSBmaWxlLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgaW4gbGlzdCwgYWRkXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FERF9JVEVNJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuTk9ORSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEFEQVRBOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fTUVUQURBVEEoX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmMy5pZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSBfcmVmMy5jaGFuZ2U7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNpbGVudCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGNsb3NlIHN1Y2Nlc3Npb24gd2UgY29tYmluZWQgYWxsIGNhbGxzIHRvZ2V0aGVyIHRvIHNhdmUgcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJldmVydCBhbmQgYXR0ZW1wdCB0byB1cGxvYWQgd2hlbiB3ZSdyZSB1cGxvYWRpbmcgdG8gYSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnSVNfQVNZTkMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIHVwZGF0ZSB0aGUgb3V0cHV0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZVByZXBhcmVGaWxlID0gcXVlcnkoJ0dFVF9CRUZPUkVfUFJFUEFSRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGlzIGxvY2FsIGl0ZW0gd2UgbmVlZCB0byBlbmFibGUgdXBsb2FkIGJ1dHRvbiBzbyBjaGFuZ2UgY2FuIGJlIHByb3BhZ2F0ZWQgdG8gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBhc3luYyBzY2VuYXJpb3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwbG9hZCA9IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHB1c2ggdGhpcyBmb3J3YXJkIGEgYml0IHNvIHRoZSBpbnRlcmZhY2UgaXMgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldmVydCA9IGZ1bmN0aW9uIHJldmVydChkb1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZG9VcGxvYWQgPyB1cGxvYWQgOiBmdW5jdGlvbigpIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydChkb1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIHJlLXVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldmVydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IHVwbG9hZGluZywgY2FuY2VsIHVwbG9hZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgTU9WRV9JVEVNOiBmdW5jdGlvbiBNT1ZFX0lURU0oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmNC5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfcmVmNC5pbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgc3RhdGUuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIHN0YXRlLml0ZW1zLnNwbGljZShjdXJyZW50SW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFNPUlQ6IGZ1bmN0aW9uIFNPUlQoX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZSA9IF9yZWY1LmNvbXBhcmU7XG4gICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NPUlRfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQUREX0lURU1TOiBmdW5jdGlvbiBBRERfSVRFTVMoX3JlZjYpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBfcmVmNi5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfcmVmNi5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBfcmVmNi5pbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkc3VjY2VzcyA9IF9yZWY2LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNiRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjYkc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkZmFpbHVyZSA9IF9yZWY2LmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmNiRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjYkZmFpbHVyZTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxJdGVtcyA9IHF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gaW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gMCA6IHRvdGFsSXRlbXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkRmlsZSA9IGZ1bmN0aW9uIGlzVmFsaWRGaWxlKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaWxlKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhzb3VyY2UubmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhaXNFbXB0eShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkSXRlbXMgPSBpdGVtcy5maWx0ZXIoaXNWYWxpZEZpbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gdmFsaWRJdGVtcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Uuc291cmNlIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogc291cmNlLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBRERfSVRFTTogZnVuY3Rpb24gQUREX0lURU0oX3JlZjcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjcuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRpbmRleCA9IF9yZWY3LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9yZWY3JGluZGV4ID09PSB2b2lkIDAgPyAtMSA6IF9yZWY3JGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY3LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRzdWNjZXNzID0gX3JlZjcuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWY3JHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNyRzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRmYWlsdXJlID0gX3JlZjcuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSA9IF9yZWY3JGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNyRmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyRvcHRpb25zID0gX3JlZjcub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWY3JG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjckb3B0aW9ucztcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBzb3VyY2Ugc3VwcGxpZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdObyBzb3VyY2UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgZmlsZSBpdGVtcywgdXNlZCB0byBmaWx0ZXIgZHJvcHBlZCBkaXJlY3RvcnkgY29udGVudHNcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzRmlsZShzb3VyY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWwgc2lsZW50bHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgdGhlcmUncyBzdGlsbCByb29tIGluIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNSb29tRm9ySXRlbShzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgYWxsb3dlZCwgd2UgY2FuJ3QgcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gaXMgYWxsb3dlZCBidXQgd2UncmUgbm90IGFsbG93ZWQgdG8gcmVwbGFjZSBpdCB3ZSBleGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgJiYgIXN0YXRlLm9wdGlvbnMuYWxsb3dSZXBsYWNlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogbnVsbCB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgcmVwbGFjZSB0aGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAvLyBpZCBvZiBmaXJzdCBpdGVtIHdlJ3JlIGFib3V0IHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZW0gPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcylbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaGFzIGJlZW4gcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXJ2ZXIgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmNlUmV2ZXJ0ID0gcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VSZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gYWRkIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7IC8vIG5vIG5lZWQgdG8gaGFuZGxlIHRoaXMgY2F0Y2ggc3RhdGUgZm9yIG5vd1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmaXJzdCBpdGVtIGFzIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhpcyBpdGVtXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IF9pdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGRpZCB0aGUgZmlsZSBvcmlnaW5hdGVcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSAnbG9jYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnbGltYm8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBibGFuayBpdGVtXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBkaWQgdGhpcyBmaWxlIGNvbWUgZnJvbVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW5wdXQgZmlsZSBuZXZlciBoYXMgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgbWV0YSBkYXRhXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5tZXRhZGF0YSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShrZXksIG9wdGlvbnMubWV0YWRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVycygnRElEX0NSRUFURV9JVEVNJywgaXRlbSwgeyBxdWVyeTogcXVlcnksIGRpc3BhdGNoOiBkaXNwYXRjaCB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4IGlmIGlzIG5vdCBhbGxvd2VkIHRvIHBpY2sgbG9jYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaXRlbUluc2VydExvY2F0aW9uRnJlZWRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGl0ZW1JbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAtMSA6IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbSB0byBsaXN0XG4gICAgICAgICAgICAgICAgaW5zZXJ0SXRlbShzdGF0ZS5pdGVtcywgaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGdldCBhIHF1aWNrIHJlZmVyZW5jZSB0byB0aGUgaXRlbSBpZFxuICAgICAgICAgICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBvYnNlcnZlIGl0ZW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgaXRlbS5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0lOSVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1pbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9MT0FEJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLW1ldGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLXByb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTJywgeyBpZDogaWQsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShlcnJvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgY2xpZW50IGVycm9yLCBubyB3YXkgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA+PSA0MDAgJiYgZXJyb3IuY29kZSA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBlcnJvci5jb2RlICsgJyAoJyArIGVycm9yLmJvZHkgKyAnKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3QgdGhlIGZpbGUgc28gY2FuIGJlIGRlYWx0IHdpdGggdGhyb3VnaCBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBwb3NzaWJsZSBzZXJ2ZXIgZXJyb3IsIHNvIG1pZ2h0IGJlIHBvc3NpYmxlIHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLWZpbGUtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvci5zdGF0dXMsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLWFib3J0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1za2lwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub24oJ21ldGFkYXRhLXVwZGF0ZScsIGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpbGUoaXRlbS5maWxlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBREFUQScsIHsgaWQ6IGlkLCBjaGFuZ2U6IGNoYW5nZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gc2hvdWxkIG5vdCBhZGQgdGhpcyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgaW50ZXJlc3RlZCBpbiBtZXRhZGF0YSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEFEQVRBJywgeyBpZDogaWQsIGNoYW5nZTogY2hhbmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBwbHVnaW5zIGRlY2lkZSBpZiB0aGUgb3V0cHV0IGRhdGEgc2hvdWxkIGJlIHByZXBhcmVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIHdlJ2xsIGRvIHRoaXMgYW5kIHdhaXQgZm9yIGlkbGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZVByZXBhcmVGaWxlID0gcXVlcnkoJ0dFVF9CRUZPUkVfUFJFUEFSRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZENvbXBsZXRlID0gZnVuY3Rpb24gbG9hZENvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQcmVwYXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlkbGUgc3RhdGUgYW5kIHRoZW4gcnVuIFBSRVBBUkVfT1VUUFVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBsb2FkZWQsIGFsbG93IHBsdWdpbnMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gLSByZWFkIGRhdGEgKHF1aWNrbHkpXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYWRkIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0RJRF9MT0FEX0lURU0nLCBpdGVtLCB7IHF1ZXJ5OiBxdWVyeSwgZGlzcGF0Y2g6IGRpc3BhdGNoIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfQUREX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAhZS5lcnJvciB8fCAhZS5zdGF0dXMpIHJldHVybiBoYW5kbGVBZGQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGUuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXByb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJywgeyBpZDogaWQsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yKShlcnJvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNlcnZlckZpbGVSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZDogaWQsIHZhbHVlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1yZXZlcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZDogaWQsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbGV0IHZpZXcga25vdyB0aGUgaXRlbSBoYXMgYmVlbiBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgbG9hZGluZyB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgdmFyIF9yZWY4ID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXIgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IF9yZWY4LnVybCxcbiAgICAgICAgICAgICAgICAgICAgbG9hZCA9IF9yZWY4LmxvYWQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBfcmVmOC5yZXN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaCA9IF9yZWY4LmZldGNoO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5sb2FkKFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGaWxlTG9hZGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N0cmluZyhzb3VyY2UpICYmIGlzRXh0ZXJuYWxVUkwoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHJlbW90ZSB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmZXRjaEJsb2IgLy8gdHJ5IHRvIGZldGNoIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCByZXN0b3JlKSAvLyBsaW1ib1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIGZpbGUgaXMgbG9hZGVkIHNvIGl0IGNhbiBiZSBwaXBlZCB0aHJvdWdoIHRoZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBwcm9jZXNzIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUOiBmdW5jdGlvbiBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUKF9yZWY5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmOS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gX3JlZjkuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjkkZmFpbHVyZSA9IF9yZWY5LmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmOSRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjkkZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciByZXNwb25zZSBpZiBpdGVtIGFyY2hpdmVkXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIHdhaXRpbmcgdG8gYmUgcHJlcGFyZWRcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgaXRlbS5maWxlLCB7IHF1ZXJ5OiBxdWVyeSwgaXRlbTogaXRlbSB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgYmVpbmcgcHJlcGFyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQ09NUExFVEVfTE9BRF9JVEVNOiBmdW5jdGlvbiBDT01QTEVURV9MT0FEX0lURU0oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmMTAuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9yZWYxMC5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZGF0YS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBkYXRhLnNvdXJjZTtcblxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICAgICAgICAgIHZhciBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxldCBpbnRlcmZhY2Uga25vdyB0aGUgaXRlbSBoYXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gaXRlbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkIGFuZCBhZGRlZCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGl0ZW1zIHNvIGNhbiBub3cgYmUgc2FmZWx5IHJldHVybmVkIGZvciB1c2VcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIHNlcnZlciBmaWxlIHdlIG5lZWQgdG8gc2hvdyBhIGRpZmZlcmVudCBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0xPQURfTE9DQUxfSVRFTScsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpcyBhIHRlbXAgc2VydmVyIGZpbGUgd2UgcHJldmVudCBhc3luYyB1cGxvYWQgY2FsbCBoZXJlIChhcyB0aGUgZmlsZSBpcyBhbHJlYWR5IG9uIHRoZSBzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLnNlcnZlcklkIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlkIHdlIGFyZSBhbGxvd2VkIHRvIHVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseSwgbGV0cyBkbyBpdFxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSgnSVNfQVNZTkMnKSAmJiBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IGxvYWRpbmcgdGhlIHNvdXJjZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgICAgICAgaXRlbS5yZXRyeUxvYWQoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX0lURU1fUFJFUEFSRTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIF9zdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5ub3QgYmUgcXVldWVkIChvciBpcyBhbHJlYWR5IHF1ZXVlZClcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZyA9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3Npbmcgd2VudCB3cm9uZyBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1I7XG5cbiAgICAgICAgICAgICAgICAvLyBub3QgcmVhZHkgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzTm93ID0gZnVuY3Rpb24gcHJvY2Vzc05vdygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmhpZGRlbiA/IHByb2Nlc3NOb3coKSA6IHNldFRpbWVvdXQocHJvY2Vzc05vdywgMzIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgZG9uZSBwcm9jZXNzaW5nIG9yIHRyaWVkIHRvIHJldmVydCBidXQgZGlkbid0IHdvcmssIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBkb24ndCBjb250aW51ZSB3aXRoIHByb2Nlc3NpbmcgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4ocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBxdWV1ZWQgZm9yIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVxdWVzdFByb2Nlc3NpbmcoKTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1BST0NFU1NfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGZhaWx1cmU6IGZhaWx1cmUgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUFJPQ0VTU19JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhQYXJhbGxlbFVwbG9hZHMgPSBxdWVyeSgnR0VUX01BWF9QQVJBTExFTF9VUExPQURTJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORylcbiAgICAgICAgICAgICAgICAgICAgLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgICAgICAgICBpZiAodG90YWxDdXJyZW50VXBsb2FkcyA9PT0gbWF4UGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHF1ZXVlIGZvciBsYXRlciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgaXQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgbm90IHF1ZXVlZCBvciBpcyBhbHJlYWR5IHByb2Nlc3NpbmcgZXhpdCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzTmV4dCA9IGZ1bmN0aW9uIHByb2Nlc3NOZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHF1ZXVldWQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlRW50cnkgPSBzdGF0ZS5wcm9jZXNzaW5nUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBubyBpdGVtcyBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWVFbnRyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBpdGVtIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBxdWV1ZUVudHJ5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHF1ZXVlRW50cnkuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBxdWV1ZUVudHJ5LmZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtUmVmZXJlbmNlID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdGVtIHdhcyBhcmNoaXZlZCB3aGlsZSBpbiBxdWV1ZSwganVtcCB0byBuZXh0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbVJlZmVyZW5jZSB8fCBpdGVtUmVmZXJlbmNlLmFyY2hpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZWQgaXRlbVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUk9DRVNTX0lURU0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBxdWVyeTogaWQsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGZhaWx1cmU6IGZhaWx1cmUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWNvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3JpZ2luIGlzIGxvY2FsLCBhbmQgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcsIHRyaWdnZXIgcmVtb3ZlIG9mIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHJldmVydCB3aWxsIHJlbW92ZSBmaWxlIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50VXBsb2FkID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50VXBsb2FkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihzZXJ2ZXIucmVtb3ZlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmVtb3ZlKGl0ZW0uc291cmNlLCBub29wLCBub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBpdGVtcyBwcm9jZXNzZWQ/IE5vIGVycm9ycz9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEl0ZW1zUHJvY2Vzc2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfSVRFTVNfQllfU1RBVFVTJywgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKS5sZW5ndGggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxJdGVtc1Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgZmlsZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzdGF0ZS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJvY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmlsZVByb2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci5wcm9jZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rVHJhbnNmZXJJZDogaXRlbS50cmFuc2ZlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NlcnZlcjogb3B0aW9ucy5zZXJ2ZXIucGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rVXBsb2Fkczogb3B0aW9ucy5jaHVua1VwbG9hZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rRm9yY2U6IG9wdGlvbnMuY2h1bmtGb3JjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtSZXRyeURlbGF5czogb3B0aW9ucy5jaHVua1JldHJ5RGVsYXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjogcXVlcnkoJ0dFVF9BTExPV19NSU5JTVVNX1VQTE9BRF9EVVJBVElPTicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGFib3V0IHRvIGJlIHByb2Nlc3NlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgdHJhbnNmb3JtIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSwgaXRlbTogaXRlbSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGU6IGZpbGUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFVFJZX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFUVVFU1RfUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyksIGNyZWF0ZUl0ZW1BUEkoaXRlbSkpLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVMRUFTRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVsZWFzZSgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVGcm9tVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21WaWV3KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgaWQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJjaGl2ZSB0aGUgaXRlbSwgdGhpcyBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtQnlJZChzdGF0ZS5pdGVtcywgaWQpLmFyY2hpdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0ZWxsIHRoZSB2aWV3IHRoZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRU1PVkVfSVRFTScsIHsgZXJyb3I6IG51bGwsIGlkOiBpZCwgaXRlbTogaXRlbSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgdGhlIGxpc3QgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgZmlsZSBhbmQgdGhlIGBzZXJ2ZXIucmVtb3ZlYCBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkLFxuICAgICAgICAgICAgICAgIC8vIHNlbmQgc291cmNlIHRoZXJlIHNvIGRldiBjYW4gcmVtb3ZlIGZpbGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihzZXJ2ZXIucmVtb3ZlKSAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlbW92ZSAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX1JFTU9WRScsIHsgaWQ6IGl0ZW0uaWQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVJlbW92ZUVycm9yKShzdGF0dXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpcyByZXF1ZXN0aW5nIHJldmVydCBhbmQgY2FuIHJldmVydCBuZWVkIHRvIGNhbGwgcmV2ZXJ0IGhhbmRsZXIgKG5vdCBjYWxsaW5nIHJlcXVlc3RfIGJlY2F1c2UgdGhhdCB3b3VsZCBhbHNvIHRyaWdnZXIgYmVmb3JlUmVtb3ZlSG9vaylcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMucmV2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gIT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlcnZlcklkICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2h1bmtlZCB1cGxvYWRzIGFyZSBlbmFibGVkIGFuZCB3ZSdyZSB1cGxvYWRpbmcgaW4gY2h1bmtzIGZvciB0aGlzIHNwZWNpZmljIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBmaWxlIGlzbid0IGJpZyBlbm91Z2ggZm9yIGNodW5rZWQgdXBsb2FkcyBidXQgY2h1bmtGb3JjZSBpcyBzZXQgdGhlbiBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgYmVmb3JlIHJlbW92aW5nIGZyb20gdGhlIHZpZXcuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5vcHRpb25zLmNodW5rVXBsb2FkcyAmJiBpdGVtLmZpbGUuc2l6ZSA+IHN0YXRlLm9wdGlvbnMuY2h1bmtTaXplKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIHN0YXRlLm9wdGlvbnMuY2h1bmtGb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIEFCT1JUX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0TG9hZCgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIEFCT1JUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VydmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWJvcnRcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGluc3RhbnQgdXBsb2FkaW5nLCByZXZlcnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbnN0YW50IHVwbG9hZGluZyB0aGUgZmlsZSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBpZiB3ZSByZXZlcnQsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYSBiZWZvcmUgcmVtb3ZlIGZpbGUgaG9vayBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gcnVuIGl0IG5vd1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVSZXZlcnQgPSBmdW5jdGlvbiBoYW5kbGVSZXZlcnQoc2hvdWxkUmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gcXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RSZW1vdmVSZXN1bHQgPSBmbihjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydChyZXF1ZXN0UmVtb3ZlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RSZW1vdmVSZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4oaGFuZGxlUmV2ZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQgfHwgaXNNb2NrSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgU0VUX09QVElPTlM6IGZ1bmN0aW9uIFNFVF9PUFRJT05TKF9yZWYxMSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3JlZjExLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBrZXlzIHBhc3NlZFxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgcHJpb3JpdGl6ZWQga2V5ZWQgdG8gaW5jbHVkZSAocmVtb3ZlIG9uY2Ugbm90IGluIG9wdGlvbnMgb2JqZWN0KVxuICAgICAgICAgICAgICAgIHZhciBwcmlvcml0aXplZE9wdGlvbktleXMgPSBQcmlvcml0aXplZE9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uS2V5cy5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGhlIGtleXMsIHByaW9yaXRpemVkIGZpcnN0LCB0aGVuIHJlc3RcbiAgICAgICAgICAgICAgICB2YXIgb3JkZXJlZE9wdGlvbktleXMgPSBbXS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIF90b0NvbnN1bWFibGVBcnJheShwcmlvcml0aXplZE9wdGlvbktleXMpLFxuICAgICAgICAgICAgICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwcmlvcml0aXplZE9wdGlvbktleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzcGF0Y2ggc2V0IGV2ZW50IGZvciBlYWNoIG9wdGlvblxuICAgICAgICAgICAgICAgIG9yZGVyZWRPcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdTRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIFByaW9yaXRpemVkT3B0aW9ucyA9IFsnc2VydmVyJ107XG5cbiAgICB2YXIgZm9ybWF0RmlsZW5hbWUgPSBmdW5jdGlvbiBmb3JtYXRGaWxlbmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRWxlbWVudCQxID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgICAgIHZhciBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc2NyaWJlQXJjID0gZnVuY3Rpb24gZGVzY3JpYmVBcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXJjU3dlZXApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIFsnTScsIHN0YXJ0LngsIHN0YXJ0LnksICdBJywgcmFkaXVzLCByYWRpdXMsIDAsIGFyY1N3ZWVwLCAwLCBlbmQueCwgZW5kLnldLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgdmFyIHBlcmNlbnRhZ2VBcmMgPSBmdW5jdGlvbiBwZXJjZW50YWdlQXJjKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGFyY1N3ZWVwID0gMTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSAmJiB0byAtIGZyb20gPD0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiB0byAmJiBmcm9tIC0gdG8gPj0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlQXJjKFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICAgICAgICBhcmNTd2VlcFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIHN0YXJ0IGF0IDBcbiAgICAgICAgcHJvcHMuc3BpbiA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHByb3BzLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIC8vIHN2Z1xuICAgICAgICB2YXIgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICAgICB9KTtcblxuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICAgICAgcm9vdC5yZWYuc3ZnID0gc3ZnO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5hbGlnbikge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB3aWR0aCBvZiBzdHJva2VcbiAgICAgICAgdmFyIHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNpemUgb2YgcmluZ1xuICAgICAgICB2YXIgc2l6ZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuXG4gICAgICAgIC8vIHJpbmcgc3RhdGVcbiAgICAgICAgdmFyIHJpbmdGcm9tID0gMDtcbiAgICAgICAgdmFyIHJpbmdUbyA9IDA7XG5cbiAgICAgICAgLy8gbm93IGluIGJ1c3kgbW9kZVxuICAgICAgICBpZiAocHJvcHMuc3Bpbikge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gMC41O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gcHJvcHMucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcGVyY2VudGFnZUFyYyhzaXplLCBzaXplLCBzaXplIC0gcmluZ1N0cm9rZVdpZHRoLCByaW5nRnJvbSwgcmluZ1RvKTtcblxuICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ2QnLCBjb29yZGluYXRlcyk7XG5cbiAgICAgICAgLy8gaGlkZSB3aGlsZSBjb250YWlucyAwIHZhbHVlXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS1vcGFjaXR5JywgcHJvcHMuc3BpbiB8fCBwcm9wcy5wcm9ncmVzcyA+IDAgPyAxIDogMCk7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICB0YWc6ICdkaXYnLFxuICAgICAgICBuYW1lOiAncHJvZ3Jlc3MtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ3Byb2dyZXNzJywgJ3NwaW4nLCAnYWxpZ24nXSxcbiAgICAgICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgICAgIHN0aWZmbmVzczogMC45NSxcbiAgICAgICAgICAgICAgICAgICAgZGFtcGluZzogMC42NSxcbiAgICAgICAgICAgICAgICAgICAgbWFzczogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlJDEgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IChwcm9wcy5pY29uIHx8ICcnKSArICgnPHNwYW4+JyArIHByb3BzLmxhYmVsICsgJzwvc3Bhbj4nKTtcblxuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQxID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkO1xuICAgICAgICB2YXIgc2hvdWxkRGlzYWJsZSA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpIHx8IHByb3BzLm9wYWNpdHkgPT09IDA7XG5cbiAgICAgICAgaWYgKHNob3VsZERpc2FibGUgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNhYmxlICYmIGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZpbGVBY3Rpb25CdXR0b24gPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnYnV0dG9uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgIH0sXG5cbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgbmFtZTogJ2ZpbGUtYWN0aW9uLWJ1dHRvbicsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydsYWJlbCddLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDEsXG4gICAgfSk7XG5cbiAgICB2YXIgdG9OYXR1cmFsRmlsZVNpemUgPSBmdW5jdGlvbiB0b05hdHVyYWxGaWxlU2l6ZShieXRlcykge1xuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9XG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcuJztcbiAgICAgICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwMDA7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgICAgdmFyIF9vcHRpb25zJGxhYmVsQnl0ZXMgPSBvcHRpb25zLmxhYmVsQnl0ZXMsXG4gICAgICAgICAgICBsYWJlbEJ5dGVzID0gX29wdGlvbnMkbGFiZWxCeXRlcyA9PT0gdm9pZCAwID8gJ2J5dGVzJyA6IF9vcHRpb25zJGxhYmVsQnl0ZXMsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbEtpbG9ieXQgPSBvcHRpb25zLmxhYmVsS2lsb2J5dGVzLFxuICAgICAgICAgICAgbGFiZWxLaWxvYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbEtpbG9ieXQgPT09IHZvaWQgMCA/ICdLQicgOiBfb3B0aW9ucyRsYWJlbEtpbG9ieXQsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbE1lZ2FieXQgPSBvcHRpb25zLmxhYmVsTWVnYWJ5dGVzLFxuICAgICAgICAgICAgbGFiZWxNZWdhYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbE1lZ2FieXQgPT09IHZvaWQgMCA/ICdNQicgOiBfb3B0aW9ucyRsYWJlbE1lZ2FieXQsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbEdpZ2FieXQgPSBvcHRpb25zLmxhYmVsR2lnYWJ5dGVzLFxuICAgICAgICAgICAgbGFiZWxHaWdhYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbEdpZ2FieXQgPT09IHZvaWQgMCA/ICdHQicgOiBfb3B0aW9ucyRsYWJlbEdpZ2FieXQ7XG5cbiAgICAgICAgLy8gbm8gbmVnYXRpdmUgYnl0ZSBzaXplc1xuICAgICAgICBieXRlcyA9IE1hdGgucm91bmQoTWF0aC5hYnMoYnl0ZXMpKTtcblxuICAgICAgICB2YXIgS0IgPSBiYXNlO1xuICAgICAgICB2YXIgTUIgPSBiYXNlICogYmFzZTtcbiAgICAgICAgdmFyIEdCID0gYmFzZSAqIGJhc2UgKiBiYXNlO1xuXG4gICAgICAgIC8vIGp1c3QgYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgS0IpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlcyArICcgJyArIGxhYmVsQnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBraWxvYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgTUIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGJ5dGVzIC8gS0IpICsgJyAnICsgbGFiZWxLaWxvYnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZWdhYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgR0IpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKGJ5dGVzIC8gTUIsIDEsIGRlY2ltYWxTZXBhcmF0b3IpICsgJyAnICsgbGFiZWxNZWdhYnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnaWdhYnl0ZXNcbiAgICAgICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBHQiwgMiwgZGVjaW1hbFNlcGFyYXRvcikgKyAnICcgKyBsYWJlbEdpZ2FieXRlcztcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZURlY2ltYWxzV2hlblplcm8gPSBmdW5jdGlvbiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKHZhbHVlLCBkZWNpbWFsQ291bnQsIHNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIC50b0ZpeGVkKGRlY2ltYWxDb3VudClcbiAgICAgICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydCAhPT0gJzAnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkMiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBmaWxlbmFtZVxuICAgICAgICB2YXIgZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICAgICAgZmlsZU5hbWUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tbWFpbic7XG4gICAgICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgLy8gdGhlIGZpbGUgaXMgY29udGFpbmVkIGluIGEgZmllbGRzZXQgd2l0aCBsZWdlbmQgdGhhdCBjb250YWlucyB0aGUgZmlsZW5hbWVcbiAgICAgICAgLy8gbm8gbmVlZCB0byByZWFkIGl0IHR3aWNlXG4gICAgICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZU5hbWUpO1xuICAgICAgICByb290LnJlZi5maWxlTmFtZSA9IGZpbGVOYW1lO1xuXG4gICAgICAgIC8vIGZpbGVzaXplXG4gICAgICAgIHZhciBmaWxlU2l6ZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgICAgICBmaWxlU2l6ZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1zdWInO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGZpbGVTaXplKTtcbiAgICAgICAgcm9vdC5yZWYuZmlsZVNpemUgPSBmaWxlU2l6ZTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgdGV4dChmaWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfV0FJVElOR19GT1JfU0laRScpKTtcbiAgICAgICAgdGV4dChmaWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsZSA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgdGV4dChcbiAgICAgICAgICAgIHJvb3QucmVmLmZpbGVTaXplLFxuICAgICAgICAgICAgdG9OYXR1cmFsRmlsZVNpemUoXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9CQVNFJyksXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9MQUJFTFMnLCByb290LnF1ZXJ5KVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGVTaXplT25FcnJvciA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGVTaXplT25FcnJvcihfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAvLyBpZiBzaXplIGlzIGF2YWlsYWJsZSBkb24ndCBmYWxsYmFjayB0byB1bmtub3duIHNpemUgbWVzc2FnZVxuICAgICAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZpbGUoeyByb290OiByb290LCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlSW5mbyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1pbmZvJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZUZpbGUsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQTogdXBkYXRlRmlsZSxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgfSksXG5cbiAgICAgICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIHRvUGVyY2VudGFnZSA9IGZ1bmN0aW9uIHRvUGVyY2VudGFnZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkMyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuXG4gICAgICAgIC8vIG1haW4gc3RhdHVzXG4gICAgICAgIHZhciBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIG1haW4uY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLXN0YXR1cy1tYWluJztcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICAgICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAgICAgLy8gc3ViIHN0YXR1c1xuICAgICAgICB2YXIgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIHN1Yi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1Yic7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ViKTtcbiAgICAgICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgICAgIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MoeyByb290OiByb290LCBhY3Rpb246IHsgcHJvZ3Jlc3M6IG51bGwgfSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtTG9hZFByb2dyZXNzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgdmFyIHRpdGxlID1cbiAgICAgICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9MT0FESU5HJykgKyAnICcgKyB0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKSArICclJztcblxuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICAgICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyA9IGZ1bmN0aW9uIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB2YXIgdGl0bGUgPVxuICAgICAgICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSArXG4gICAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgK1xuICAgICAgICAgICAgICAgICAgJyUnO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1JFVFJZJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG4gICAgfTtcblxuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCAnJyk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY4LmFjdGlvbjtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCBhY3Rpb24uc3RhdHVzLm1haW4pO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1YiwgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsZVN0YXR1cyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1zdGF0dXMnLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogZXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogZXJyb3IsXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDMsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gICAgICovXG5cbiAgICB2YXIgQnV0dG9ucyA9IHtcbiAgICAgICAgQWJvcnRJdGVtTG9hZDoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLWxvYWQnLFxuICAgICAgICAgICAgYWxpZ246ICdMT0FEX0lORElDQVRPUl9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbUxvYWQ6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tbG9hZCcsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZW1vdmVJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRU1PVkVfSVRFTScsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVNT1ZFJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmVtb3ZlLWl0ZW0nLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nLCAvLyBsZWZ0XG4gICAgICAgIH0sXG4gICAgICAgIFByb2Nlc3NJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9QUk9DRVNTJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcHJvY2Vzcy1pdGVtJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIEFib3J0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZXZlcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1VORE9fSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fVU5ETycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJywgLy8gcmlnaHRcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gbWFrZSBhIGxpc3Qgb2YgYnV0dG9ucywgd2UgY2FuIHRoZW4gcmVtb3ZlIGJ1dHRvbnMgZnJvbSB0aGlzIGxpc3QgaWYgdGhleSdyZSBkaXNhYmxlZFxuICAgIHZhciBCdXR0b25LZXlzID0gW107XG4gICAgZm9yaW4oQnV0dG9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIEJ1dHRvbktleXMucHVzaChrZXkpO1xuICAgIH0pO1xuXG4gICAgdmFyIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQocm9vdCkge1xuICAgICAgICBpZiAoZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkgPT09ICdyaWdodCcpIHJldHVybiAwO1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC5oaWRkZW4gPyBudWxsIDogYnV0dG9uUmVjdC53aWR0aCArIGJ1dHRvblJlY3QubGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gZnVuY3Rpb24gY2FsY3VsYXRlQnV0dG9uV2lkdGgocm9vdCkge1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC53aWR0aDtcbiAgICB9O1xuXG4gICAgLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuICAgIHZhciBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQocm9vdCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgLyA0KTtcbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQubGVmdCAvIDIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyk7XG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuICAgIH07XG4gICAgdmFyIGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50ID0gZnVuY3Rpb24gZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicpO1xuICAgIH07XG5cbiAgICB2YXIgRGVmYXVsdFN0eWxlID0ge1xuICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgfSxcbiAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgICAgIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvcjogeyBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuNzUsIHNjYWxlWTogMC43NSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICB9O1xuXG4gICAgdmFyIElkbGVTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICB9O1xuXG4gICAgdmFyIFByb2Nlc3NpbmdTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfTtcblxuICAgIHZhciBTdHlsZU1hcCA9IHtcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDoge1xuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEsIGFsaWduOiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudCB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IHtcbiAgICAgICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEsIHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX0xPQURfSVRFTTogSWRsZVN0eWxlLFxuICAgICAgICBESURfTE9BRF9MT0NBTF9JVEVNOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlLFxuICAgIH07XG5cbiAgICAvLyBjb21wbGV0ZSBpbmRpY2F0b3Igdmlld1xuICAgIHZhciBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IHJvb3QucXVlcnkoJ0dFVF9JQ09OX0RPTkUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogJ3Byb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNCA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgICAgICAvLyBjb3B5IEJ1dHRvbnMgb2JqZWN0XG4gICAgICAgIHZhciBMb2NhbEJ1dHRvbnMgPSBPYmplY3Qua2V5cyhCdXR0b25zKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICAgICAgcHJldltjdXJyXSA9IE9iamVjdC5hc3NpZ24oe30sIEJ1dHRvbnNbY3Vycl0pO1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgICAgICB2YXIgYWxsb3dSZXZlcnQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVWRVJUJyk7XG5cbiAgICAgICAgLy8gYWxsb3cgcmVtb3ZlIGZpbGVcbiAgICAgICAgdmFyIGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgICAgIHZhciBhbGxvd1Byb2Nlc3MgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUFJPQ0VTUycpO1xuXG4gICAgICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgICAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHJvb3QucXVlcnkoJ0dFVF9JTlNUQU5UX1VQTE9BRCcpO1xuXG4gICAgICAgIC8vIGlzIGFzeW5jIHNldCB1cFxuICAgICAgICB2YXIgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICAgICAgdmFyIGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiA9IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nKTtcblxuICAgICAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICAgICAgdmFyIGJ1dHRvbkZpbHRlcjtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcmV2ZXJ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEvUmV2ZXJ0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm9jZXNzIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gcHJvY2VzcyBjb250cm9scyBhdmFpbGFibGVcbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyID8gQnV0dG9uS2V5cy5maWx0ZXIoYnV0dG9uRmlsdGVyKSA6IEJ1dHRvbktleXMuY29uY2F0KCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGljb24gYW5kIGxhYmVsIGZvciByZXZlcnQgYnV0dG9uIHdoZW4gaW5zdGFudCB1cGxvYWRpbmdcbiAgICAgICAgaWYgKGluc3RhbnRVcGxvYWQgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5sYWJlbCA9ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJztcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgICAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsXG4gICAgICAgICAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFN0eWxlTWFwWydESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJ10uc3RhdHVzLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVCdXR0b25XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdmUgcmVtb3ZlIGJ1dHRvbiB0byByaWdodFxuICAgICAgICBpZiAoYWxpZ25SZW1vdmVJdGVtQnV0dG9uICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10uYWxpZ24gPSAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJztcbiAgICAgICAgICAgIHZhciBfbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIF9tYXAuaW5mby50cmFuc2xhdGVYID0gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQ7XG4gICAgICAgICAgICBfbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgX21hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG93L2hpZGUgUmVtb3ZlSXRlbSBidXR0b25cbiAgICAgICAgaWYgKCFhbGxvd1JlbW92ZSkge1xuICAgICAgICAgICAgTG9jYWxCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICAgICAgZm9yaW4oTG9jYWxCdXR0b25zLCBmdW5jdGlvbihrZXksIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgICAgICAgIHZhciBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgIGxhYmVsOiByb290LnF1ZXJ5KGRlZmluaXRpb24ubGFiZWwpLFxuICAgICAgICAgICAgICAgIGljb246IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5pY29uKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhcHBlbmRlZD9cbiAgICAgICAgICAgIGlmIChlbmFibGVkQnV0dG9ucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvZ2dsZVxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHBvc2l0aW9uIGF0dHJpYnV0ZVxuICAgICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfJyArIGRlZmluaXRpb24uYWxpZ24pO1xuXG4gICAgICAgICAgICAvLyBhZGQgY2xhc3NcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGRlZmluaXRpb24uY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goZGVmaW5pdGlvbi5hY3Rpb24sIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgICAgICAgIHJvb3QucmVmWydidXR0b24nICsga2V5XSA9IGJ1dHRvblZpZXc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrbWFya1xuICAgICAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcpXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yLmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgICAgICAnR0VUX1NUWUxFX0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgICAgIHJvb3QucmVmLmluZm8gPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlSW5mbywgeyBpZDogaWQgfSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgICAgIHJvb3QucmVmLnN0YXR1cyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVTdGF0dXMsIHsgaWQ6IGlkIH0pKTtcblxuICAgICAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgICB2YXIgbG9hZEluZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGxvYWRJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWxvYWQtaW5kaWNhdG9yJyk7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvciA9IGxvYWRJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIHZhciBwcm9ncmVzc0luZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yID0gcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHN0eWxlc1xuICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDIgPSBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjMuYWN0aW9ucyxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG5cbiAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHlsZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGRlZmluZSBuZXcgYWN0aXZlIHN0eWxlc1xuICAgICAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgICAgICAgIHZhciBzdHlsZXNUb0FwcGx5ID0gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCBmdW5jdGlvbihuYW1lLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSByb290LnJlZltuYW1lXTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgICAgICAgICBmb3JpbihkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJiB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5wdXNoKHsgY29udHJvbDogY29udHJvbCwga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYWN0aXZlIHN0eWxlcyB0byBlbGVtZW50XG4gICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IF9yZWY0LmNvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5ID0gX3JlZjQua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgICAgICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyhcbiAgICAgICAgICAgIF9yZWY1XG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVByb2Nlc3NpbmcubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUwoXG4gICAgICAgICAgICBfcmVmN1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1SZW1vdmFsLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORyhfcmVmOCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NUQVJUX0lURU1fTE9BRChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiBmdW5jdGlvbiBESURfU1RBUlRfSVRFTV9SRU1PVkUoX3JlZjEwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTKF9yZWYxMSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTEucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTEuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTKF9yZWYxMikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTIucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTIuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBmaWxlID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgICAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnZmlsZScsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJDUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBmaWxlbmFtZVxuICAgICAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgICAgIC8vIGZpbGUgYXBwZW5kZWRcbiAgICAgICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGUsIHsgaWQ6IHByb3BzLmlkIH0pKTtcblxuICAgICAgICAvLyBkYXRhIGhhcyBtb3ZlZCB0byBkYXRhLmpzXG4gICAgICAgIHJvb3QucmVmLmRhdGEgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBzdG9yYWdlXG4gICAgICovXG4gICAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlV3JhcHBlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICAgICAgbmFtZTogJ2ZpbGUtd3JhcHBlcicsXG4gICAgfSk7XG5cbiAgICB2YXIgUEFORUxfU1BSSU5HX1BST1BTID0geyB0eXBlOiAnc3ByaW5nJywgZGFtcGluZzogMC42LCBtYXNzOiA3IH07XG5cbiAgICB2YXIgY3JlYXRlJDYgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogUEFORUxfU1BSSU5HX1BST1BTLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgY3JlYXRlU2VjdGlvbihyb290LCBzZWN0aW9uLCBwcm9wcy5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS0nICsgcHJvcHMubmFtZSk7XG5cbiAgICAgICAgcm9vdC5yZWYuc2NhbGFibGUgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciB2aWV3Q29uc3RydWN0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgICAgIG5hbWU6ICdwYW5lbC0nICsgc2VjdGlvbi5uYW1lICsgJyBmaWxlcG9uZC0tJyArIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHZpZXdDb25zdHJ1Y3Rvciwgc2VjdGlvbi5wcm9wcyk7XG5cbiAgICAgICAgcm9vdC5yZWZbc2VjdGlvbi5uYW1lXSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHZpZXcpO1xuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkMyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICAgICAgLy8gdXBkYXRlIHNjYWxhYmxlIHN0YXRlXG4gICAgICAgIGlmIChyb290LnJlZi5zY2FsYWJsZSA9PT0gbnVsbCB8fCBwcm9wcy5zY2FsYWJsZSAhPT0gcm9vdC5yZWYuc2NhbGFibGUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoZWlnaHQsIGNhbid0IHNldFxuICAgICAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBjaGlsZCByZWN0c1xuICAgICAgICB2YXIgdG9wUmVjdCA9IHJvb3QucmVmLnRvcC5yZWN0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgodG9wUmVjdC5oZWlnaHQgKyBib3R0b21SZWN0LmhlaWdodCwgcHJvcHMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnRyYW5zbGF0ZVkgPSB0b3BSZWN0LmhlaWdodDtcblxuICAgICAgICAvLyBzY2FsZSBjZW50ZXIgcGFydFxuICAgICAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnNjYWxlWSA9IChoZWlnaHQgLSB0b3BSZWN0LmhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0KSAvIDEwMDtcblxuICAgICAgICAvLyBvZmZzZXQgYm90dG9tIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkgPSBoZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdwYW5lbCcsXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAgICAgcmV0dXJuIChwcm9wcy5oZWlnaHRDdXJyZW50ID0gcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogd3JpdGUkMyxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkNixcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ2hlaWdodCcsICdoZWlnaHRDdXJyZW50JywgJ3NjYWxhYmxlJ10sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlRHJhZ0hlbHBlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdIZWxwZXIoaXRlbXMpIHtcbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SW5kZXg6IGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbUluZGV4OiBmdW5jdGlvbiBnZXRJdGVtSW5kZXgoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtSWRzLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSVRFTV9UUkFOU0xBVEVfU1BSSU5HID0ge1xuICAgICAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICAgICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgICAgICBkYW1waW5nOiAwLjQ1LFxuICAgICAgICBtYXNzOiAxMCxcbiAgICB9O1xuXG4gICAgdmFyIElURU1fU0NBTEVfU1BSSU5HID0gJ3NwcmluZyc7XG5cbiAgICB2YXIgU3RhdGVNYXAgPSB7XG4gICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICdidXN5JyxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogJ2xvYWQtaW52YWxpZCcsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6ICdsb2FkLWVycm9yJyxcbiAgICAgICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6ICdyZW1vdmUtZXJyb3InLFxuICAgICAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICdidXN5JyxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiAncHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogJ3Byb2Nlc3NpbmctZXJyb3InLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogJ3Byb2Nlc3NpbmctcmV2ZXJ0LWVycm9yJyxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiAnaWRsZScsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBzZWxlY3RcbiAgICAgICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdC5kaXNwYXRjaCgnRElEX0FDVElWQVRFX0lURU0nLCB7IGlkOiBwcm9wcy5pZCB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgaWRcbiAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1pdGVtLScgKyBwcm9wcy5pZDtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuXG4gICAgICAgIC8vIGZpbGUgdmlld1xuICAgICAgICByb290LnJlZi5jb250YWluZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVXcmFwcGVyLCB7IGlkOiBwcm9wcy5pZCB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGZpbGUgcGFuZWxcbiAgICAgICAgcm9vdC5yZWYucGFuZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAnaXRlbS1wYW5lbCcgfSkpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgc3RhcnQgaGVpZ2h0XG4gICAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IG51bGw7XG5cbiAgICAgICAgLy8gYnkgZGVmYXVsdCBub3QgbWFya2VkIGZvciByZW1vdmFsXG4gICAgICAgIHByb3BzLm1hcmtlZEZvclJlbW92YWwgPSBmYWxzZTtcblxuICAgICAgICAvLyBpZiBub3QgYWxsb3dlZCB0byByZW9yZGVyIGZpbGUgaXRlbXMsIGV4aXQgaGVyZVxuICAgICAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU9SREVSJykpIHJldHVybjtcblxuICAgICAgICAvLyBzZXQgdG8gaWRsZSBzbyBzaG93cyBncmFiIGN1cnNvclxuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnaWRsZSc7XG5cbiAgICAgICAgdmFyIGdyYWIgPSBmdW5jdGlvbiBncmFiKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgeDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICAgICAgeTogcm9vdC50cmFuc2xhdGVZLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvcHMuZHJhZ0NlbnRlciA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgeTogZS5vZmZzZXRZLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRyYWdTdGF0ZSA9IGNyZWF0ZURyYWdIZWxwZXIocm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpKTtcblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0dSQUJfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGU6IGRyYWdTdGF0ZSB9KTtcblxuICAgICAgICAgICAgdmFyIGRyYWcgPSBmdW5jdGlvbiBkcmFnKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGUucGFnZVggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBkcmFnZ2VkIHN0b3AgbGlzdGVuaW5nIHRvIGNsaWNrcywgd2lsbCByZS1hZGQgd2hlbiBkb25lIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnggKiBwcm9wcy5kcmFnT2Zmc2V0LnggK1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnkgKiBwcm9wcy5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAxNiAmJiAhcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RSQUdfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGU6IGRyYWdTdGF0ZSB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgY2FuY2VsKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuXG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1BfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGU6IGRyYWdTdGF0ZSB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGxpc3RlbmluZyB0byBjbGlja3MgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCBjYW5jZWwpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGdyYWIpO1xuICAgIH07XG5cbiAgICB2YXIgcm91dGUkMSA9IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1VQREFURV9QQU5FTF9IRUlHSFQ6IGZ1bmN0aW9uIERJRF9VUERBVEVfUEFORUxfSEVJR0hUKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBhY3Rpb24uaGVpZ2h0O1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIHdyaXRlJDQgPSBjcmVhdGVSb3V0ZShcbiAgICAgICAge1xuICAgICAgICAgICAgRElEX0dSQUJfSVRFTTogZnVuY3Rpb24gRElEX0dSQUJfSVRFTShfcmVmMykge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERJRF9EUkFHX0lURU06IGZ1bmN0aW9uIERJRF9EUkFHX0lURU0oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3Q7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2RyYWcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERJRF9EUk9QX0lURU06IGZ1bmN0aW9uIERJRF9EUk9QX0lURU0oX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHM7XG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2Ryb3AnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNi5hY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjYucHJvcHMsXG4gICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNi5zaG91bGRPcHRpbWl6ZTtcbiAgICAgICAgICAgIGlmIChyb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPT09ICdkcm9wJykge1xuICAgICAgICAgICAgICAgIGlmIChyb290LnNjYWxlWCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9eRElEXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdGF0ZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IHNhbWUgc3RhdGUgdHdpY2VcbiAgICAgICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgIT09IHByb3BzLmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAgICAgcHJvcHMuY3VycmVudFN0YXRlID0gYWN0aW9uLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgc3RhdGVcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5maWxlcG9uZEl0ZW1TdGF0ZSA9IFN0YXRlTWFwW3Byb3BzLmN1cnJlbnRTdGF0ZV0gfHwgJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9XG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPJykgfHwgcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICAgICAgaWYgKCFhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHJvdXRlJDEoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyb290LmhlaWdodCAmJiByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3luYyBwYW5lbCBoZWlnaHQgd2l0aCBpdGVtIGhlaWdodFxuICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIGl0ZW0gPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkNyxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDQsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjcpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY3LnByb3BzO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnUkVMRUFTRV9JVEVNJywgeyBxdWVyeTogcHJvcHMuaWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgbmFtZTogJ2l0ZW0nLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFtcbiAgICAgICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgICAgICdpbnRlcmFjdGlvbk1ldGhvZCcsXG4gICAgICAgICAgICAgICAgJ21hcmtlZEZvclJlbW92YWwnLFxuICAgICAgICAgICAgICAgICdzcGF3bkRhdGUnLFxuICAgICAgICAgICAgICAgICdkcmFnQ2VudGVyJyxcbiAgICAgICAgICAgICAgICAnZHJhZ09yaWdpbicsXG4gICAgICAgICAgICAgICAgJ2RyYWdPZmZzZXQnLFxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknLCAnaGVpZ2h0J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiBJVEVNX1NDQUxFX1NQUklORyxcbiAgICAgICAgICAgICAgICBzY2FsZVk6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IElURU1fVFJBTlNMQVRFX1NQUklORyxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEl0ZW1zUGVyUm93ID0gZnVuY3Rpb24oaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpIHtcbiAgICAgICAgLy8gYWRkIG9uZSBwaXhlbCBsZWV3YXksIHdoZW4gdXNpbmcgcGVyY2VudGFnZXMgZm9yIGl0ZW0gd2lkdGggdG90YWwgaXRlbXMgY2FuIGJlIDEuOTkgcGVyIHJvd1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKChob3Jpem9udGFsU3BhY2UgKyAxKSAvIGl0ZW1XaWR0aCkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUluZGV4QnlQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24odmlldywgY2hpbGRyZW4sIHBvc2l0aW9uSW5WaWV3KSB7XG4gICAgICAgIGlmICghcG9zaXRpb25JblZpZXcpIHJldHVybjtcblxuICAgICAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gdmlldy5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgIC8vIGNvbnN0IGNoaWxkcmVuID0gdmlldy5jaGlsZFZpZXdzO1xuICAgICAgICB2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3QgPSBudWxsO1xuXG4gICAgICAgIC8vIC0xLCBkb24ndCBtb3ZlIGl0ZW1zIHRvIGFjY29tb2RhdGUgKGVpdGhlciBhZGQgdG8gdG9wIG9yIGJvdHRvbSlcbiAgICAgICAgaWYgKGwgPT09IDAgfHwgcG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50LnRvcCkgcmV0dXJuIC0xO1xuXG4gICAgICAgIC8vIGxldCdzIGdldCB0aGUgaXRlbSB3aWR0aFxuICAgICAgICB2YXIgaXRlbSA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB2YXIgaXRlbVJlY3QgPSBpdGVtLnJlY3QuZWxlbWVudDtcbiAgICAgICAgdmFyIGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gaXRlbVJlY3QubWFyZ2luTGVmdCArIGl0ZW1SZWN0Lm1hcmdpblJpZ2h0O1xuICAgICAgICB2YXIgaXRlbVdpZHRoID0gaXRlbVJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgICAgdmFyIGl0ZW1zUGVyUm93ID0gZ2V0SXRlbXNQZXJSb3coaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpO1xuXG4gICAgICAgIC8vIHN0YWNrXG4gICAgICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGw7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTWlkID0gY2hpbGQucmVjdC5vdXRlci50b3AgKyBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkluVmlldy50b3AgPCBjaGlsZE1pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBncmlkXG4gICAgICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5Ub3AgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gaXRlbVJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICBmb3IgKHZhciBfaW5kZXggPSAwOyBfaW5kZXggPCBsOyBfaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4WCA9IF9pbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICAgICAgdmFyIGluZGV4WSA9IE1hdGguZmxvb3IoX2luZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gaW5kZXhZICogaXRlbUhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGl0ZW1Ub3AgPSBvZmZzZXRZIC0gaXRlbVJlY3QubWFyZ2luVG9wO1xuICAgICAgICAgICAgdmFyIGl0ZW1SaWdodCA9IG9mZnNldFggKyBpdGVtV2lkdGg7XG4gICAgICAgICAgICB2YXIgaXRlbUJvdHRvbSA9IG9mZnNldFkgKyBpdGVtSGVpZ2h0ICsgaXRlbVJlY3QubWFyZ2luQm90dG9tO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgaXRlbUJvdHRvbSAmJiBwb3NpdGlvbkluVmlldy50b3AgPiBpdGVtVG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LmxlZnQgPCBpdGVtUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCAhPT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IF9pbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbDtcbiAgICB9O1xuXG4gICAgdmFyIGRyb3BBcmVhRGltZW5zaW9ucyA9IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgZ2V0IGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHNldEhlaWdodCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMuaGVpZ2h0ID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHNldFdpZHRoKHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IDAgfHwgdmFsID09PSAwKSB0aGlzLndpZHRoID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IDAgfHwgd2lkdGggPT09IDApIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSQ4ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICAgIC8vIG5lZWQgdG8gc2V0IHJvbGUgdG8gbGlzdCBhcyBvdGhlcndpc2UgaXQgd29uJ3QgYmUgcmVhZCBhcyBhIGxpc3QgYnkgVm9pY2VPdmVyXG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAncm9sZScsICdsaXN0Jyk7XG5cbiAgICAgICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBEYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbmV3IGl0ZW1cbiAgICAgKiBAcGFyYW0gcm9vdFxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgYWRkSXRlbVZpZXcgPSBmdW5jdGlvbiBhZGRJdGVtVmlldyhfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgICAgICAgIGluZGV4ID0gYWN0aW9uLmluZGV4LFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBhY3Rpb24uaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICAgICAgcm9vdC5yZWYuYWRkSW5kZXggPSBpbmRleDtcblxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHNwYXduRGF0ZSA9IG5vdztcbiAgICAgICAgdmFyIG9wYWNpdHkgPSAxO1xuXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbk1ldGhvZCAhPT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgICAgICB2YXIgY29vbGRvd24gPSByb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfSU5URVJWQUwnKTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gbm93IC0gcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGU7XG4gICAgICAgICAgICBzcGF3bkRhdGUgPSBkaXN0IDwgY29vbGRvd24gPyBub3cgKyAoY29vbGRvd24gLSBkaXN0KSA6IG5vdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gc3Bhd25EYXRlO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgICAgICAgLy8gdmlldyB0eXBlXG4gICAgICAgICAgICAgICAgaXRlbSxcblxuICAgICAgICAgICAgICAgIC8vIHByb3BzXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzcGF3bkRhdGU6IHNwYXduRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIG1vdmVJdGVtID0gZnVuY3Rpb24gbW92ZUl0ZW0oaXRlbSwgeCwgeSkge1xuICAgICAgICB2YXIgdnggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICAgIHZhciB2eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMTtcbiAgICAgICAgLy8gc2V0IHRvIG51bGwgdG8gcmVtb3ZlIGFuaW1hdGlvbiB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICBpZiAoaXRlbS5kcmFnT2Zmc2V0KSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IGl0ZW0uZHJhZ09yaWdpbi54ICsgaXRlbS5kcmFnT2Zmc2V0Lng7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBpdGVtLmRyYWdPcmlnaW4ueSArIGl0ZW0uZHJhZ09mZnNldC55O1xuICAgICAgICAgICAgaXRlbS5zY2FsZVggPSAxLjAyNTtcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVZID0gMS4wMjU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geTtcblxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiBpdGVtLnNwYXduRGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHJldmVhbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGlzIGRlZmF1bHQgc2NhbGUgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDE7XG4gICAgICAgICAgICAgICAgaXRlbS5zY2FsZVkgPSAxO1xuICAgICAgICAgICAgICAgIGl0ZW0ub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGludHJvSXRlbVZpZXcgPSBmdW5jdGlvbiBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSkge1xuICAgICAgICBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QKSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geCAtIHZ4ICogMjA7XG5cbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gdnkgKiAxMDtcblxuICAgICAgICAgICAgaXRlbS5zY2FsZVggPSAwLjg7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDAuODtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gMzA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQVBJKSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geCAtIDMwO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIGl0ZW1cbiAgICAgKiBAcGFyYW0gcm9vdFxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgcmVtb3ZlSXRlbVZpZXcgPSBmdW5jdGlvbiByZW1vdmVJdGVtVmlldyhfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgIHZhciBpZCA9IGFjdGlvbi5pZDtcblxuICAgICAgICAvLyBnZXQgdGhlIHZpZXcgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkXG4gICAgICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbmltYXRlIHZpZXcgb3V0IG9mIHZpZXdcbiAgICAgICAgdmlldy5zY2FsZVggPSAwLjk7XG4gICAgICAgIHZpZXcuc2NhbGVZID0gMC45O1xuICAgICAgICB2aWV3Lm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIC8vIG1hcmsgZm9yIHJlbW92YWxcbiAgICAgICAgdmlldy5tYXJrZWRGb3JSZW1vdmFsID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1IZWlnaHQgPSBmdW5jdGlvbiBnZXRJdGVtSGVpZ2h0KGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICtcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20gKiAwLjUgK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblRvcCAqIDAuNVxuICAgICAgICApO1xuICAgIH07XG4gICAgdmFyIGdldEl0ZW1XaWR0aCA9IGZ1bmN0aW9uIGdldEl0ZW1XaWR0aChjaGlsZCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50LndpZHRoICtcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5MZWZ0ICogMC41ICtcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5SaWdodCAqIDAuNVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ0l0ZW0gPSBmdW5jdGlvbiBkcmFnSXRlbShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgICAgICAgIGRyYWdTdGF0ZSA9IGFjdGlvbi5kcmFnU3RhdGU7XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIGl0ZW1cbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICAgICAgdmFyIHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG51bUl0ZW1zID0gcm9vdC5jaGlsZFZpZXdzLmxlbmd0aDtcbiAgICAgICAgdmFyIG9sZEluZGV4ID0gZHJhZ1N0YXRlLmdldEl0ZW1JbmRleChpdGVtKTtcblxuICAgICAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuO1xuXG4gICAgICAgIHZhciBkcmFnUG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiB2aWV3LmRyYWdPcmlnaW4ueCArIHZpZXcuZHJhZ09mZnNldC54ICsgdmlldy5kcmFnQ2VudGVyLngsXG4gICAgICAgICAgICB5OiB2aWV3LmRyYWdPcmlnaW4ueSArIHZpZXcuZHJhZ09mZnNldC55ICsgdmlldy5kcmFnQ2VudGVyLnksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IGRyYWcgYXJlYSBkaW1lbnNpb25zXG4gICAgICAgIHZhciBkcmFnSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodCh2aWV3KTtcbiAgICAgICAgdmFyIGRyYWdXaWR0aCA9IGdldEl0ZW1XaWR0aCh2aWV3KTtcblxuICAgICAgICAvLyBnZXQgcm93cyBhbmQgY29sdW1ucyAoVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIHJvdyBhbmQgb25lIGNvbHVtbiBpZiBhIGZpbGUgaXMgcHJlc2VudClcbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLmZsb29yKHJvb3QucmVjdC5vdXRlci53aWR0aCAvIGRyYWdXaWR0aCk7XG4gICAgICAgIGlmIChjb2xzID4gbnVtSXRlbXMpIGNvbHMgPSBudW1JdGVtcztcblxuICAgICAgICAvLyByb3dzIGFyZSB1c2VkIHRvIGZpbmQgd2hlbiB3ZSBoYXZlIGxlZnQgdGhlIHByZXZpZXcgYXJlYSBib3VuZGluZyBib3hcbiAgICAgICAgdmFyIHJvd3MgPSBNYXRoLmZsb29yKG51bUl0ZW1zIC8gY29scyArIDEpO1xuXG4gICAgICAgIGRyb3BBcmVhRGltZW5zaW9ucy5zZXRIZWlnaHQgPSBkcmFnSGVpZ2h0ICogcm93cztcbiAgICAgICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldFdpZHRoID0gZHJhZ1dpZHRoICogY29scztcblxuICAgICAgICAvLyBnZXQgbmV3IGluZGV4IG9mIGRyYWdnZWQgaXRlbVxuICAgICAgICB2YXIgbG9jYXRpb24gPSB7XG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGRyYWdQb3NpdGlvbi55IC8gZHJhZ0hlaWdodCksXG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKGRyYWdQb3NpdGlvbi54IC8gZHJhZ1dpZHRoKSxcbiAgICAgICAgICAgIGdldEdyaWRJbmRleDogZnVuY3Rpb24gZ2V0R3JpZEluZGV4KCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi55IDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueCA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueCA8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55ICogY29scyArIHRoaXMueDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb2xJbmRleDogZnVuY3Rpb24gZ2V0Q29sSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZpZXcuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGNoaWxkcmVuLmZpbmRJbmRleChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHZpZXc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgICAgICAgICAgICAgIHZhciBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBsO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQm90dG9tID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUb3AgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVG9wID0gY2hpbGRCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQm90dG9tID0gY2hpbGRUb3AgKyBjaGlsZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdQb3NpdGlvbi55IDwgY2hpbGRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdQb3NpdGlvbi55IDwgY2hpbGRUb3AgKyBkcmFnSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgbmV3IGluZGV4XG4gICAgICAgIHZhciBpbmRleCA9IGNvbHMgPiAxID8gbG9jYXRpb24uZ2V0R3JpZEluZGV4KCkgOiBsb2NhdGlvbi5nZXRDb2xJbmRleCgpO1xuICAgICAgICByb290LmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiB2aWV3LCBpbmRleDogaW5kZXggfSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGNoYW5nZWQsIGRpc3BhdGNoIHJlb3JkZXIgYWN0aW9uXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBkcmFnU3RhdGUuZ2V0SW5kZXgoKTtcblxuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQgfHwgY3VycmVudEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgZHJhZ1N0YXRlLnNldEluZGV4KGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRU9SREVSX0lURU1TJywge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBvbGRJbmRleCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGluZGV4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0dXAgYWN0aW9uIHJvdXRlc1xuICAgICAqL1xuICAgIHZhciByb3V0ZSQyID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfQUREX0lURU06IGFkZEl0ZW1WaWV3LFxuICAgICAgICBESURfUkVNT1ZFX0lURU06IHJlbW92ZUl0ZW1WaWV3LFxuICAgICAgICBESURfRFJBR19JVEVNOiBkcmFnSXRlbSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHZpZXdcbiAgICAgKiBAcGFyYW0gcm9vdFxuICAgICAqIEBwYXJhbSBhY3Rpb25zXG4gICAgICogQHBhcmFtIHByb3BzXG4gICAgICovXG4gICAgdmFyIHdyaXRlJDUgPSBmdW5jdGlvbiB3cml0ZShfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzLFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9yZWY1LmFjdGlvbnMsXG4gICAgICAgICAgICBzaG91bGRPcHRpbWl6ZSA9IF9yZWY1LnNob3VsZE9wdGltaXplO1xuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIHJvdXRlJDIoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG4gICAgICAgIHZhciBkcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAgICAgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIGhvcml6b250YWwgYXhpc1xuICAgICAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG5cbiAgICAgICAgLy8gb25seSBkcmF3IGNoaWxkcmVuIHRoYXQgaGF2ZSBkaW1lbnNpb25zXG4gICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc29ydCBiYXNlZCBvbiBjdXJyZW50IGFjdGl2ZSBpdGVtc1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGdldCBpbmRleFxuICAgICAgICB2YXIgZHJhZ0luZGV4ID0gZHJhZ0Nvb3JkaW5hdGVzXG4gICAgICAgICAgICA/IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24ocm9vdCwgY2hpbGRyZW4sIGRyYWdDb29yZGluYXRlcylcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAvLyBhZGQgaW5kZXggaXMgdXNlZCB0byByZXNlcnZlIHRoZSBkcm9wcGVkL2FkZGVkIGl0ZW0gaW5kZXggdGlsbCB0aGUgYWN0dWFsIGl0ZW0gaXMgcmVuZGVyZWRcbiAgICAgICAgdmFyIGFkZEluZGV4ID0gcm9vdC5yZWYuYWRkSW5kZXggfHwgbnVsbDtcblxuICAgICAgICAvLyBhZGQgaW5kZXggbm8gbG9uZ2VyIG5lZWRlZCB0aWxsIHBvc3NpYmx5IG5leHQgZHJhd1xuICAgICAgICByb290LnJlZi5hZGRJbmRleCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGRyYWdJbmRleE9mZnNldCA9IDA7XG4gICAgICAgIHZhciByZW1vdmVJbmRleE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBhZGRJbmRleE9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpbkxlZnQgKyBjaGlsZFJlY3QubWFyZ2luUmlnaHQ7XG4gICAgICAgIHZhciBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZFJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAgICAgLy8gc3RhY2tcbiAgICAgICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB2YXIgZHJhZ09mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGluZGV4IC0gZHJhZ0luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAtaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY2hpbGQubWFya2VkRm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgMCwgb2Zmc2V0WSArIGRyYWdPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgICAgICAgICAgICAgIHZhciB2aXN1YWxIZWlnaHQgPSBpdGVtSGVpZ2h0ICogKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgPyBjaGlsZC5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgICAgICAgICBvZmZzZXRZICs9IHZpc3VhbEhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyaWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlggPSAwO1xuICAgICAgICAgICAgdmFyIHByZXZZID0gMDtcblxuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGRyYWdJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnSW5kZXhPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gYWRkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5kZXhPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUluZGV4T2Zmc2V0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZpc3VhbEluZGV4ID0gaW5kZXggKyBhZGRJbmRleE9mZnNldCArIGRyYWdJbmRleE9mZnNldCArIHJlbW92ZUluZGV4T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4WCA9IHZpc3VhbEluZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4WSA9IE1hdGguZmxvb3IodmlzdWFsSW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IGluZGV4WSAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yWCA9IE1hdGguc2lnbihvZmZzZXRYIC0gcHJldlgpO1xuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3JZID0gTWF0aC5zaWduKG9mZnNldFkgLSBwcmV2WSk7XG5cbiAgICAgICAgICAgICAgICBwcmV2WCA9IG9mZnNldFg7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBvZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW92ZUl0ZW0oY2hpbGQsIG9mZnNldFgsIG9mZnNldFksIHZlY3RvclgsIHZlY3RvclkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyBhY3Rpb25zIHRoYXQgYXJlIG1lYW50IHNwZWNpZmljYWxseSBmb3IgYSBjZXJ0YWluIGNoaWxkIG9mIHRoZSBsaXN0XG4gICAgICogQHBhcmFtIGNoaWxkXG4gICAgICogQHBhcmFtIGFjdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgZmlsdGVyU2V0SXRlbUFjdGlvbnMgPSBmdW5jdGlvbiBmaWx0ZXJTZXRJdGVtQWN0aW9ucyhjaGlsZCwgYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiBhY3Rpb24gaGFzIGFuIGlkLCBmaWx0ZXIgb3V0IGFjdGlvbnMgdGhhdCBkb24ndCBoYXZlIHRoaXMgY2hpbGQgaWRcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZGF0YSAmJiBhY3Rpb24uZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gYWN0aW9uLmRhdGEuaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbG93IGFsbCBvdGhlciBhY3Rpb25zXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDgsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ1LFxuICAgICAgICB0YWc6ICd1bCcsXG4gICAgICAgIG5hbWU6ICdsaXN0JyxcbiAgICAgICAgZGlkV3JpdGVWaWV3OiBmdW5jdGlvbiBkaWRXcml0ZVZpZXcoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgICAgIHJvb3QuY2hpbGRWaWV3c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5tYXJrZWRGb3JSZW1vdmFsICYmIHZpZXcub3BhY2l0eSA9PT0gMCAmJiB2aWV3LnJlc3Rpbmc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkOiBmaWx0ZXJTZXRJdGVtQWN0aW9ucyxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ2RyYWdDb29yZGluYXRlcyddLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZSQ5ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHJvb3QucmVmLmxpc3QgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhsaXN0KSk7XG4gICAgICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgICAgIHByb3BzLm92ZXJmbG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBzdG9yZURyYWdDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHN0b3JlRHJhZ0Nvb3JkaW5hdGVzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OX0ZSRUVET00nKSkgcmV0dXJuO1xuICAgICAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICBsZWZ0OiBhY3Rpb24ucG9zaXRpb24uc2NvcGVMZWZ0IC0gcm9vdC5yZWYubGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgICAgIHRvcDpcbiAgICAgICAgICAgICAgICBhY3Rpb24ucG9zaXRpb24uc2NvcGVUb3AgLVxuICAgICAgICAgICAgICAgIChyb290LnJlY3Qub3V0ZXIudG9wICsgcm9vdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICsgcm9vdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNsZWFyRHJhZ0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gY2xlYXJEcmFnQ29vcmRpbmF0ZXMoX3JlZjMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQzID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfRFJBRzogc3RvcmVEcmFnQ29vcmRpbmF0ZXMsXG4gICAgICAgIERJRF9FTkRfRFJBRzogY2xlYXJEcmFnQ29vcmRpbmF0ZXMsXG4gICAgfSk7XG5cbiAgICB2YXIgd3JpdGUkNiA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjQucHJvcHMsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjQuYWN0aW9ucztcblxuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIHJvdXRlJDMoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAgICAgLy8gY3VycmVudCBkcmFnIHBvc2l0aW9uXG4gICAgICAgIHJvb3QucmVmLmxpc3QuZHJhZ0Nvb3JkaW5hdGVzID0gcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzO1xuXG4gICAgICAgIC8vIGlmIGN1cnJlbnRseSBvdmVyZmxvd2luZyBidXQgbm8gbG9uZ2VyIHJlY2VpdmVkIG92ZXJmbG93XG4gICAgICAgIGlmIChwcm9wcy5vdmVyZmxvd2luZyAmJiAhcHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHByb3BzLm92ZXJmbG93aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IG92ZXJmbG93IHN0YXRlXG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICcnO1xuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgbm90IG92ZXJmbG93aW5nIGN1cnJlbnRseSBidXQgZG9lcyByZWNlaXZlIG92ZXJmbG93IHZhbHVlXG4gICAgICAgIGlmIChwcm9wcy5vdmVyZmxvdykge1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGgucm91bmQocHJvcHMub3ZlcmZsb3cpO1xuICAgICAgICAgICAgaWYgKG5ld0hlaWdodCAhPT0gcm9vdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuc3RhdGUgPSAnb3ZlcmZsb3cnO1xuICAgICAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsaXN0U2Nyb2xsZXIgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkOSxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDYsXG4gICAgICAgIG5hbWU6ICdsaXN0LXNjcm9sbGVyJyxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ292ZXJmbG93JywgJ2RyYWdDb29yZGluYXRlcyddLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGF0dHJUb2dnbGUgPSBmdW5jdGlvbiBhdHRyVG9nZ2xlKGVsZW1lbnQsIG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIHZhciBlbmFibGVkVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcnO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGF0dHIoZWxlbWVudCwgbmFtZSwgZW5hYmxlZFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNldEZpbGVJbnB1dCA9IGZ1bmN0aW9uIHJlc2V0RmlsZUlucHV0KGlucHV0KSB7XG4gICAgICAgIC8vIG5vIHZhbHVlLCBubyBuZWVkIHRvIHJlc2V0XG4gICAgICAgIGlmICghaW5wdXQgfHwgaW5wdXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZm9yIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICAgIC8vIGZvciBJRTEwXG4gICAgICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgLy8gcXVpY2tseSBhcHBlbmQgaW5wdXQgdG8gdGVtcCBmb3JtIGFuZCByZXNldCBmb3JtXG4gICAgICAgICAgICB2YXIgZm9ybSA9IGNyZWF0ZUVsZW1lbnQkMSgnZm9ybScpO1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBpbnB1dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIHJlZiA9IGlucHV0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBmb3JtLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIC8vIHJlLWluamVjdCBpbnB1dCB3aGVyZSBpdCBvcmlnaW5hbGx5IHdhc1xuICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCByZWYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJGEgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBzZXQgaWQgc28gY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSBvdXRzaWRlIGxhYmVsc1xuICAgICAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWJyb3dzZXItJyArIHByb3BzLmlkO1xuXG4gICAgICAgIC8vIHNldCBuYW1lIG9mIGVsZW1lbnQgKGlzIHJlbW92ZWQgd2hlbiBhIHZhbHVlIGlzIHNldClcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICduYW1lJywgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byBsaW5rIHRoaXMgZWxlbWVudCB0byB0aGUgc3RhdHVzIGVsZW1lbnRcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWNvbnRyb2xzJywgJ2ZpbGVwb25kLS1hc3Npc3RhbnQtJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyBzZXQgbGFiZWwsIHdlIHVzZSBsYWJlbGxlZCBieSBhcyBvdGhlcndpc2UgdGhlIHNjcmVlbnJlYWRlciBkb2VzIG5vdCByZWFkIHRoZSBcImJyb3dzZVwiIHRleHQgaW4gdGhlIGxhYmVsIChhcyBpdCBoYXMgdGFiaW5kZXg6IDApXG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1sYWJlbGxlZGJ5JywgJ2ZpbGVwb25kLS1kcm9wLWxhYmVsLScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gc2V0IGNvbmZpZ3VyYWJsZSBwcm9wc1xuICAgICAgICBzZXRBY2NlcHRlZEZpbGVUeXBlcyh7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVBbGxvd011bHRpcGxlKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKSB9IH0pO1xuICAgICAgICB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoe1xuICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFknKSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdG9nZ2xlRGlzYWJsZWQoeyByb290OiByb290IH0pO1xuICAgICAgICB0b2dnbGVSZXF1aXJlZCh7IHJvb3Q6IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX1JFUVVJUkVEJykgfSB9KTtcbiAgICAgICAgc2V0Q2FwdHVyZU1ldGhvZCh7IHJvb3Q6IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0NBUFRVUkVfTUVUSE9EJykgfSB9KTtcblxuICAgICAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCFyb290LmVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZmlsZXMgYW5kIG1vdmUgdmFsdWUgb2Ygd2Via2l0UmVsYXRpdmVQYXRoIHBhdGggdG8gX3JlbGF0aXZlUGF0aFxuICAgICAgICAgICAgdmFyIGZpbGVzID0gQXJyYXkuZnJvbShyb290LmVsZW1lbnQuZmlsZXMpLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gd2UgYWRkIGEgbGl0dGxlIGRlbGF5IHNvIHRoZSBPUyBmaWxlIHNlbGVjdCB3aW5kb3cgY2FuIG1vdmUgb3V0IG9mIHRoZSB3YXkgYmVmb3JlIHdlIGFkZCBvdXIgZmlsZVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2FkIGZpbGVzXG4gICAgICAgICAgICAgICAgcHJvcHMub25sb2FkKGZpbGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGlucHV0LCBpdCdzIGp1c3QgZm9yIGV4cG9zaW5nIGEgbWV0aG9kIHRvIGRyb3AgZmlsZXMsIHNob3VsZCBub3QgcmV0YWluIGFueSBzdGF0ZVxuICAgICAgICAgICAgICAgIHJlc2V0RmlsZUlucHV0KHJvb3QuZWxlbWVudCk7XG4gICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0QWNjZXB0ZWRGaWxlVHlwZXMgPSBmdW5jdGlvbiBzZXRBY2NlcHRlZEZpbGVUeXBlcyhfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1NZTkNfQUNDRVBUX0FUVFJJQlVURScpKSByZXR1cm47XG4gICAgICAgIGF0dHJUb2dnbGUoXG4gICAgICAgICAgICByb290LmVsZW1lbnQsXG4gICAgICAgICAgICAnYWNjZXB0JyxcbiAgICAgICAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgYWN0aW9uLnZhbHVlID8gYWN0aW9uLnZhbHVlLmpvaW4oJywnKSA6ICcnXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVBbGxvd011bHRpcGxlID0gZnVuY3Rpb24gdG9nZ2xlQWxsb3dNdWx0aXBsZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnbXVsdGlwbGUnLCBhY3Rpb24udmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyID0gZnVuY3Rpb24gdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICd3ZWJraXRkaXJlY3RvcnknLCBhY3Rpb24udmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlRGlzYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVEaXNhYmxlZChfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3Q7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHZhciBkb2VzQWxsb3dCcm93c2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgICAgIHZhciBkaXNhYmxlRmllbGQgPSBpc0Rpc2FibGVkIHx8ICFkb2VzQWxsb3dCcm93c2U7XG4gICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnZGlzYWJsZWQnLCBkaXNhYmxlRmllbGQpO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlUmVxdWlyZWQgPSBmdW5jdGlvbiB0b2dnbGVSZXF1aXJlZChfcmVmNikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNi5hY3Rpb247XG4gICAgICAgIC8vIHdhbnQgdG8gcmVtb3ZlIHJlcXVpcmVkLCBhbHdheXMgcG9zc2libGVcbiAgICAgICAgaWYgKCFhY3Rpb24udmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2FudCB0byBtYWtlIHJlcXVpcmVkLCBvbmx5IHBvc3NpYmxlIHdoZW4gemVybyBpdGVtc1xuICAgICAgICBlbHNlIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA9PT0gMCkge1xuICAgICAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzZXRDYXB0dXJlTWV0aG9kID0gZnVuY3Rpb24gc2V0Q2FwdHVyZU1ldGhvZChfcmVmNykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgIGF0dHJUb2dnbGUoXG4gICAgICAgICAgICByb290LmVsZW1lbnQsXG4gICAgICAgICAgICAnY2FwdHVyZScsXG4gICAgICAgICAgICAhIWFjdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGFjdGlvbi52YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYWN0aW9uLnZhbHVlXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVSZXF1aXJlZFN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVJlcXVpcmVkU3RhdHVzKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSByb290LmVsZW1lbnQ7XG4gICAgICAgIC8vIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSB3aGVuIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zXG4gICAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA+IDApIHtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgICAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAnbmFtZScsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAnbmFtZScsIHRydWUsIHJvb3QucXVlcnkoJ0dFVF9OQU1FJykpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgYW55IHZhbGlkYXRpb24gbWVzc2FnZXNcbiAgICAgICAgICAgIHZhciBzaG91bGRDaGVja1ZhbGlkaXR5ID0gcm9vdC5xdWVyeSgnR0VUX0NIRUNLX1ZBTElESVRZJyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tWYWxpZGl0eSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGFkZCByZXF1aXJlZCBpZiB0aGUgZmllbGQgaGFzIGJlZW4gZGVlbWVkIHJlcXVpcmVkXG4gICAgICAgICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1JFUVVJUkVEJykpIHtcbiAgICAgICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyhfcmVmOSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgICAgIHZhciBzaG91bGRDaGVja1ZhbGlkaXR5ID0gcm9vdC5xdWVyeSgnR0VUX0NIRUNLX1ZBTElESVRZJyk7XG4gICAgICAgIGlmICghc2hvdWxkQ2hlY2tWYWxpZGl0eSkgcmV0dXJuO1xuICAgICAgICByb290LmVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkocm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lOVkFMSURfRklFTEQnKSk7XG4gICAgfTtcblxuICAgIHZhciBicm93c2VyID0gY3JlYXRlVmlldyh7XG4gICAgICAgIHRhZzogJ2lucHV0JyxcbiAgICAgICAgbmFtZTogJ2Jyb3dzZXInLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkYSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmMTApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjEwLnJvb3Q7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgICAgICAgRElEX1JFTU9WRV9JVEVNOiB1cGRhdGVSZXF1aXJlZFN0YXR1cyxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMsXG5cbiAgICAgICAgICAgIERJRF9TRVRfRElTQUJMRUQ6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgICAgICAgRElEX1NFVF9BTExPV19CUk9XU0U6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgICAgICAgRElEX1NFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZOiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIsXG4gICAgICAgICAgICBESURfU0VUX0FMTE9XX01VTFRJUExFOiB0b2dnbGVBbGxvd011bHRpcGxlLFxuICAgICAgICAgICAgRElEX1NFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTOiBzZXRBY2NlcHRlZEZpbGVUeXBlcyxcbiAgICAgICAgICAgIERJRF9TRVRfQ0FQVFVSRV9NRVRIT0Q6IHNldENhcHR1cmVNZXRob2QsXG4gICAgICAgICAgICBESURfU0VUX1JFUVVJUkVEOiB0b2dnbGVSZXF1aXJlZCxcbiAgICAgICAgfSksXG4gICAgfSk7XG5cbiAgICB2YXIgS2V5ID0ge1xuICAgICAgICBFTlRFUjogMTMsXG4gICAgICAgIFNQQUNFOiAzMixcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSRiID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbGFiZWwgYW5kIGxpbmsgaXQgdG8gdGhlIGZpbGUgYnJvd3NlclxuICAgICAgICB2YXIgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgICAgIGF0dHIobGFiZWwsICdmb3InLCAnZmlsZXBvbmQtLWJyb3dzZXItJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyB1c2UgZm9yIGxhYmVsaW5nIGZpbGUgaW5wdXQgKGFyaWEtbGFiZWxsZWRieSBvbiBmaWxlIGlucHV0KVxuICAgICAgICBhdHRyKGxhYmVsLCAnaWQnLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyBoYW5kbGUga2V5c1xuICAgICAgICByb290LnJlZi5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZhdGlvbktleSA9IGUua2V5Q29kZSA9PT0gS2V5LkVOVEVSIHx8IGUua2V5Q29kZSA9PT0gS2V5LlNQQUNFO1xuICAgICAgICAgICAgaWYgKCFpc0FjdGl2YXRpb25LZXkpIHJldHVybjtcbiAgICAgICAgICAgIC8vIHN0b3BzIGZyb20gdHJpZ2dlcmluZyB0aGUgZWxlbWVudCBhIHNlY29uZCB0aW1lXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgICAgICByb290LnJlZi5sYWJlbC5jbGljaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2xpY2sgdHdpY2VcbiAgICAgICAgICAgIGlmIChpc0xhYmVsQ2xpY2spIHJldHVybjtcblxuICAgICAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgcHJvcHMuY2FwdGlvbik7XG5cbiAgICAgICAgLy8gYWRkIVxuICAgICAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgcm9vdC5yZWYubGFiZWwgPSBsYWJlbDtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUxhYmVsVmFsdWUgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGNsaWNrYWJsZSA9IGxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWxlcG9uZC0tbGFiZWwtYWN0aW9uJyk7XG4gICAgICAgIGlmIChjbGlja2FibGUpIHtcbiAgICAgICAgICAgIGF0dHIoY2xpY2thYmxlLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRyb3BMYWJlbCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGIsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9TRVRfTEFCRUxfSURMRTogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9JRExFKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgICAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogJ2RyaXAtYmxvYicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGFkZEJsb2IgPSBmdW5jdGlvbiBhZGRCbG9iKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJsb2IsIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogMi41LFxuICAgICAgICAgICAgICAgIHNjYWxlWTogMi41LFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogY2VudGVyWSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBtb3ZlQmxvYiA9IGZ1bmN0aW9uIG1vdmVCbG9iKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICBhZGRCbG9iKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWSA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcDtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAxO1xuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIHZhciBoaWRlQmxvYiA9IGZ1bmN0aW9uIGhpZGVCbG9iKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdDtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGxvZGVCbG9iID0gZnVuY3Rpb24gZXhwbG9kZUJsb2IoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDIuNTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ3ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zO1xuICAgICAgICByb3V0ZSQ0KHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuICAgICAgICB2YXIgYmxvYiA9IHJvb3QucmVmLmJsb2I7XG5cbiAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwICYmIGJsb2IgJiYgYmxvYi5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQ0ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgICAgIERJRF9EUk9QOiBleHBsb2RlQmxvYixcbiAgICAgICAgRElEX0VORF9EUkFHOiBoaWRlQmxvYixcbiAgICB9KTtcblxuICAgIHZhciBkcmlwID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIG5hbWU6ICdkcmlwJyxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDcsXG4gICAgfSk7XG5cbiAgICB2YXIgc2V0SW5wdXRGaWxlcyA9IGZ1bmN0aW9uIHNldElucHV0RmlsZXMoZWxlbWVudCwgZmlsZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIERhdGFUcmFuc2ZlciBpbnN0YW5jZSBhbmQgYWRkIGEgbmV3bHkgY3JlYXRlZCBmaWxlXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLml0ZW1zLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlKFtmaWxlXSwgZmlsZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBEYXRhVHJhbnNmZXIgZmlsZXMgbGlzdCB0byB0aGUgZmlsZSBpbnB1dFxuICAgICAgICAgICAgZWxlbWVudC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICByb290LnJlZi5maWVsZHMgPSB7fTtcbiAgICAgICAgdmFyIGxlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xlZ2VuZCcpO1xuICAgICAgICBsZWdlbmQudGV4dENvbnRlbnQgPSAnRmlsZXMnO1xuICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQobGVnZW5kKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpZWxkID0gZnVuY3Rpb24gZ2V0RmllbGQocm9vdCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucmVmLmZpZWxkc1tpZF07XG4gICAgfTtcblxuICAgIHZhciBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMgPSBmdW5jdGlvbiBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCkge1xuICAgICAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUmVvcmRlckl0ZW1zID0gZnVuY3Rpb24gZGlkUmVvcmRlckl0ZW1zKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgcmV0dXJuIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFkZEl0ZW0gPSBmdW5jdGlvbiBkaWRBZGRJdGVtKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgaXNMb2NhbEZpbGUgPSBmaWxlSXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUw7XG4gICAgICAgIHZhciBzaG91bGRVc2VGaWxlSW5wdXQgPSAhaXNMb2NhbEZpbGUgJiYgcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJyk7XG4gICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCQxKCdpbnB1dCcpO1xuICAgICAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSBzaG91bGRVc2VGaWxlSW5wdXQgPyAnZmlsZScgOiAnaGlkZGVuJztcbiAgICAgICAgZGF0YUNvbnRhaW5lci5uYW1lID0gcm9vdC5xdWVyeSgnR0VUX05BTUUnKTtcbiAgICAgICAgcm9vdC5yZWYuZmllbGRzW2FjdGlvbi5pZF0gPSBkYXRhQ29udGFpbmVyO1xuICAgICAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG4gICAgfTtcblxuICAgIHZhciBkaWRMb2FkSXRlbSQxID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG5cbiAgICAgICAgLy8gc3RvcmUgc2VydmVyIHJlZiBpbiBoaWRkZW4gaW5wdXRcbiAgICAgICAgaWYgKGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlICE9PSBudWxsKSBmaWVsZC52YWx1ZSA9IGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgIC8vIHN0b3JlIGZpbGUgaXRlbSBpbiBmaWxlIGlucHV0XG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcblxuICAgICAgICB2YXIgZmlsZUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgIHNldElucHV0RmlsZXMoZmllbGQsIFtmaWxlSXRlbS5maWxlXSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRQcmVwYXJlT3V0cHV0ID0gZnVuY3Rpb24gZGlkUHJlcGFyZU91dHB1dChfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICAgIC8vIHRoaXMgdGltZW91dCBwdXNoZXMgdGhlIGhhbmRsZXIgYWZ0ZXIgJ2xvYWQnXG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRJbnB1dEZpbGVzKGZpZWxkLCBbYWN0aW9uLmZpbGVdKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIHZhciBkaWRTZXREaXNhYmxlZCA9IGZ1bmN0aW9uIGRpZFNldERpc2FibGVkKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgfTtcblxuICAgIHZhciBkaWRSZW1vdmVJdGVtID0gZnVuY3Rpb24gZGlkUmVtb3ZlSXRlbShfcmVmNykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICAgICAgaWYgKGZpZWxkLnBhcmVudE5vZGUpIGZpZWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmllbGQpO1xuICAgICAgICBkZWxldGUgcm9vdC5yZWYuZmllbGRzW2FjdGlvbi5pZF07XG4gICAgfTtcblxuICAgIC8vIG9ubHkgcnVucyBmb3Igc2VydmVyIGZpbGVzLiB3aWxsIHJlZnVzZSB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIHRoZSBmaWVsZFxuICAgIC8vIGlzIGEgZmlsZSBmaWVsZFxuICAgIHZhciBkaWREZWZpbmVWYWx1ZSA9IGZ1bmN0aW9uIGRpZERlZmluZVZhbHVlKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY4LmFjdGlvbjtcbiAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgICAgICBpZiAoYWN0aW9uLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgZmllbGQucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0IGZpZWxkIHZhbHVlXG4gICAgICAgICAgICBpZiAoZmllbGQudHlwZSAhPSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ4ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0RJU0FCTEVEOiBkaWRTZXREaXNhYmxlZCxcbiAgICAgICAgRElEX0FERF9JVEVNOiBkaWRBZGRJdGVtLFxuICAgICAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbSQxLFxuICAgICAgICBESURfUkVNT1ZFX0lURU06IGRpZFJlbW92ZUl0ZW0sXG4gICAgICAgIERJRF9ERUZJTkVfVkFMVUU6IGRpZERlZmluZVZhbHVlLFxuICAgICAgICBESURfUFJFUEFSRV9PVVRQVVQ6IGRpZFByZXBhcmVPdXRwdXQsXG4gICAgICAgIERJRF9SRU9SREVSX0lURU1TOiBkaWRSZW9yZGVySXRlbXMsXG4gICAgICAgIERJRF9TT1JUX0lURU1TOiBkaWRSZW9yZGVySXRlbXMsXG4gICAgfSk7XG5cbiAgICB2YXIgZGF0YSA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkYyxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDgsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Um9vdE5vZGUgPSBmdW5jdGlvbiBnZXRSb290Tm9kZShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAnZ2V0Um9vdE5vZGUnIGluIGVsZW1lbnQgPyBlbGVtZW50LmdldFJvb3ROb2RlKCkgOiBkb2N1bWVudDtcbiAgICB9O1xuXG4gICAgdmFyIGltYWdlcyA9IFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2dpZicsICdibXAnLCAnd2VicCcsICdzdmcnLCAndGlmZiddO1xuICAgIHZhciB0ZXh0JDEgPSBbJ2NzcycsICdjc3YnLCAnaHRtbCcsICd0eHQnXTtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgICB6aXA6ICd6aXB8Y29tcHJlc3NlZCcsXG4gICAgICAgIGVwdWI6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgfTtcblxuICAgIHZhciBndWVzc3RpbWF0ZU1pbWVUeXBlID0gZnVuY3Rpb24gZ3Vlc3N0aW1hdGVNaW1lVHlwZSgpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaW1hZ2VzLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ2ltYWdlLycgK1xuICAgICAgICAgICAgICAgIChleHRlbnNpb24gPT09ICdqcGcnID8gJ2pwZWcnIDogZXh0ZW5zaW9uID09PSAnc3ZnJyA/ICdzdmcreG1sJyA6IGV4dGVuc2lvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQkMS5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RleHQvJyArIGV4dGVuc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBbZXh0ZW5zaW9uXSB8fCAnJztcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyA9IGZ1bmN0aW9uIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBsaW5rcyBmcm9tIHRyYW5zZmVyLCBpZiBmb3VuZCB3ZSdsbCBleGl0IGltbWVkaWF0ZWx5ICh1bmxlc3MgYSBmaWxlIGlzIGluIHRoZSBkYXRhVHJhbnNmZXIgYXMgd2VsbCwgdGhpcyBpcyBiZWNhdXNlIEZpcmVmb3ggY291bGQgcmVwcmVzZW50IHRoZSBmaWxlIGFzIGEgVVJMIGFuZCBhIGZpbGUgb2JqZWN0IGF0IHRoZSBzYW1lIHRpbWUpXG4gICAgICAgICAgICB2YXIgbGlua3MgPSBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCAmJiAhaGFzRmlsZXMoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpbmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgZmlsZXMgZnJvbSB0aGUgdHJhbnNmZXJcbiAgICAgICAgICAgIGdldEZpbGVzKGRhdGFUcmFuc2ZlcikudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgZGF0YXRyYW5zZmVyIGhhcyBmaWxlc1xuICAgICAqL1xuICAgIHZhciBoYXNGaWxlcyA9IGZ1bmN0aW9uIGhhc0ZpbGVzKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBpZiAoZGF0YVRyYW5zZmVyLmZpbGVzKSByZXR1cm4gZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgZmlsZXMgZnJvbSBhIERhdGFUcmFuc2ZlciBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB0cmFuc2ZlciBpdGVtcyBhcyBwcm9taXNlc1xuICAgICAgICAgICAgdmFyIHByb21pc2VkRmlsZXMgPSAoZGF0YVRyYW5zZmVyLml0ZW1zID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuaXRlbXMpIDogW10pXG4gICAgICAgICAgICAgICAgLy8gb25seSBrZWVwIGZpbGUgc3lzdGVtIGl0ZW1zIChmaWxlcyBhbmQgZGlyZWN0b3JpZXMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAvLyBtYXAgZWFjaCBpdGVtIHRvIHByb21pc2VcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpbGVzRnJvbUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGlzIGVtcHR5LCBzZWUgaWYgd2UgY2FuIGV4dHJhY3Qgc29tZSBpbmZvIGZyb20gdGhlIGZpbGVzIHByb3BlcnR5IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgICAgIGlmICghcHJvbWlzZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0ZXN0IGZvciBkaXJlY3RvcmllcyAoc2hvdWxkIG5vdCBiZSBhbGxvd2VkKVxuICAgICAgICAgICAgICAgIC8vIFVzZSBGaWxlUmVhZGVyLCBwcm9ibGVtIGlzIHRoYXQgdGhlIGZpbGVzIHByb3BlcnR5IGdldHMgbG9zdCBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YVRyYW5zZmVyLmZpbGVzID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuZmlsZXMpIDogW10pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VkRmlsZXMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0dXJuZWRGaWxlR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZEZpbGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaC5hcHBseShmaWxlcywgZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIChmaWx0ZXIgb3V0IGVtcHR5IGZpbGVzKSFcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZS5fcmVsYXRpdmVQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNGaWxlU3lzdGVtSXRlbSA9IGZ1bmN0aW9uIGlzRmlsZVN5c3RlbUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXNFbnRyeShpdGVtKSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZ2V0QXNFbnRyeShpdGVtKTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5pc0ZpbGUgfHwgZW50cnkuaXNEaXJlY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ2ZpbGUnO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZXNGcm9tSXRlbSA9IGZ1bmN0aW9uIGdldEZpbGVzRnJvbUl0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNEaXJlY3RvcnlFbnRyeShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGdldEZpbGVzSW5EaXJlY3RvcnkoZ2V0QXNFbnRyeShpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKFtpdGVtLmdldEFzRmlsZSgpXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZXNJbkRpcmVjdG9yeSA9IGZ1bmN0aW9uIGdldEZpbGVzSW5EaXJlY3RvcnkoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgICAgICAgIC8vIHRoZSB0b3RhbCBlbnRyaWVzIHRvIHJlYWRcbiAgICAgICAgICAgIHZhciBkaXJDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHZhciBmaWxlQ291bnRlciA9IDA7XG5cbiAgICAgICAgICAgIHZhciByZXNvbHZlSWZEb25lID0gZnVuY3Rpb24gcmVzb2x2ZUlmRG9uZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUNvdW50ZXIgPT09IDAgJiYgZGlyQ291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgcmVhZEVudHJpZXMgPSBmdW5jdGlvbiByZWFkRW50cmllcyhkaXJFbnRyeSkge1xuICAgICAgICAgICAgICAgIGRpckNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yaWVzIGFyZSByZXR1cm5lZCBpbiBiYXRjaGVzLCB3ZSBuZWVkIHRvIHByb2Nlc3MgYWxsIGJhdGNoZXMgYmVmb3JlIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICB2YXIgcmVhZEJhdGNoID0gZnVuY3Rpb24gcmVhZEJhdGNoKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHJlYWQgbW9yZSBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBhcyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkRmlsZSA9IGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZnVsbFBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkRmlsZS5fcmVsYXRpdmVQYXRoID0gZW50cnkuZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvcnJlY3RlZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgbmV4dCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHJlYWQgZmlyc3QgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGdvIVxuICAgICAgICAgICAgcmVhZEVudHJpZXMoZW50cnkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUgPSBmdW5jdGlvbiBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUudHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgICAgICB2YXIgZGF0ZSA9IGZpbGUubGFzdE1vZGlmaWVkRGF0ZTtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgIHZhciB0eXBlID0gZ3Vlc3N0aW1hdGVNaW1lVHlwZShnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZS5uYW1lKSk7XG4gICAgICAgIGlmICghdHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgICAgICBmaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIHR5cGUpO1xuICAgICAgICBmaWxlLm5hbWUgPSBuYW1lO1xuICAgICAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBkYXRlO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRGlyZWN0b3J5RW50cnkgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGlzRW50cnkoaXRlbSkgJiYgKGdldEFzRW50cnkoaXRlbSkgfHwge30pLmlzRGlyZWN0b3J5O1xuICAgIH07XG5cbiAgICB2YXIgaXNFbnRyeSA9IGZ1bmN0aW9uIGlzRW50cnkoaXRlbSkge1xuICAgICAgICByZXR1cm4gJ3dlYmtpdEdldEFzRW50cnknIGluIGl0ZW07XG4gICAgfTtcblxuICAgIHZhciBnZXRBc0VudHJ5ID0gZnVuY3Rpb24gZ2V0QXNFbnRyeShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgbGlua3MgZnJvbSBhIERhdGFUcmFuc2ZlciBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgZ2V0TGlua3MgPSBmdW5jdGlvbiBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBsb29rIGluIG1ldGEgZGF0YSBwcm9wZXJ0eVxuICAgICAgICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9wZSBub3BlIG5vcGUgKHByb2JhYmx5IElFIHRyb3VibGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGlua3NGcm9tVHJhbnNmZXJVUkxEYXRhID0gZnVuY3Rpb24gZ2V0TGlua3NGcm9tVHJhbnNmZXJVUkxEYXRhKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd1cmwnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtkYXRhXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIHZhciBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhID0gZnVuY3Rpb24gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZGF0YS5tYXRjaCgvc3JjXFxzKj1cXHMqXCIoLis/KVwiLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbWF0Y2hlc1sxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ05Ecm9wT2JzZXJ2ZXJzID0gW107XG5cbiAgICB2YXIgZXZlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIGV2ZW50UG9zaXRpb24oZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFnZUxlZnQ6IGUucGFnZVgsXG4gICAgICAgICAgICBwYWdlVG9wOiBlLnBhZ2VZLFxuICAgICAgICAgICAgc2NvcGVMZWZ0OiBlLm9mZnNldFggfHwgZS5sYXllclgsXG4gICAgICAgICAgICBzY29wZVRvcDogZS5vZmZzZXRZIHx8IGUubGF5ZXJZLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRHJhZ05Ecm9wQ2xpZW50ID0gZnVuY3Rpb24gY3JlYXRlRHJhZ05Ecm9wQ2xpZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBzY29wZVRvT2JzZXJ2ZSxcbiAgICAgICAgZmlsdGVyRWxlbWVudFxuICAgICkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBnZXREcmFnTkRyb3BPYnNlcnZlcihzY29wZVRvT2JzZXJ2ZSk7XG5cbiAgICAgICAgdmFyIGNsaWVudCA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBmaWx0ZXJFbGVtZW50OiBmaWx0ZXJFbGVtZW50LFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBvbmRyb3A6IGZ1bmN0aW9uIG9uZHJvcCgpIHt9LFxuICAgICAgICAgICAgb25lbnRlcjogZnVuY3Rpb24gb25lbnRlcigpIHt9LFxuICAgICAgICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgICAgICAgIG9uZXhpdDogZnVuY3Rpb24gb25leGl0KCkge30sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICAgICAgYWxsb3dkcm9wOiBmdW5jdGlvbiBhbGxvd2Ryb3AoKSB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQuZGVzdHJveSA9IG9ic2VydmVyLmFkZExpc3RlbmVyKGNsaWVudCk7XG5cbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9O1xuXG4gICAgdmFyIGdldERyYWdORHJvcE9ic2VydmVyID0gZnVuY3Rpb24gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCkge1xuICAgICAgICAvLyBzZWUgaWYgYWxyZWFkeSBleGlzdHMsIGlmIHNvLCByZXR1cm5cbiAgICAgICAgdmFyIG9ic2VydmVyID0gZHJhZ05Ecm9wT2JzZXJ2ZXJzLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZlciwgZG9lcyBub3QgeWV0IGV4aXN0IGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgdmFyIG5ld09ic2VydmVyID0gY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCk7XG4gICAgICAgIGRyYWdORHJvcE9ic2VydmVycy5wdXNoKG5ld09ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIG5ld09ic2VydmVyO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIgPSBmdW5jdGlvbiBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KSB7XG4gICAgICAgIHZhciBjbGllbnRzID0gW107XG5cbiAgICAgICAgdmFyIHJvdXRlcyA9IHtcbiAgICAgICAgICAgIGRyYWdlbnRlcjogZHJhZ2VudGVyLFxuICAgICAgICAgICAgZHJhZ292ZXI6IGRyYWdvdmVyLFxuICAgICAgICAgICAgZHJhZ2xlYXZlOiBkcmFnbGVhdmUsXG4gICAgICAgICAgICBkcm9wOiBkcm9wLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIGZvcmluKHJvdXRlcywgZnVuY3Rpb24oZXZlbnQsIGNyZWF0ZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2xpZW50cyk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhcyBjbGllbnRcbiAgICAgICAgICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZW1vdmVMaXN0ZW5lciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRzLnNwbGljZShjbGllbnRzLmluZGV4T2YoY2xpZW50KSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gbW9yZSBjbGllbnRzLCBjbGVhbiB1cCBvYnNlcnZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdORHJvcE9ic2VydmVycy5zcGxpY2UoZHJhZ05Ecm9wT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1lbnRGcm9tUG9pbnQgPSBmdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHBvaW50KSB7XG4gICAgICAgIGlmICghKCdlbGVtZW50RnJvbVBvaW50JyBpbiByb290KSkge1xuICAgICAgICAgICAgcm9vdCA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfTtcblxuICAgIHZhciBpc0V2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gaXNFdmVudFRhcmdldChlLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gZ2V0IHJvb3RcbiAgICAgICAgdmFyIHJvb3QgPSBnZXRSb290Tm9kZSh0YXJnZXQpO1xuXG4gICAgICAgIC8vIGdldCBlbGVtZW50IGF0IHBvc2l0aW9uXG4gICAgICAgIC8vIGlmIHJvb3QgaXMgbm90IGFjdHVhbCBzaGFkb3cgRE9NIGFuZCBkb2VzIG5vdCBoYXZlIGVsZW1lbnRGcm9tUG9pbnQgbWV0aG9kLCB1c2UgdGhlIG9uZSBvbiBkb2N1bWVudFxuICAgICAgICB2YXIgZWxlbWVudEF0UG9zaXRpb24gPSBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHtcbiAgICAgICAgICAgIHg6IGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICB5OiBlLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0ZXN0IGlmIHRhcmdldCBpcyB0aGUgZWxlbWVudCBvciBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gICAgICAgIHJldHVybiBlbGVtZW50QXRQb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhlbGVtZW50QXRQb3NpdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBpbml0aWFsVGFyZ2V0ID0gbnVsbDtcblxuICAgIHZhciBzZXREcm9wRWZmZWN0ID0gZnVuY3Rpb24gc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsIGVmZmVjdCkge1xuICAgICAgICAvLyBpcyBpbiB0cnkgY2F0Y2ggYXMgSUUxMSB3aWxsIHRocm93IGVycm9yIGlmIG5vdFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfTtcblxuICAgIHZhciBkcmFnZW50ZXIgPSBmdW5jdGlvbiBkcmFnZW50ZXIocm9vdCwgY2xpZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpbml0aWFsVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgICAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNsaWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBvbmVudGVyID0gY2xpZW50Lm9uZW50ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdvdmVyID0gZnVuY3Rpb24gZHJhZ292ZXIocm9vdCwgY2xpZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgICAgICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlckRyb3BUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNsaWVudHMuc29tZShmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW50ZXIgPSBjbGllbnQub25lbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmRyYWcgPSBjbGllbnQub25kcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlIGNhbiBkcm9wXG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnY29weScpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRyYW5zZmVyIG9mIHRoZXNlIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxvd3NUcmFuc2ZlciA9IGFsbG93ZHJvcChpdGVtcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB1c2VkIHdoZW4gY2FuIGJlIGRyb3BwZWQgb24gcGFnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldHRpbmcgdGhpcyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJEcm9wVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFkIG5vIHByZXZpb3VzIHN0YXRlLCBtZWFucyB3ZSBhcmUgZW50ZXJpbmcgdGhpcyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgb3ZlciBlbGVtZW50IChubyBtYXR0ZXIgaWYgaXQgYWxsb3dzIHRoZSBkcm9wIG9yIG5vdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdvdmVyJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYWxsb3cgdHJhbnNmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZHJhZyhldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBvdmVyIGFuIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIW92ZXJEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUganVzdCBsZWZ0IHRoaXMgY2xpZW50P1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKHJvb3QsIGNsaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgICAgICAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZGF0YVRyYW5zZmVyKS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyRWxlbWVudCA9IGNsaWVudC5maWx0ZXJFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGNsaWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25kcm9wID0gY2xpZW50Lm9uZHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2Ryb3AgPSBjbGllbnQuYWxsb3dkcm9wO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgZmlsdGVyaW5nIG9uIGVsZW1lbnQgd2UgbmVlZCB0byBiZSBvdmVyIHRoZSBlbGVtZW50IHRvIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIWlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBubyB0cmFuc2ZlciBmb3IgdGhpcyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2Ryb3AoaXRlbXMpKSByZXR1cm4gb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBkcm9wIHRoZXNlIGl0ZW1zIG9uIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIG9uZHJvcChldmVudFBvc2l0aW9uKGUpLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdsZWF2ZSA9IGZ1bmN0aW9uIGRyYWdsZWF2ZShyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25leGl0ID0gY2xpZW50Lm9uZXhpdDtcblxuICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUhvcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUhvcHBlcihzY29wZSwgdmFsaWRhdGVJdGVtcywgb3B0aW9ucykge1xuICAgICAgICAvLyBpcyBub3cgaG9wcGVyIHNjb3BlXG4gICAgICAgIHNjb3BlLmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1ob3BwZXInKTtcblxuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgdmFyIGNhdGNoZXNEcm9wc09uUGFnZSA9IG9wdGlvbnMuY2F0Y2hlc0Ryb3BzT25QYWdlLFxuICAgICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50ID0gb3B0aW9ucy5yZXF1aXJlc0Ryb3BPbkVsZW1lbnQsXG4gICAgICAgICAgICBfb3B0aW9ucyRmaWx0ZXJJdGVtcyA9IG9wdGlvbnMuZmlsdGVySXRlbXMsXG4gICAgICAgICAgICBmaWx0ZXJJdGVtcyA9XG4gICAgICAgICAgICAgICAgX29wdGlvbnMkZmlsdGVySXRlbXMgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogX29wdGlvbnMkZmlsdGVySXRlbXM7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgZG5kIGNsaWVudFxuICAgICAgICB2YXIgY2xpZW50ID0gY3JlYXRlRHJhZ05Ecm9wQ2xpZW50KFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBjYXRjaGVzRHJvcHNPblBhZ2UgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBzY29wZSxcbiAgICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgY2xpZW50IHN0YXRlXG4gICAgICAgIHZhciBsYXN0U3RhdGUgPSAnJztcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9ICcnO1xuXG4gICAgICAgIC8vIGRldGVybWluZXMgaWYgYSBmaWxlIG1heSBiZSBkcm9wcGVkXG4gICAgICAgIGNsaWVudC5hbGxvd2Ryb3AgPSBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgd2UgY2FuLCB0aHJvdyBlcnJvciB0byBpbmRpY2F0ZSB0aGUgaXRlbXMgY2Fubm90IGJ5IGRyb3BwZWRcblxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSXRlbXMoZmlsdGVySXRlbXMoaXRlbXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQub25kcm9wID0gZnVuY3Rpb24ocG9zaXRpb24sIGl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IGZpbHRlckl0ZW1zKGl0ZW1zKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUl0ZW1zKGZpbHRlcmVkSXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1kcm9wJztcblxuICAgICAgICAgICAgYXBpLm9ubG9hZChmaWx0ZXJlZEl0ZW1zLCBwb3NpdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xpZW50Lm9uZHJhZyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBhcGkub25kcmFnKHBvc2l0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQub25lbnRlciA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1vdmVyJztcblxuICAgICAgICAgICAgYXBpLm9uZHJhZ3N0YXJ0KHBvc2l0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQub25leGl0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLWV4aXQnO1xuXG4gICAgICAgICAgICBhcGkub25kcmFnZW5kKHBvc2l0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgdXBkYXRlSG9wcGVyU3RhdGU6IGZ1bmN0aW9uIHVwZGF0ZUhvcHBlclN0YXRlKCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5kYXRhc2V0LmhvcHBlclN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgICAgICBvbmRyYWdzdGFydDogZnVuY3Rpb24gb25kcmFnc3RhcnQoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZzogZnVuY3Rpb24gb25kcmFnKCkge30sXG4gICAgICAgICAgICBvbmRyYWdlbmQ6IGZ1bmN0aW9uIG9uZHJhZ2VuZCgpIHt9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IGNsaWVudFxuICAgICAgICAgICAgICAgIGNsaWVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICB2YXIgbGlzdGVuZXJzJDEgPSBbXTtcblxuICAgIHZhciBoYW5kbGVQYXN0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUpIHtcbiAgICAgICAgLy8gaWYgaXMgcGFzdGluZyBpbiBpbnB1dCBvciB0ZXh0YXJlYSBhbmQgdGhlIHRhcmdldCBpcyBvdXRzaWRlIG9mIGEgZmlsZXBvbmQgc2NvcGUsIGlnbm9yZVxuICAgICAgICB2YXIgYWN0aXZlRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB2YXIgaXNBY3RpdmVFbGVtZW50RWRpdGFibGUgPVxuICAgICAgICAgICAgYWN0aXZlRWwgJiZcbiAgICAgICAgICAgICgvdGV4dGFyZWF8aW5wdXQvaS50ZXN0KGFjdGl2ZUVsLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIGFjdGl2ZUVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJyk7XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlRWxlbWVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAvLyB0ZXN0IHRleHRhcmVhIG9yIGlucHV0IGlzIGNvbnRhaW5lZCBpbiBmaWxlcG9uZCByb290XG4gICAgICAgICAgICB2YXIgaW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhY3RpdmVFbDtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlcG9uZC0tcm9vdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpblNjb3BlKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKS50aGVuKGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAgICAgICAvLyBubyBmaWxlcyByZWNlaXZlZFxuICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdGlmeSBsaXN0ZW5lcnMgb2YgcmVjZWl2ZWQgZmlsZXNcbiAgICAgICAgICAgIGxpc3RlbmVycyQxLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoZmlsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGNiKSB7XG4gICAgICAgIC8vIGNhbid0IGFkZCB0d2ljZVxuICAgICAgICBpZiAobGlzdGVuZXJzJDEuaW5jbHVkZXMoY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaW5pdGlhbCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lcnMkMS5wdXNoKGNiKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXN0ZSBsaXN0ZW5lciBmb3IgZW50aXJlIHBhZ2VcbiAgICAgICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgfTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGZ1bmN0aW9uIHVubGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXBcbiAgICAgICAgaWYgKGxpc3RlbmVycyQxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgICAgICAgICBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFzdGVyID0gZnVuY3Rpb24gY3JlYXRlUGFzdGVyKCkge1xuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiBjYihmaWxlcykge1xuICAgICAgICAgICAgYXBpLm9ubG9hZChmaWxlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuKGNiKTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJGQgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1hc3Npc3RhbnQtJyArIHByb3BzLmlkO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1yZWxldmFudCcsICdhZGRpdGlvbnMnKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG4gICAgdmFyIG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCA9IG51bGw7XG5cbiAgICB2YXIgZmlsZW5hbWVzID0gW107XG5cbiAgICB2YXIgYXNzaXN0ID0gZnVuY3Rpb24gYXNzaXN0KHJvb3QsIG1lc3NhZ2UpIHtcbiAgICAgICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgdmFyIGNsZWFyJDEgPSBmdW5jdGlvbiBjbGVhcihyb290KSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdE1vZGlmaWVkID0gZnVuY3Rpb24gbGlzdE1vZGlmaWVkKHJvb3QsIGZpbGVuYW1lLCBsYWJlbCkge1xuICAgICAgICB2YXIgdG90YWwgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgYXNzaXN0KFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhYmVsICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lICtcbiAgICAgICAgICAgICAgICAnLCAnICtcbiAgICAgICAgICAgICAgICB0b3RhbCArXG4gICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAodG90YWwgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9DT1VOVF9TSU5HVUxBUicpXG4gICAgICAgICAgICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfUExVUkFMJykpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY2xlYXIgZ3JvdXAgYWZ0ZXIgc2V0IGFtb3VudCBvZiB0aW1lIHNvIHRoZSBzdGF0dXMgaXMgbm90IHJlYWQgdHdpY2VcbiAgICAgICAgY2xlYXJUaW1lb3V0KG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCk7XG4gICAgICAgIG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhciQxKHJvb3QpO1xuICAgICAgICB9LCAxNTAwKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzVXNpbmdGaWxlUG9uZCA9IGZ1bmN0aW9uIGlzVXNpbmdGaWxlUG9uZChyb290KSB7XG4gICAgICAgIHJldHVybiByb290LmVsZW1lbnQucGFyZW50Tm9kZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1BZGRlZCA9IGZ1bmN0aW9uIGl0ZW1BZGRlZChfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgIGZpbGVuYW1lcy5wdXNoKGl0ZW0uZmlsZW5hbWUpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dChhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICBhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGlzdE1vZGlmaWVkKHJvb3QsIGZpbGVuYW1lcy5qb2luKCcsICcpLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9BRERFRCcpKTtcbiAgICAgICAgICAgIGZpbGVuYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICB9LCA3NTApO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbVJlbW92ZWQgPSBmdW5jdGlvbiBpdGVtUmVtb3ZlZChfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbSA9IGFjdGlvbi5pdGVtO1xuICAgICAgICBsaXN0TW9kaWZpZWQocm9vdCwgaXRlbS5maWxlbmFtZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUkVNT1ZFRCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1Qcm9jZXNzZWQgPSBmdW5jdGlvbiBpdGVtUHJvY2Vzc2VkKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGZpbGVuYW1lICsgJyAnICsgbGFiZWwpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbVByb2Nlc3NlZFVuZG8gPSBmdW5jdGlvbiBpdGVtUHJvY2Vzc2VkVW5kbyhfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgICAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgICAgICBhc3Npc3Qocm9vdCwgZmlsZW5hbWUgKyAnICcgKyBsYWJlbCk7XG4gICAgfTtcblxuICAgIHZhciBpdGVtRXJyb3IgPSBmdW5jdGlvbiBpdGVtRXJyb3IoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcblxuICAgICAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGFjdGlvbi5zdGF0dXMubWFpbiArICcgJyArIGZpbGVuYW1lICsgJyAnICsgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICAgIH07XG5cbiAgICB2YXIgYXNzaXN0YW50ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGQsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiBpdGVtQWRkZWQsXG4gICAgICAgICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZCxcblxuICAgICAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICB9KSxcblxuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgbmFtZTogJ2Fzc2lzdGFudCcsXG4gICAgfSk7XG5cbiAgICB2YXIgdG9DYW1lbHMgPSBmdW5jdGlvbiB0b0NhbWVscyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy0nO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzZXBhcmF0b3IgKyAnLicsICdnJyksIGZ1bmN0aW9uKHN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHN1Yi5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgICAgICAgdmFyIGltbWlkaWF0ZU9ubHkgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgICB2YXIgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgICB2YXIgZGlzdCA9IERhdGUubm93KCkgLSBsYXN0O1xuXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGludGVydmFsIGFuZCBkaXN0XG4gICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGU6IGlmIGRpc3RhbmNlIGlzIDEwIG1zIGFuZCBpbnRlcnZhbCBpcyAxNiBtcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYW4gYWRkaXRpb25hbCA2bXMgYmVmb3JlIGNhbGxpbmcgdGhlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghaW1taWRpYXRlT25seSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgaW50ZXJ2YWwgLSBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdvIVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBNQVhfRklMRVNfTElNSVQgPSAxMDAwMDAwO1xuXG4gICAgdmFyIHByZXZlbnQgPSBmdW5jdGlvbiBwcmV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZSRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIEFkZCBpZFxuICAgICAgICB2YXIgaWQgPSByb290LnF1ZXJ5KCdHRVRfSUQnKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjbGFzc05hbWVcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHJvb3QucXVlcnkoJ0dFVF9DTEFTU19OQU1FJyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWVsZCBsYWJlbFxuICAgICAgICByb290LnJlZi5sYWJlbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgICAgICAgZHJvcExhYmVsLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JRExFJyksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBMaXN0IG9mIGl0ZW1zXG4gICAgICAgIHJvb3QucmVmLmxpc3QgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3RTY3JvbGxlciwgeyB0cmFuc2xhdGVZOiBudWxsIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgICAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdwYW5lbC1yb290JyB9KSk7XG5cbiAgICAgICAgLy8gQXNzaXN0YW50IG5vdGlmaWVzIGFzc2lzdGl2ZSB0ZWNoIHdoZW4gY29udGVudCBjaGFuZ2VzXG4gICAgICAgIHJvb3QucmVmLmFzc2lzdGFudCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYXNzaXN0YW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGF0YVxuICAgICAgICByb290LnJlZi5kYXRhID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZGF0YSwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgICAgIC8vIERPQ1RZUEUgbmVlZHMgdG8gYmUgc2V0IGZvciB0aGlzIHRvIHdvcmtcbiAgICAgICAgcm9vdC5yZWYubWVhc3VyZSA9IGNyZWF0ZUVsZW1lbnQkMSgnZGl2Jyk7XG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG5cbiAgICAgICAgLy8gaW5mb3JtYXRpb24gb24gdGhlIHJvb3QgaGVpZ2h0IG9yIGZpeGVkIGhlaWdodCBzdGF0dXNcbiAgICAgICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgICAgICAvLyBhcHBseSBpbml0aWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX1NUWUxFUycpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc0VtcHR5KHN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgd2lkdGggY2hhbmdlZFxuICAgICAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkID0gZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfUkVTSVpFX1JPT1QnKTtcbiAgICAgICAgfSwgMjUwKTtcblxuICAgICAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICAgICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcblxuICAgICAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICAgICAgdmFyIGNhbkhvdmVyID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwb2ludGVyOiBmaW5lKSBhbmQgKGhvdmVyOiBob3ZlciknKS5tYXRjaGVzO1xuICAgICAgICB2YXIgaGFzUG9pbnRlckV2ZW50cyA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcbiAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU9SREVSJykgJiYgaGFzUG9pbnRlckV2ZW50cyAmJiAhY2FuSG92ZXIpIHtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNyZWRpdHNcbiAgICAgICAgdmFyIGNyZWRpdHMgPSByb290LnF1ZXJ5KCdHRVRfQ1JFRElUUycpO1xuICAgICAgICB2YXIgaGFzQ3JlZGl0cyA9IGNyZWRpdHMubGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoaGFzQ3JlZGl0cykge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBmcmFnLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tY3JlZGl0cyc7XG4gICAgICAgICAgICBmcmFnLmhyZWYgPSBjcmVkaXRzWzBdO1xuICAgICAgICAgICAgZnJhZy50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgZnJhZy50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgIGZyYWcucmVsID0gJ25vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3cnO1xuICAgICAgICAgICAgZnJhZy50ZXh0Q29udGVudCA9IGNyZWRpdHNbMV07XG4gICAgICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgICAgICByb290LnJlZi5jcmVkaXRzID0gZnJhZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkOSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHMsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjMuYWN0aW9ucztcbiAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICByb3V0ZSQ1KHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gL15ESURfU0VUX1NUWUxFXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzRW1wdHkoYWN0aW9uLmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWY0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfcmVmNC5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdG9DYW1lbHModHlwZS5zdWJzdHJpbmcoOCkudG9Mb3dlckNhc2UoKSwgJ18nKTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgcm9vdC5pbnZhbGlkYXRlTGF5b3V0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LndpZHRoICE9PSByb290LnJlZi53aWR0aFByZXZpb3VzKSB7XG4gICAgICAgICAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICByb290LnJlZi53aWR0aFVwZGF0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBib3ggYm91bmRzLCB3ZSBkbyB0aGlzIG9ubHkgb25jZVxuICAgICAgICB2YXIgYm91bmRzID0gcm9vdC5yZWYuYm91bmRzO1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgYm91bmRzID0gcm9vdC5yZWYuYm91bmRzID0gY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0KHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBkZXN0cm95IG1lYXN1cmUgZWxlbWVudFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUNoaWxkKHJvb3QucmVmLm1lYXN1cmUpO1xuICAgICAgICAgICAgcm9vdC5yZWYubWVhc3VyZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlcyB0byB2YXJpb3VzIGhpZ2ggbGV2ZWwgcGFydHMgb2YgdGhlIHVwbG9hZCB0b29sXG4gICAgICAgIHZhciBfcm9vdCRyZWYgPSByb290LnJlZixcbiAgICAgICAgICAgIGhvcHBlciA9IF9yb290JHJlZi5ob3BwZXIsXG4gICAgICAgICAgICBsYWJlbCA9IF9yb290JHJlZi5sYWJlbCxcbiAgICAgICAgICAgIGxpc3QgPSBfcm9vdCRyZWYubGlzdCxcbiAgICAgICAgICAgIHBhbmVsID0gX3Jvb3QkcmVmLnBhbmVsO1xuXG4gICAgICAgIC8vIHNldHMgY29ycmVjdCBzdGF0ZSB0byBob3BwZXIgc2NvcGVcbiAgICAgICAgaWYgKGhvcHBlcikge1xuICAgICAgICAgICAgaG9wcGVyLnVwZGF0ZUhvcHBlclN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBib29sIHRvIGluZGljYXRlIGlmIHdlJ3JlIGZ1bGwgb3Igbm90XG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgdmFyIGlzTXVsdGlJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG4gICAgICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgIHZhciBtYXhJdGVtcyA9IGlzTXVsdGlJdGVtID8gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpIHx8IE1BWF9GSUxFU19MSU1JVCA6IDE7XG4gICAgICAgIHZhciBhdE1heENhcGFjaXR5ID0gdG90YWxJdGVtcyA9PT0gbWF4SXRlbXM7XG5cbiAgICAgICAgLy8gYWN0aW9uIHVzZWQgdG8gYWRkIGl0ZW1cbiAgICAgICAgdmFyIGFkZEFjdGlvbiA9IGFjdGlvbnMuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24udHlwZSA9PT0gJ0RJRF9BRERfSVRFTSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHJlYWNoZWQgbWF4IGNhcGFjaXR5IGFuZCB3ZSd2ZSBqdXN0IHJlYWNoZWQgaXRcbiAgICAgICAgaWYgKGF0TWF4Q2FwYWNpdHkgJiYgYWRkQWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBnZXQgaW50ZXJhY3Rpb24gdHlwZVxuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uTWV0aG9kID0gYWRkQWN0aW9uLmRhdGEuaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICAgICAgICAgIC8vIGhpZGUgbGFiZWxcbiAgICAgICAgICAgIGxhYmVsLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaXNNdWx0aUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gLTQwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVYID0gNDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSA0MDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gMzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhdE1heENhcGFjaXR5KSB7XG4gICAgICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSAwO1xuICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlzdEl0ZW1NYXJnaW4gPSBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KTtcblxuICAgICAgICB2YXIgbGlzdEhlaWdodCA9IGNhbGN1bGF0ZUxpc3RIZWlnaHQocm9vdCk7XG5cbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gbGFiZWwucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgdmFyIGN1cnJlbnRMYWJlbEhlaWdodCA9ICFpc011bHRpSXRlbSB8fCBhdE1heENhcGFjaXR5ID8gMCA6IGxhYmVsSGVpZ2h0O1xuXG4gICAgICAgIHZhciBsaXN0TWFyZ2luVG9wID0gYXRNYXhDYXBhY2l0eSA/IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCA6IDA7XG4gICAgICAgIHZhciBsaXN0TWFyZ2luQm90dG9tID0gdG90YWxJdGVtcyA9PT0gMCA/IDAgOiBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b207XG5cbiAgICAgICAgdmFyIHZpc3VhbEhlaWdodCA9XG4gICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC52aXN1YWwgKyBsaXN0TWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgYm91bmRzSGVpZ2h0ID1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LmJvdW5kcyArIGxpc3RNYXJnaW5Cb3R0b207XG5cbiAgICAgICAgLy8gbGluayBsaXN0IHRvIGxhYmVsIGJvdHRvbSBwb3NpdGlvblxuICAgICAgICBsaXN0LnRyYW5zbGF0ZVkgPVxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgY3VycmVudExhYmVsSGVpZ2h0IC0gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wKSAtIGxpc3RJdGVtTWFyZ2luLnRvcDtcblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIC8vIGZpeGVkIGFzcGVjdCByYXRpb1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaGVpZ2h0IGJhc2VkIG9uIHdpZHRoXG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB3aWR0aCAqIGFzcGVjdFJhdGlvO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBoaXN0b3J5IGlmIGFzcGVjdCByYXRpbyBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKGFzcGVjdFJhdGlvICE9PSByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhpcyB3aWR0aFxuICAgICAgICAgICAgdmFyIGhpc3RvcnkgPSByb290LnJlZi51cGRhdGVIaXN0b3J5O1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHdpZHRoKTtcblxuICAgICAgICAgICAgdmFyIE1BWF9CT1VOQ0VTID0gMjtcbiAgICAgICAgICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IE1BWF9CT1VOQ0VTICogMikge1xuICAgICAgICAgICAgICAgIHZhciBsID0gaGlzdG9yeS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGwgLSAxMDtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmNlcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGw7IGkgPj0gYm90dG9tOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpc3RvcnlbaV0gPT09IGhpc3RvcnlbaSAtIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuY2VzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmNlcyA+PSBNQVhfQk9VTkNFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9udCBhZGp1c3QgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpeCBoZWlnaHQgb2YgcGFuZWwgc28gaXQgYWRoZXJlcyB0byBhc3BlY3QgcmF0aW9cbiAgICAgICAgICAgIHBhbmVsLnNjYWxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBwYW5lbC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgICAgIHZhciBsaXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRzLmZpeGVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBmaXhlZCBoZWlnaHRcblxuICAgICAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbFxuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICAgICAgdmFyIF9saXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgYm91bmRzLmZpeGVkSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBsaXN0IGhlaWdodFxuICAgICAgICAgICAgaWYgKGxpc3RIZWlnaHQudmlzdWFsID4gX2xpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gX2xpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHNldCBjb250YWluZXIgYm91bmRzIGFzIHRoZXNlIGFyZSBoYW5kbGVzIGJ5IENTUyBmaXhlZCBoZWlnaHRcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZHMuY2FwcGVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBtYXgtaGVpZ2h0XG5cbiAgICAgICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICAgICAgdmFyIGlzQ2FwcGVkSGVpZ2h0ID0gdmlzdWFsSGVpZ2h0ID49IGJvdW5kcy5jYXBwZWRIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcGFuZWxIZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuY2FwcGVkSGVpZ2h0LCB2aXN1YWxIZWlnaHQpO1xuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gaXNDYXBwZWRIZWlnaHRcbiAgICAgICAgICAgICAgICA/IHBhbmVsSGVpZ2h0XG4gICAgICAgICAgICAgICAgOiBwYW5lbEhlaWdodCAtIGxpc3RJdGVtTWFyZ2luLnRvcCAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICAgICAgdmFyIF9saXN0QXZhaWxhYmxlSGVpZ2h0MiA9XG4gICAgICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgICAgIHBhbmVsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBsaXN0IGhlaWdodCAoaWYgaXMgb3ZlcmZsb3dpbmcpXG4gICAgICAgICAgICBpZiAodmlzdWFsSGVpZ2h0ID4gYm91bmRzLmNhcHBlZEhlaWdodCAmJiBsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0Mikge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgYm91bmRzLmNhcHBlZEhlaWdodCxcbiAgICAgICAgICAgICAgICBib3VuZHNIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b21cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbGV4aWJsZSBoZWlnaHRcblxuICAgICAgICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICAgICAgICB2YXIgaXRlbU1hcmdpbiA9IHRvdGFsSXRlbXMgPiAwID8gbGlzdEl0ZW1NYXJnaW4udG9wICsgbGlzdEl0ZW1NYXJnaW4uYm90dG9tIDogMDtcbiAgICAgICAgICAgIHBhbmVsLnNjYWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhbmVsLmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCB2aXN1YWxIZWlnaHQgLSBpdGVtTWFyZ2luKTtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgICAgICByb290LmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCBib3VuZHNIZWlnaHQgLSBpdGVtTWFyZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdmUgY3JlZGl0cyB0byBib3R0b21cbiAgICAgICAgaWYgKHJvb3QucmVmLmNyZWRpdHMgJiYgcGFuZWwuaGVpZ2h0Q3VycmVudClcbiAgICAgICAgICAgIHJvb3QucmVmLmNyZWRpdHMuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoJyArIHBhbmVsLmhlaWdodEN1cnJlbnQgKyAncHgpJztcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luID0gZnVuY3Rpb24gY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4ocm9vdCkge1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXS5jaGlsZFZpZXdzWzBdO1xuICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICB0b3A6IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUxpc3RIZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SGVpZ2h0KHJvb3QpIHtcbiAgICAgICAgdmFyIHZpc3VhbCA9IDA7XG4gICAgICAgIHZhciBib3VuZHMgPSAwO1xuXG4gICAgICAgIC8vIGdldCBmaWxlIGxpc3QgcmVmZXJlbmNlXG4gICAgICAgIHZhciBzY3JvbGxMaXN0ID0gcm9vdC5yZWYubGlzdDtcbiAgICAgICAgdmFyIGl0ZW1MaXN0ID0gc2Nyb2xsTGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gaXRlbUxpc3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBubyBjaGlsZHJlbiwgZG9uZSFcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgdmlzdWFsOiB2aXN1YWwsIGJvdW5kczogYm91bmRzIH07XG5cbiAgICAgICAgdmFyIGhvcml6b250YWxTcGFjZSA9IGl0ZW1MaXN0LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIGRyYWdJbmRleCA9IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCBzY3JvbGxMaXN0LmRyYWdDb29yZGluYXRlcyk7XG5cbiAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudDtcblxuICAgICAgICB2YXIgaXRlbVZlcnRpY2FsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpblRvcCArIGNoaWxkUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuXG4gICAgICAgIHZhciBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZFJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgICAgIHZhciBuZXdJdGVtID0gdHlwZW9mIGRyYWdJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZHJhZ0luZGV4ID49IDAgPyAxIDogMDtcbiAgICAgICAgdmFyIHJlbW92ZWRJdGVtID0gY2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNDU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHZhciB2ZXJ0aWNhbEl0ZW1Db3VudCA9IGNoaWxkcmVuLmxlbmd0aCArIG5ld0l0ZW0gKyByZW1vdmVkSXRlbTtcbiAgICAgICAgdmFyIGl0ZW1zUGVyUm93ID0gZ2V0SXRlbXNQZXJSb3coaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpO1xuXG4gICAgICAgIC8vIHN0YWNrXG4gICAgICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGl0ZW0ucmVjdC5lbGVtZW50LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgICAgICAgICBib3VuZHMgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpc3VhbCArPSBoZWlnaHQgKiBpdGVtLm9wYWNpdHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBncmlkXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm91bmRzID0gTWF0aC5jZWlsKHZlcnRpY2FsSXRlbUNvdW50IC8gaXRlbXNQZXJSb3cpICogaXRlbUhlaWdodDtcbiAgICAgICAgICAgIHZpc3VhbCA9IGJvdW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZpc3VhbDogdmlzdWFsLCBib3VuZHM6IGJvdW5kcyB9O1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0KHJvb3QpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgfHwgbnVsbDtcbiAgICAgICAgdmFyIGNhcHBlZEhlaWdodCA9IHBhcnNlSW50KHJvb3Quc3R5bGUubWF4SGVpZ2h0LCAxMCkgfHwgbnVsbDtcbiAgICAgICAgdmFyIGZpeGVkSGVpZ2h0ID0gaGVpZ2h0ID09PSAwID8gbnVsbCA6IGhlaWdodDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FwcGVkSGVpZ2h0OiBjYXBwZWRIZWlnaHQsXG4gICAgICAgICAgICBmaXhlZEhlaWdodDogZml4ZWRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBleGNlZWRzTWF4RmlsZXMgPSBmdW5jdGlvbiBleGNlZWRzTWF4RmlsZXMocm9vdCwgaXRlbXMpIHtcbiAgICAgICAgdmFyIGFsbG93UmVwbGFjZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRVBMQUNFJyk7XG4gICAgICAgIHZhciBhbGxvd011bHRpcGxlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG4gICAgICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgIHZhciBtYXhJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKTtcblxuICAgICAgICAvLyB0b3RhbCBhbW91bnQgb2YgaXRlbXMgYmVpbmcgZHJhZ2dlZFxuICAgICAgICB2YXIgdG90YWxCcm93c2VJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiBkb2VzIG5vdCBhbGxvdyBtdWx0aXBsZSBpdGVtcyBhbmQgZHJhZ2dpbmcgbW9yZSB0aGFuIG9uZSBpdGVtXG4gICAgICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiB0b3RhbEJyb3dzZUl0ZW1zID4gMSkge1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgICAgICBtYXhJdGVtcyA9IGFsbG93TXVsdGlwbGUgPyBtYXhJdGVtcyA6IDE7XG5cbiAgICAgICAgaWYgKCFhbGxvd011bHRpcGxlICYmIGFsbG93UmVwbGFjZSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgaXRlbSwgc28gdGhlcmUgaXMgcm9vbSB0byByZXBsYWNlIG9yIGFkZCBhbiBpdGVtXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBtb3JlIHJvb20/XG4gICAgICAgIHZhciBoYXNNYXhJdGVtcyA9IGlzSW50KG1heEl0ZW1zKTtcbiAgICAgICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBnZXREcmFnSW5kZXggPSBmdW5jdGlvbiBnZXREcmFnSW5kZXgobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpdGVtTGlzdCA9IGxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgcmV0dXJuIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCB7XG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5zY29wZUxlZnQgLSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgICAgIHRvcDpcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgKyBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyBsaXN0LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsZSBkcm9wIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICB2YXIgdG9nZ2xlRHJvcCA9IGZ1bmN0aW9uIHRvZ2dsZURyb3Aocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgICAgIHZhciBob3BwZXIgPSBjcmVhdGVIb3BwZXIoXG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHF1aWNrIHZhbGlkYXRpb24gb2YgZHJvcHBlZCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlRHJvcEZpbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBzaG91bGQgYmUgdmFsaWRhdGVkIGJ5IGFsbCBmaWx0ZXJzIGFzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wVmFsaWRhdGlvbiA9IHJvb3QucXVlcnkoJ0dFVF9EUk9QX1ZBTElEQVRJT04nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BWYWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdBTExPV19IT1BQRVJfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHJvb3QucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZXZlcnkoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgJiYgYmVmb3JlRHJvcEZpbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJJdGVtcyhpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudDogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fRUxFTUVOVCcpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcywgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgaXRlbSBjaGlsZHJlbiBlbGVtZW50cyBhbmQgc29ydCBiYXNlZCBvbiBsaXN0IHNvcnRcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgcXVldWVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXREcmFnSW5kZXgocm9vdC5yZWYubGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1NUQVJUX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWcgPSBkZWJvdW5jZShmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaG9wcGVyLm9uZHJhZ2VuZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgICAgICAgIHJvb3QucmVmLmRyaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkcmlwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGJyb3dzZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZUJyb3dzZSA9IGZ1bmN0aW9uIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcykge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICAgICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlcixcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuYnJvd3Nlcik7XG4gICAgICAgICAgICByb290LnJlZi5icm93c2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZVBhc3RlID0gZnVuY3Rpb24gdG9nZ2xlUGFzdGUocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BBU1RFJyk7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgICAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBjcmVhdGVQYXN0ZXIoKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3Rlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXMhXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm91dGUgYWN0aW9uc1xuICAgICAqL1xuICAgIHZhciByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19CUk9XU0UoX3JlZjUpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9BTExPV19EUk9QOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX0RST1AoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfQUxMT1dfUEFTVEU6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfUEFTVEUoX3JlZjcpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgICB9LFxuICAgICAgICBESURfU0VUX0RJU0FCTEVEOiBmdW5jdGlvbiBESURfU0VUX0RJU0FCTEVEKF9yZWY4KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmOC5wcm9wcztcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgICAgICB0b2dnbGVQYXN0ZShyb290KTtcbiAgICAgICAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZDsgPD0gdGhpcyBkb2VzIG5vdCB3b3JrIG9uIGlPUyAxMFxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciByb290ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ5LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCddLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlcyB0aGUgYXBwXG4gICAgdmFyIGNyZWF0ZUFwcCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgLy8gbGV0IGVsZW1lbnRcbiAgICAgICAgdmFyIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgICAgICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgICAgICAgIGNyZWF0ZUluaXRpYWxTdGF0ZShkZWZhdWx0T3B0aW9ucyksXG5cbiAgICAgICAgICAgIC8vIHF1ZXJpZXNcbiAgICAgICAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgICAgICAgIC8vIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgICAgICAgW2FjdGlvbnMsIGNyZWF0ZU9wdGlvbkFjdGlvbnMoZGVmYXVsdE9wdGlvbnMpXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zOiBpbml0aWFsT3B0aW9ucyB9KTtcblxuICAgICAgICAvLyBraWNrIHRocmVhZCBpZiB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgICAgICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSByZXR1cm47XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICAgICAgdmFyIHJlc2l6ZURvbmVUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgIHZhciBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplRG9uZVRpbWVyKTtcbiAgICAgICAgICAgIHJlc2l6ZURvbmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNpemluZ0hvcml6b250YWxseSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgLy8gcmVuZGVyIGluaXRpYWwgdmlld1xuICAgICAgICB2YXIgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUFJJVkFURSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgIHZhciByZWFkV3JpdGVBcGkgPSB7XG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVhZHMgZnJvbSBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVhZDogZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZXNpemluZyBob3Jpem9udGFsbHlcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1dpZHRoID0gY3VycmVudFdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ICYmIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUQVJUX1JFU0laRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaXNSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3LmVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyByZWFkIHZpZXcgZGF0YVxuICAgICAgICAgICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGlzIGhpZGRlbiB3ZSBuZWVkIHRvIGtub3cgc28gd2UgZXhpdCByZXN0IG1vZGUgd2hlbiByZXZlYWxlZFxuICAgICAgICAgICAgICAgIGlzSGlkZGVuID0gdmlldy5yZWN0LmVsZW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZXMgdG8gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3dyaXRlOiBmdW5jdGlvbiBfd3JpdGUodHMpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGFjdGlvbnMgZnJvbSBzdG9yZVxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25zID0gc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLnByb2Nlc3NBY3Rpb25RdWV1ZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhL15TRVRfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgaWRsaW5nIGFuZCBubyBhY3Rpb25zIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcgJiYgIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgICAgICByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2xlYW4gdXAgYWxsIGFyY2hpdmVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVsZWFzZWRJdGVtcyhzdG9yZS5xdWVyeSgnR0VUX0lURU1TJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHJvY2Vzc0Rpc3BhdGNoUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZXJyb3IpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQub3V0cHV0ID0gZGF0YS5maWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gZGF0YS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLml0ZW0gfHwgZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1hcCBhbGwgaXRlbXMgaW4gYSBwb3NzaWJsZSBpdGVtcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lml0ZW1zID0gZGF0YS5pdGVtcy5tYXAoY3JlYXRlSXRlbUFQSSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgICAgICAgICAgaWYgKC9wcm9ncmVzcy8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZGF0YS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRSb3V0ZXMgPSB7XG4gICAgICAgICAgICBESURfREVTVFJPWTogY3JlYXRlRXZlbnQoJ2Rlc3Ryb3knKSxcblxuICAgICAgICAgICAgRElEX0lOSVQ6IGNyZWF0ZUV2ZW50KCdpbml0JyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19NQVhfRklMRVM6IGNyZWF0ZUV2ZW50KCd3YXJuaW5nJyksXG5cbiAgICAgICAgICAgIERJRF9JTklUX0lURU06IGNyZWF0ZUV2ZW50KCdpbml0ZmlsZScpLFxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogY3JlYXRlRXZlbnQoJ2FkZGZpbGVzdGFydCcpLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpXSxcblxuICAgICAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBjcmVhdGVFdmVudCgncHJlcGFyZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlc3RhcnQnKSxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVwcm9ncmVzcycpLFxuICAgICAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlYWJvcnQnKSxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEw6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXMnKSxcbiAgICAgICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVyZXZlcnQnKSxcblxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9SRU1PVkVfSVRFTTogY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNUzogY3JlYXRlRXZlbnQoJ3VwZGF0ZWZpbGVzJyksXG5cbiAgICAgICAgICAgIERJRF9BQ1RJVkFURV9JVEVNOiBjcmVhdGVFdmVudCgnYWN0aXZhdGVmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9SRU9SREVSX0lURU1TOiBjcmVhdGVFdmVudCgncmVvcmRlcmZpbGVzJyksXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cG9zZUV2ZW50ID0gZnVuY3Rpb24gZXhwb3NlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBldmVudCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBwb25kOiBleHBvcnRzIH0sIGV2ZW50KTtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXRhaWwudHlwZTtcbiAgICAgICAgICAgIHZpZXcuZWxlbWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6JyArIGV2ZW50LnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgaW5mb1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBiZWhhdmlvdXJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zZWQ6IHRydWUsIC8vIHRyaWdnZXJzIGxpc3RlbmVycyBvdXRzaWRlIG9mIHNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IG9iamVjdCB0byBwYXJhbXMgdXNlZCBmb3IgYG9uKClgIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgYG9uaW5pdCgpYFxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBpZiBpcyBwb3NzaWJsZSBlcnJvciBldmVudCwgbWFrZSBpdCB0aGUgZmlyc3QgcGFyYW1cbiAgICAgICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChldmVudC5maWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwZW5kIG90aGVyIHByb3BzXG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbJ3R5cGUnLCAnZXJyb3InLCAnZmlsZSddO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXJlZC5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucHVzaChldmVudFtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgICAgICAgZXhwb3J0cy5maXJlLmFwcGx5KGV4cG9ydHMsIFtldmVudC50eXBlXS5jb25jYXQocGFyYW1zKSk7XG5cbiAgICAgICAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHN0b3JlLnF1ZXJ5KCdHRVRfT04nICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvdXRlQWN0aW9uc1RvRXZlbnRzID0gZnVuY3Rpb24gcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IFtyb3V0ZXNdKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRElEX0lOSVRfSVRFTScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBQVUJMSUMgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGUgPSBmdW5jdGlvbiBwcmVwYXJlRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJFUEFSRScsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZSA9IGZ1bmN0aW9uIGFkZEZpbGUoc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgYWRkRmlsZXMoW3sgc291cmNlOiBzb3VyY2UsIG9wdGlvbnM6IG9wdGlvbnMgfV0sIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNGaWxlUG9uZEZpbGUgPSBmdW5jdGlvbiBpc0ZpbGVQb25kRmlsZShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsZSAmJiBvYmouaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGUgPSBmdW5jdGlvbiByZW1vdmVGaWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiAhaXNGaWxlUG9uZEZpbGUocXVlcnkpICYmICFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBxdWVyeTogcXVlcnkgfSkpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KSA9PT0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZXMgPSBmdW5jdGlvbiBhZGRGaWxlcygpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgYSBzb3VyY2VzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIHNvdXJjZXMgYXMgYXJndW1lbnRzLCBsYXN0IG9uZSBtaWdodCBiZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEFyZ3VtZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgIShsYXN0QXJndW1lbnQgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCByZXN0IHRvIHNvdXJjZXNcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkFQSSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0ZpbGUgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGVzID0gZnVuY3Rpb24gcHJlcGFyZUZpbGVzKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgICAgICAgICAgX2tleTIrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBxdWVyaWVzLmxlbmd0aCA/IHF1ZXJpZXMgOiBnZXRGaWxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChwcmVwYXJlRmlsZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzRmlsZXMgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTMgPCBfbGVuMztcbiAgICAgICAgICAgICAgICBfa2V5MysrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBnZXRGaWxlcygpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLklETEUgJiYgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXJpZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGVzID0gZnVuY3Rpb24gcmVtb3ZlRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTQgPCBfbGVuNDtcbiAgICAgICAgICAgICAgICBfa2V5NCsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcmllc1txdWVyaWVzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyaWVzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGdldEZpbGVzKCk7XG5cbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgICAgICBmaWxlcy5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgICAgICAgIHZhciBtYXBwZWRRdWVyaWVzID0gcXVlcmllc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHF1ZXJ5KSA/IChmaWxlc1txdWVyeV0gPyBmaWxlc1txdWVyeV0uaWQgOiBudWxsKSA6IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXBwZWRRdWVyaWVzLm1hcChmdW5jdGlvbihxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUocSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgb24oKSxcbiAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICByZWFkV3JpdGVBcGksXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT3ZlcnJpZGUgb3B0aW9ucyBkZWZpbmVkIGluIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIG9mIHRoZSBmaWxlIChlaXRoZXIgYSBGaWxlLCBiYXNlNjQgZGF0YSB1cmkgb3IgdXJsKVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhZGRGaWxlOiBhZGRGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZXNcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlcyAtIHRoZSBzb3VyY2VzIG9mIHRoZSBmaWxlcyB0byBsb2FkXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZEZpbGVzOiBhZGRGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGZpbGUgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZTogZ2V0RmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpbGU6IHByb2Nlc3NGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlOiBwcmVwYXJlRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBmaWxlIGJ5IGl0cyBuYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVGaWxlOiByZW1vdmVGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbW92ZUZpbGU6IGZ1bmN0aW9uIG1vdmVGaWxlKHF1ZXJ5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHF1ZXJ5LCBpbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYWxsIGZpbGVzICh3cmFwcGVkIGluIHB1YmxpYyBhcGkpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZXM6IGdldEZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RhcnRzIHVwbG9hZGluZyBhbGwgZmlsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcm9jZXNzRmlsZXM6IHByb2Nlc3NGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbW92ZUZpbGVzOiByZW1vdmVGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0YXJ0cyBwcmVwYXJpbmcgb3V0cHV0IG9mIGFsbCBmaWxlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlczogcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU29ydCBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU09SVCcsIHsgY29tcGFyZTogY29tcGFyZSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQnJvd3NlIHRoZSBmaWxlIHN5c3RlbSBmb3IgYSBmaWxlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnJvd3NlOiBmdW5jdGlvbiBicm93c2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIHRyaWdnZXIgZGlyZWN0bHkgYXMgdXNlciBhY3Rpb24gbmVlZHMgdG8gYmUgdHJhY2VhYmxlIChpcyBub3QgdHJhY2VhYmxlIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERlc3Ryb3lzIHRoZSBhcHBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGRlc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuZmlyZSgnZGVzdHJveScsIHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGl0ZW1zIGFuZCBkZXBlbmRpbmcgb24gc3RhdGVzIGNhbGwgYWJvcnQgZm9yIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBQk9SVF9BTEwnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlIHZpc2libGl0eWNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9ERVNUUk9ZJyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBiZWZvcmUgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUkMShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbiBpbnNlcnRBZnRlciQxKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEFmdGVyKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFwcGVuZHMgdGhlIHBsdWdpbiB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hcHBlbmRDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXBsYWNlcyBhbiBlbGVtZW50IHdpdGggdGhlIGFwcFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcGxhY2VFbGVtZW50OiBmdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgYXBwIGJlZm9yZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXN0b3JlRWxlbWVudDogZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGVsZW1lbnQgdG8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEFmdGVyKG9yaWdpbmFsRWxlbWVudCwgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3VyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmlldy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHJvb3QgaXMgYXR0YWNoZWQgdG8gZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXNBdHRhY2hlZFRvOiBmdW5jdGlvbiBpc0F0dGFjaGVkVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50ID09PSBlbGVtZW50IHx8IG9yaWdpbmFsRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERvbmUhXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfSU5JVCcpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4cG9ydHMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXBwT2JqZWN0ID0gZnVuY3Rpb24gY3JlYXRlQXBwT2JqZWN0KCkge1xuICAgICAgICB2YXIgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldID0gdmFsdWVbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCBhcHAgb3B0aW9uc1xuICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgY3VzdG9tT3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfTtcblxuICAgIHZhciBsb3dlckNhc2VGaXJzdExldHRlciA9IGZ1bmN0aW9uIGxvd2VyQ2FzZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICB2YXIgYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQ2FtZWxzKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXmRhdGEtLywgJycpKTtcbiAgICB9O1xuXG4gICAgdmFyIG1hcE9iamVjdCA9IGZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIHByb3BlcnR5TWFwKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgICAgICBmb3Jpbihwcm9wZXJ0eU1hcCwgZnVuY3Rpb24oc2VsZWN0b3IsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGZvcmluKG9iamVjdCwgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclJlZ0V4cCA9IG5ldyBSZWdFeHAoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdHMgaWZcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2gsIHNraXBcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBtYXBwaW5nLCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgaXMgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IHJlbW92ZSwgd2UgZG9uZSFcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdmFsdWUgdG8gbmV3IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFttYXBwaW5nXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBncm91cFxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcHBpbmcpICYmICFvYmplY3RbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtncm91cF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdW2xvd2VyQ2FzZUZpcnN0TGV0dGVyKHByb3BlcnR5LnJlcGxhY2Uoc2VsZWN0b3JSZWdFeHAsICcnKSldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICAgICAgICAgIG1hcE9iamVjdChvYmplY3RbbWFwcGluZy5ncm91cF0sIG1hcHBpbmcubWFwcGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXR0cmlidXRlc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KG5vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU1hcHBpbmcgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvcmluKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChub2RlLmF0dHJpYnV0ZXNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyKG5vZGUsIGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgIG9ialthdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBhdHRyaWJ1dGUubmFtZSA/IHRydWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgIC8vIGRvIG1hcHBpbmcgb2Ygb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFwcEF0RWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcEF0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIG90aGVyIG5hbWVcbiAgICAgICAgICAgICdeY2xhc3MkJzogJ2NsYXNzTmFtZScsXG4gICAgICAgICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICAgICAgICdeY2FwdHVyZSQnOiAnY2FwdHVyZU1ldGhvZCcsXG4gICAgICAgICAgICAnXndlYmtpdGRpcmVjdG9yeSQnOiAnYWxsb3dEaXJlY3Rvcmllc09ubHknLFxuXG4gICAgICAgICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICAgICAgICdec2VydmVyJzoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnc2VydmVyJyxcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3JldmVydCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15mZXRjaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBpbiBvYmplY3RcbiAgICAgICAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICAgICAgICdeZmlsZXMkJzogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgICAgIGFwcGx5RmlsdGVycygnU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbmFsIG9wdGlvbnMgb2JqZWN0IGJ5IHNldHRpbmcgb3B0aW9ucyBvYmplY3QgYW5kIHRoZW4gb3ZlcnJpZGluZyBvcHRpb25zIHN1cHBsaWVkIG9uIGVsZW1lbnRcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgICAgICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdGSUVMRFNFVCcgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKSA6IGVsZW1lbnQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVNYXBwaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGF0dHJpYnV0ZU9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlZE9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVyZ2VkT3B0aW9uc1trZXldLCBhdHRyaWJ1dGVPcHRpb25zW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBhdHRyaWJ1dGVPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgICAgICAvLyB0aGVzZSB3aWxsIHRoZW4gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGluaXRpYWwgZmlsZXNcbiAgICAgICAgbWVyZ2VkT3B0aW9ucy5maWxlcyA9IChvcHRpb25zLmZpbGVzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPWZpbGVdKScpKS5tYXAoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYnVpbGQgcGx1Z2luXG4gICAgICAgIHZhciBhcHAgPSBjcmVhdGVBcHBPYmplY3QobWVyZ2VkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICAgICAgaWYgKGVsZW1lbnQuZmlsZXMpIHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5maWxlcykuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgYXBwLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGFwcC5yZXBsYWNlRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9O1xuXG4gICAgLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuICAgIHZhciBjcmVhdGVBcHAkMSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pXG4gICAgICAgICAgICA/IGNyZWF0ZUFwcEF0RWxlbWVudC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogY3JlYXRlQXBwT2JqZWN0LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIFBSSVZBVEVfTUVUSE9EUyA9IFsnZmlyZScsICdfcmVhZCcsICdfd3JpdGUnXTtcblxuICAgIHZhciBjcmVhdGVBcHBBUEkgPSBmdW5jdGlvbiBjcmVhdGVBcHBBUEkoYXBwKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcblxuICAgICAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBpbiBnaXZlbiBzdHJpbmcgd2l0aCByZXBsYWNlbWVudHNcbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gICAgICogQHBhcmFtIHJlcGxhY2VtZW50cyAtIHsgXCJiYXJcIjogMTAgfVxuICAgICAqL1xuICAgIHZhciByZXBsYWNlSW5TdHJpbmcgPSBmdW5jdGlvbiByZXBsYWNlSW5TdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oPzp7KFthLXpBLVpdKyl9KS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudHNbZ3JvdXBdO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgICAgICB2YXIgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmZXI6IGZ1bmN0aW9uIHRyYW5zZmVyKG1lc3NhZ2UsIGNiKSB7fSxcbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckxpc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gdGVybWluYXRlKCkge1xuICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmFtZUZpbGUgPSBmdW5jdGlvbiByZW5hbWVGaWxlKGZpbGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlbmFtZWRGaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIGZpbGUudHlwZSk7XG4gICAgICAgIHJlbmFtZWRGaWxlLmxhc3RNb2RpZmllZERhdGUgPSBmaWxlLmxhc3RNb2RpZmllZERhdGU7XG4gICAgICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gcmVuYW1lZEZpbGU7XG4gICAgfTtcblxuICAgIHZhciBjb3B5RmlsZSA9IGZ1bmN0aW9uIGNvcHlGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoZmlsZSwgZmlsZS5uYW1lKTtcbiAgICB9O1xuXG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkIHBsdWdpbnMgKGNhbid0IHJlZ2lzdGVyIHR3aWNlKVxuICAgIHZhciByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4gICAgLy8gcGFzcyB1dGlscyB0byBwbHVnaW5cbiAgICB2YXIgY3JlYXRlQXBwUGx1Z2luID0gZnVuY3Rpb24gY3JlYXRlQXBwUGx1Z2luKHBsdWdpbikge1xuICAgICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbWVtYmVyIHRoaXMgcGx1Z2luXG4gICAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgICAgICAvLyBzZXR1cCFcbiAgICAgICAgdmFyIHBsdWdpbk91dGxpbmUgPSBwbHVnaW4oe1xuICAgICAgICAgICAgYWRkRmlsdGVyOiBhZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgICAgIFR5cGU6IFR5cGUsXG4gICAgICAgICAgICAgICAgZm9yaW46IGZvcmluLFxuICAgICAgICAgICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZTogdG9OYXR1cmFsRmlsZVNpemUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nOiByZXBsYWNlSW5TdHJpbmcsXG4gICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lOiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZTogZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgICAgICAgICBnZXRGaWxlRnJvbUJsb2I6IGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkw6IGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgICAgICAgICBjcmVhdGVSb3V0ZTogY3JlYXRlUm91dGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlV29ya2VyOiBjcmVhdGVXb3JrZXIsXG4gICAgICAgICAgICAgICAgY3JlYXRlVmlldzogY3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtQVBJOiBjcmVhdGVJdGVtQVBJLFxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZTogbG9hZEltYWdlLFxuICAgICAgICAgICAgICAgIGNvcHlGaWxlOiBjb3B5RmlsZSxcbiAgICAgICAgICAgICAgICByZW5hbWVGaWxlOiByZW5hbWVGaWxlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUJsb2I6IGNyZWF0ZUJsb2IsXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbjogYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmc6IGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgIGZpbGVBY3Rpb25CdXR0b246IGZpbGVBY3Rpb25CdXR0b24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgcGx1Z2luIG9wdGlvbnMgdG8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGV4dGVuZERlZmF1bHRPcHRpb25zKHBsdWdpbk91dGxpbmUub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgc3VwcG9ydGVkKCkgbWV0aG9kXG4gICAgdmFyIGlzT3BlcmFNaW5pID0gZnVuY3Rpb24gaXNPcGVyYU1pbmkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93Lm9wZXJhbWluaSkgPT09ICdbb2JqZWN0IE9wZXJhTWluaV0nO1xuICAgIH07XG4gICAgdmFyIGhhc1Byb21pc2VzID0gZnVuY3Rpb24gaGFzUHJvbWlzZXMoKSB7XG4gICAgICAgIHJldHVybiAnUHJvbWlzZScgaW4gd2luZG93O1xuICAgIH07XG4gICAgdmFyIGhhc0Jsb2JTbGljZSA9IGZ1bmN0aW9uIGhhc0Jsb2JTbGljZSgpIHtcbiAgICAgICAgcmV0dXJuICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG4gICAgfTtcbiAgICB2YXIgaGFzQ3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gaGFzQ3JlYXRlT2JqZWN0VVJMKCkge1xuICAgICAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG4gICAgfTtcbiAgICB2YXIgaGFzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIGhhc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIHJldHVybiAndmlzaWJpbGl0eVN0YXRlJyBpbiBkb2N1bWVudDtcbiAgICB9O1xuICAgIHZhciBoYXNUaW1pbmcgPSBmdW5jdGlvbiBoYXNUaW1pbmcoKSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdztcbiAgICB9OyAvLyBpT1MgOC54XG4gICAgdmFyIGhhc0NTU1N1cHBvcnRzID0gZnVuY3Rpb24gaGFzQ1NTU3VwcG9ydHMoKSB7XG4gICAgICAgIHJldHVybiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTtcbiAgICB9OyAvLyB1c2UgdG8gZGV0ZWN0IFNhZmFyaSA5K1xuICAgIHZhciBpc0lFMTEgPSBmdW5jdGlvbiBpc0lFMTEoKSB7XG4gICAgICAgIHJldHVybiAvTVNJRXxUcmlkZW50Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICAgIHZhciBpc1N1cHBvcnRlZCA9XG4gICAgICAgICAgICAvLyBIYXMgdG8gYmUgYSBicm93c2VyXG4gICAgICAgICAgICBpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAgICAgLy8gQ2FuJ3QgcnVuIG9uIE9wZXJhIE1pbmkgZHVlIHRvIGxhY2sgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgICAgIWlzT3BlcmFNaW5pKCkgJiZcbiAgICAgICAgICAgIC8vIFJlcXVpcmUgdGhlc2UgQVBJcyB0byBmZWF0dXJlIGRldGVjdCBhIG1vZGVybiBicm93c2VyXG4gICAgICAgICAgICBoYXNWaXNpYmlsaXR5KCkgJiZcbiAgICAgICAgICAgIGhhc1Byb21pc2VzKCkgJiZcbiAgICAgICAgICAgIGhhc0Jsb2JTbGljZSgpICYmXG4gICAgICAgICAgICBoYXNDcmVhdGVPYmplY3RVUkwoKSAmJlxuICAgICAgICAgICAgaGFzVGltaW5nKCkgJiZcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCBDU1NTdXBwb3J0cyBidXQgaXMgYSBnb29kIHdheSB0byBkZXRlY3QgU2FmYXJpIDkrICh3ZSBkbyB3YW50IHRvIHN1cHBvcnQgSUUxMSB0aG91Z2gpXG4gICAgICAgICAgICAoaGFzQ1NTU3VwcG9ydHMoKSB8fCBpc0lFMTEoKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAgICAgKi9cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICAgICAgYXBwczogW10sXG4gICAgfTtcblxuICAgIC8vIHBsdWdpbiBuYW1lXG4gICAgdmFyIG5hbWUgPSAnZmlsZXBvbmQnO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIFBsdWdpbiBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7fTtcbiAgICBleHBvcnRzLlN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZVN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZU9yaWdpbiA9IHt9O1xuICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGZuO1xuICAgIGV4cG9ydHMuZGVzdHJveSA9IGZuO1xuICAgIGV4cG9ydHMucGFyc2UgPSBmbjtcbiAgICBleHBvcnRzLmZpbmQgPSBmbjtcbiAgICBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luID0gZm47XG4gICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZm47XG4gICAgZXhwb3J0cy5zZXRPcHRpb25zID0gZm47XG5cbiAgICAvLyBpZiBub3Qgc3VwcG9ydGVkLCBubyBBUElcbiAgICBpZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gc3RhcnQgcGFpbnRlciBhbmQgZmlyZSBsb2FkIGV2ZW50XG4gICAgICAgIGNyZWF0ZVBhaW50ZXIoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHAuX3JlYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbih0cykge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5fd3JpdGUodHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGZpcmUgbG9hZGVkIGV2ZW50IHNvIHdlIGtub3cgd2hlbiBGaWxlUG9uZCBpcyBhdmFpbGFibGVcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6bG9hZGVkJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiBleHBvcnRzLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGV4cG9ydHMuZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiBleHBvcnRzLnBhcnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluZDogZXhwb3J0cy5maW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBleHBvcnRzLnNldE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHVwIGV2ZW50XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgICAgIHZhciB1cGRhdGVPcHRpb25UeXBlcyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvblR5cGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXNba2V5XSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwb3J0cy5TdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0dXMpO1xuICAgICAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSBPYmplY3QuYXNzaWduKHt9LCBGaWxlT3JpZ2luKTtcbiAgICAgICAgZXhwb3J0cy5GaWxlU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgSXRlbVN0YXR1cyk7XG5cbiAgICAgICAgZXhwb3J0cy5PcHRpb25UeXBlcyA9IHt9O1xuICAgICAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtZXRob2QsIGNyZWF0ZXMgYXBwcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwJDEuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXBwLm9uKCdkZXN0cm95JywgZXhwb3J0cy5kZXN0cm95KTtcbiAgICAgICAgICAgIHN0YXRlLmFwcHMucHVzaChhcHApO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlc3Ryb3lzIGFwcHMgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShob29rKSB7XG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgdGhlIGFwcCB3YXMgZGVzdHJveWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBzdGF0ZS5hcHBzLmZpbmRJbmRleChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGFwcHNcbiAgICAgICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSlbMF07XG5cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhcnNlcyB0aGUgZ2l2ZW4gY29udGV4dCBmb3IgcGx1Z2lucyAoZG9lcyBub3QgaW5jbHVkZSB0aGUgY29udGV4dCBlbGVtZW50IGl0c2VsZilcbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgcG9zc2libGUgaG9va3NcbiAgICAgICAgICAgIHZhciBtYXRjaGVkSG9va3MgPSBBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBuYW1lKSk7XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSBhY3RpdmUgaG9va3NcbiAgICAgICAgICAgIHZhciBuZXdIb29rcyA9IG1hdGNoZWRIb29rcy5maWx0ZXIoZnVuY3Rpb24obmV3SG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhuZXdIb29rKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIGZvciBlYWNoIGhvb2tcbiAgICAgICAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoZnVuY3Rpb24oaG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYW4gYXBwIGJhc2VkIG9uIHRoZSBnaXZlbiBlbGVtZW50IGhvb2tcbiAgICAgICAgZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gZmluZChob29rKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgICAgIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zJDEoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWVbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMkMShvcHRzKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0cykpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcGx1Z2luc1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLnNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgb3B0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/livewire-sortable/dist/livewire-sortable.js":
/*!******************************************************************!*\
  !*** ./node_modules/livewire-sortable/dist/livewire-sortable.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e){ true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}((function(){\"use strict\";var e,t=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e,t){var r;window,r=function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=44)}([function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(19);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(22),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(26);Object.defineProperty(t,\"closest\",{enumerable:!0,get:function(){return i(n).default}});var o=r(24);function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"requestNextAnimationFrame\",{enumerable:!0,get:function(){return i(o).default}})},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(42),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(35),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(1);Object.defineProperty(t,\"Sensor\",{enumerable:!0,get:function(){return c(n).default}});var o=r(21);Object.defineProperty(t,\"MouseSensor\",{enumerable:!0,get:function(){return c(o).default}});var i=r(18);Object.defineProperty(t,\"TouchSensor\",{enumerable:!0,get:function(){return c(i).default}});var s=r(16);Object.defineProperty(t,\"DragSensor\",{enumerable:!0,get:function(){return c(s).default}});var a=r(14);Object.defineProperty(t,\"ForceTouchSensor\",{enumerable:!0,get:function(){return c(a).default}});var l=r(0);function c(e){return e&&e.__esModule?e:{default:e}}Object.keys(l).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(37);Object.defineProperty(t,\"Announcement\",{enumerable:!0,get:function(){return a(n).default}}),Object.defineProperty(t,\"defaultAnnouncementOptions\",{enumerable:!0,get:function(){return n.defaultOptions}});var o=r(34);Object.defineProperty(t,\"Focusable\",{enumerable:!0,get:function(){return a(o).default}});var i=r(32);Object.defineProperty(t,\"Mirror\",{enumerable:!0,get:function(){return a(i).default}}),Object.defineProperty(t,\"defaultMirrorOptions\",{enumerable:!0,get:function(){return i.defaultOptions}});var s=r(28);function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"Scrollable\",{enumerable:!0,get:function(){return a(s).default}}),Object.defineProperty(t,\"defaultScrollableOptions\",{enumerable:!0,get:function(){return s.defaultOptions}})},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(38);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(39);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(43);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=class{constructor(){this.callbacks={}}on(e,...t){return this.callbacks[e]||(this.callbacks[e]=[]),this.callbacks[e].push(...t),this}off(e,t){if(!this.callbacks[e])return null;const r=this.callbacks[e].slice(0);for(let n=0;n<r.length;n++)t===r[n]&&this.callbacks[e].splice(n,1);return this}trigger(e){if(!this.callbacks[e.type])return null;const t=[...this.callbacks[e.type]],r=[];for(let n=t.length-1;n>=0;n--){const o=t[n];try{o(e)}catch(e){r.push(e)}}return r.length&&console.error(`Draggable caught errors while triggering '${e.type}'`,r),this}}},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(10),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=void 0;var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(2),s=r(6),a=r(11),l=(n=a)&&n.__esModule?n:{default:n},c=r(5),u=r(7),d=r(8);const g=Symbol(\"onDragStart\"),h=Symbol(\"onDragMove\"),f=Symbol(\"onDragStop\"),v=Symbol(\"onDragPressure\"),m={\"drag:start\":e=>`Picked up ${e.source.textContent.trim()||e.source.id||\"draggable element\"}`,\"drag:stop\":e=>`Released ${e.source.textContent.trim()||e.source.id||\"draggable element\"}`},p={\"container:dragging\":\"draggable-container--is-dragging\",\"source:dragging\":\"draggable-source--is-dragging\",\"source:placed\":\"draggable-source--placed\",\"container:placed\":\"draggable-container--placed\",\"body:dragging\":\"draggable--is-dragging\",\"draggable:over\":\"draggable--over\",\"container:over\":\"draggable-container--over\",\"source:original\":\"draggable--original\",mirror:\"draggable-mirror\"},b=t.defaultOptions={draggable:\".draggable-source\",handle:null,delay:100,placedTimeout:800,plugins:[],sensors:[]};class E{constructor(e=[document.body],t={}){if(e instanceof NodeList||e instanceof Array)this.containers=[...e];else{if(!(e instanceof HTMLElement))throw new Error(\"Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`\");this.containers=[e]}this.options=o({},b,t,{classes:o({},p,t.classes||{}),announcements:o({},m,t.announcements||{})}),this.emitter=new l.default,this.dragging=!1,this.plugins=[],this.sensors=[],this[g]=this[g].bind(this),this[h]=this[h].bind(this),this[f]=this[f].bind(this),this[v]=this[v].bind(this),document.addEventListener(\"drag:start\",this[g],!0),document.addEventListener(\"drag:move\",this[h],!0),document.addEventListener(\"drag:stop\",this[f],!0),document.addEventListener(\"drag:pressure\",this[v],!0);const r=Object.values(E.Plugins).map(e=>e),n=[c.MouseSensor,c.TouchSensor];this.addPlugin(...r,...this.options.plugins),this.addSensor(...n,...this.options.sensors);const i=new u.DraggableInitializedEvent({draggable:this});this.on(\"mirror:created\",({mirror:e})=>this.mirror=e),this.on(\"mirror:destroy\",()=>this.mirror=null),this.trigger(i)}destroy(){document.removeEventListener(\"drag:start\",this[g],!0),document.removeEventListener(\"drag:move\",this[h],!0),document.removeEventListener(\"drag:stop\",this[f],!0),document.removeEventListener(\"drag:pressure\",this[v],!0);const e=new u.DraggableDestroyEvent({draggable:this});this.trigger(e),this.removePlugin(...this.plugins.map(e=>e.constructor)),this.removeSensor(...this.sensors.map(e=>e.constructor))}addPlugin(...e){const t=e.map(e=>new e(this));return t.forEach(e=>e.attach()),this.plugins=[...this.plugins,...t],this}removePlugin(...e){return this.plugins.filter(t=>e.includes(t.constructor)).forEach(e=>e.detach()),this.plugins=this.plugins.filter(t=>!e.includes(t.constructor)),this}addSensor(...e){const t=e.map(e=>new e(this.containers,this.options));return t.forEach(e=>e.attach()),this.sensors=[...this.sensors,...t],this}removeSensor(...e){return this.sensors.filter(t=>e.includes(t.constructor)).forEach(e=>e.detach()),this.sensors=this.sensors.filter(t=>!e.includes(t.constructor)),this}addContainer(...e){return this.containers=[...this.containers,...e],this.sensors.forEach(t=>t.addContainer(...e)),this}removeContainer(...e){return this.containers=this.containers.filter(t=>!e.includes(t)),this.sensors.forEach(t=>t.removeContainer(...e)),this}on(e,...t){return this.emitter.on(e,...t),this}off(e,t){return this.emitter.off(e,t),this}trigger(e){return this.emitter.trigger(e),this}getClassNameFor(e){return this.options.classes[e]}isDragging(){return Boolean(this.dragging)}getDraggableElements(){return this.containers.reduce((e,t)=>[...e,...this.getDraggableElementsForContainer(t)],[])}getDraggableElementsForContainer(e){return[...e.querySelectorAll(this.options.draggable)].filter(e=>e!==this.originalSource&&e!==this.mirror)}[g](e){const t=y(e),{target:r,container:n}=t;if(!this.containers.includes(n))return;if(this.options.handle&&r&&!(0,i.closest)(r,this.options.handle))return void t.cancel();if(this.originalSource=(0,i.closest)(r,this.options.draggable),this.sourceContainer=n,!this.originalSource)return void t.cancel();this.lastPlacedSource&&this.lastPlacedContainer&&(clearTimeout(this.placedTimeoutID),this.lastPlacedSource.classList.remove(this.getClassNameFor(\"source:placed\")),this.lastPlacedContainer.classList.remove(this.getClassNameFor(\"container:placed\"))),this.source=this.originalSource.cloneNode(!0),this.originalSource.parentNode.insertBefore(this.source,this.originalSource),this.originalSource.style.display=\"none\";const s=new d.DragStartEvent({source:this.source,originalSource:this.originalSource,sourceContainer:n,sensorEvent:t});if(this.trigger(s),this.dragging=!s.canceled(),s.canceled())return this.source.parentNode.removeChild(this.source),void(this.originalSource.style.display=null);this.originalSource.classList.add(this.getClassNameFor(\"source:original\")),this.source.classList.add(this.getClassNameFor(\"source:dragging\")),this.sourceContainer.classList.add(this.getClassNameFor(\"container:dragging\")),document.body.classList.add(this.getClassNameFor(\"body:dragging\")),S(document.body,\"none\"),requestAnimationFrame(()=>{const t=y(e).clone({target:this.source});this[h](o({},e,{detail:t}))})}[h](e){if(!this.dragging)return;const t=y(e),{container:r}=t;let n=t.target;const o=new d.DragMoveEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t});this.trigger(o),o.canceled()&&t.cancel(),n=(0,i.closest)(n,this.options.draggable);const s=(0,i.closest)(t.target,this.containers),a=t.overContainer||s,l=this.currentOverContainer&&a!==this.currentOverContainer,c=this.currentOver&&n!==this.currentOver,u=a&&this.currentOverContainer!==a,g=s&&n&&this.currentOver!==n;if(c){const e=new d.DragOutEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,over:this.currentOver});this.currentOver.classList.remove(this.getClassNameFor(\"draggable:over\")),this.currentOver=null,this.trigger(e)}if(l){const e=new d.DragOutContainerEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:this.currentOverContainer});this.currentOverContainer.classList.remove(this.getClassNameFor(\"container:over\")),this.currentOverContainer=null,this.trigger(e)}if(u){a.classList.add(this.getClassNameFor(\"container:over\"));const e=new d.DragOverContainerEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:a});this.currentOverContainer=a,this.trigger(e)}if(g){n.classList.add(this.getClassNameFor(\"draggable:over\"));const e=new d.DragOverEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:a,over:n});this.currentOver=n,this.trigger(e)}}[f](e){if(!this.dragging)return;this.dragging=!1;const t=new d.DragStopEvent({source:this.source,originalSource:this.originalSource,sensorEvent:e.sensorEvent,sourceContainer:this.sourceContainer});this.trigger(t),this.source.parentNode.insertBefore(this.originalSource,this.source),this.source.parentNode.removeChild(this.source),this.originalSource.style.display=\"\",this.source.classList.remove(this.getClassNameFor(\"source:dragging\")),this.originalSource.classList.remove(this.getClassNameFor(\"source:original\")),this.originalSource.classList.add(this.getClassNameFor(\"source:placed\")),this.sourceContainer.classList.add(this.getClassNameFor(\"container:placed\")),this.sourceContainer.classList.remove(this.getClassNameFor(\"container:dragging\")),document.body.classList.remove(this.getClassNameFor(\"body:dragging\")),S(document.body,\"\"),this.currentOver&&this.currentOver.classList.remove(this.getClassNameFor(\"draggable:over\")),this.currentOverContainer&&this.currentOverContainer.classList.remove(this.getClassNameFor(\"container:over\")),this.lastPlacedSource=this.originalSource,this.lastPlacedContainer=this.sourceContainer,this.placedTimeoutID=setTimeout(()=>{this.lastPlacedSource&&this.lastPlacedSource.classList.remove(this.getClassNameFor(\"source:placed\")),this.lastPlacedContainer&&this.lastPlacedContainer.classList.remove(this.getClassNameFor(\"container:placed\")),this.lastPlacedSource=null,this.lastPlacedContainer=null},this.options.placedTimeout),this.source=null,this.originalSource=null,this.currentOverContainer=null,this.currentOver=null,this.sourceContainer=null}[v](e){if(!this.dragging)return;const t=y(e),r=this.source||(0,i.closest)(t.originalEvent.target,this.options.draggable),n=new d.DragPressureEvent({sensorEvent:t,source:r,pressure:t.pressure});this.trigger(n)}}function y(e){return e.detail}function S(e,t){e.style.webkitUserSelect=t,e.style.mozUserSelect=t,e.style.msUserSelect=t,e.style.oUserSelect=t,e.style.userSelect=t}t.default=E,E.Plugins={Announcement:s.Announcement,Focusable:s.Focusable,Mirror:s.Mirror,Scrollable:s.Scrollable}},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(1),i=(n=o)&&n.__esModule?n:{default:n},s=r(0);const a=Symbol(\"onMouseForceWillBegin\"),l=Symbol(\"onMouseForceDown\"),c=Symbol(\"onMouseDown\"),u=Symbol(\"onMouseForceChange\"),d=Symbol(\"onMouseMove\"),g=Symbol(\"onMouseUp\"),h=Symbol(\"onMouseForceGlobalChange\");class f extends i.default{constructor(e=[],t={}){super(e,t),this.mightDrag=!1,this[a]=this[a].bind(this),this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this),this[g]=this[g].bind(this)}attach(){for(const e of this.containers)e.addEventListener(\"webkitmouseforcewillbegin\",this[a],!1),e.addEventListener(\"webkitmouseforcedown\",this[l],!1),e.addEventListener(\"mousedown\",this[c],!0),e.addEventListener(\"webkitmouseforcechanged\",this[u],!1);document.addEventListener(\"mousemove\",this[d]),document.addEventListener(\"mouseup\",this[g])}detach(){for(const e of this.containers)e.removeEventListener(\"webkitmouseforcewillbegin\",this[a],!1),e.removeEventListener(\"webkitmouseforcedown\",this[l],!1),e.removeEventListener(\"mousedown\",this[c],!0),e.removeEventListener(\"webkitmouseforcechanged\",this[u],!1);document.removeEventListener(\"mousemove\",this[d]),document.removeEventListener(\"mouseup\",this[g])}[a](e){e.preventDefault(),this.mightDrag=!0}[l](e){if(this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY),r=e.currentTarget,n=new s.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n),this.currentContainer=r,this.dragging=!n.canceled(),this.mightDrag=!1}[g](e){if(!this.dragging)return;const t=new s.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:null,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,t),this.currentContainer=null,this.dragging=!1,this.mightDrag=!1}[c](e){this.mightDrag&&(e.stopPropagation(),e.stopImmediatePropagation(),e.preventDefault())}[d](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY),r=new s.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}[u](e){if(this.dragging)return;const t=e.target,r=e.currentTarget,n=new s.DragPressureSensorEvent({pressure:e.webkitForce,clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n)}[h](e){if(!this.dragging)return;const t=e.target,r=new s.DragPressureSensorEvent({pressure:e.webkitForce,clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}}t.default=f},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(13),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(2),i=r(1),s=(n=i)&&n.__esModule?n:{default:n},a=r(0);const l=Symbol(\"onMouseDown\"),c=Symbol(\"onMouseUp\"),u=Symbol(\"onDragStart\"),d=Symbol(\"onDragOver\"),g=Symbol(\"onDragEnd\"),h=Symbol(\"onDrop\"),f=Symbol(\"reset\");class v extends s.default{constructor(e=[],t={}){super(e,t),this.mouseDownTimeout=null,this.draggableElement=null,this.nativeDraggableElement=null,this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this),this[g]=this[g].bind(this),this[h]=this[h].bind(this)}attach(){document.addEventListener(\"mousedown\",this[l],!0)}detach(){document.removeEventListener(\"mousedown\",this[l],!0)}[u](e){e.dataTransfer.setData(\"text\",\"\"),e.dataTransfer.effectAllowed=this.options.type;const t=document.elementFromPoint(e.clientX,e.clientY);if(this.currentContainer=(0,o.closest)(e.target,this.containers),!this.currentContainer)return;const r=new a.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});setTimeout(()=>{this.trigger(this.currentContainer,r),r.canceled()?this.dragging=!1:this.dragging=!0},0)}[d](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY),r=this.currentContainer,n=new a.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n),n.canceled()||(e.preventDefault(),e.dataTransfer.dropEffect=this.options.type)}[g](e){if(!this.dragging)return;document.removeEventListener(\"mouseup\",this[c],!0);const t=document.elementFromPoint(e.clientX,e.clientY),r=this.currentContainer,n=new a.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n),this.dragging=!1,this[f]()}[h](e){e.preventDefault()}[l](e){if(e.target&&(e.target.form||e.target.contenteditable))return;const t=(0,o.closest)(e.target,e=>e.draggable);t&&(t.draggable=!1,this.nativeDraggableElement=t),document.addEventListener(\"mouseup\",this[c],!0),document.addEventListener(\"dragstart\",this[u],!1),document.addEventListener(\"dragover\",this[d],!1),document.addEventListener(\"dragend\",this[g],!1),document.addEventListener(\"drop\",this[h],!1);const r=(0,o.closest)(e.target,this.options.draggable);r&&(this.mouseDownTimeout=setTimeout(()=>{r.draggable=!0,this.draggableElement=r},this.options.delay))}[c](){this[f]()}[f](){clearTimeout(this.mouseDownTimeout),document.removeEventListener(\"mouseup\",this[c],!0),document.removeEventListener(\"dragstart\",this[u],!1),document.removeEventListener(\"dragover\",this[d],!1),document.removeEventListener(\"dragend\",this[g],!1),document.removeEventListener(\"drop\",this[h],!1),this.nativeDraggableElement&&(this.nativeDraggableElement.draggable=!0,this.nativeDraggableElement=null),this.draggableElement&&(this.draggableElement.draggable=!1,this.draggableElement=null)}}t.default=v},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(15),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(2),i=r(1),s=(n=i)&&n.__esModule?n:{default:n},a=r(0);const l=Symbol(\"onTouchStart\"),c=Symbol(\"onTouchHold\"),u=Symbol(\"onTouchEnd\"),d=Symbol(\"onTouchMove\");let g=!1;window.addEventListener(\"touchmove\",e=>{g&&e.preventDefault()},{passive:!1});class h extends s.default{constructor(e=[],t={}){super(e,t),this.currentScrollableParent=null,this.tapTimeout=null,this.touchMoved=!1,this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this)}attach(){document.addEventListener(\"touchstart\",this[l])}detach(){document.removeEventListener(\"touchstart\",this[l])}[l](e){const t=(0,o.closest)(e.target,this.containers);t&&(document.addEventListener(\"touchmove\",this[d]),document.addEventListener(\"touchend\",this[u]),document.addEventListener(\"touchcancel\",this[u]),t.addEventListener(\"contextmenu\",f),this.currentContainer=t,this.tapTimeout=setTimeout(this[c](e,t),this.options.delay))}[c](e,t){return()=>{if(this.touchMoved)return;const r=e.touches[0]||e.changedTouches[0],n=e.target,o=new a.DragStartSensorEvent({clientX:r.pageX,clientY:r.pageY,target:n,container:t,originalEvent:e});this.trigger(t,o),this.dragging=!o.canceled(),g=this.dragging}}[d](e){if(this.touchMoved=!0,!this.dragging)return;const t=e.touches[0]||e.changedTouches[0],r=document.elementFromPoint(t.pageX-window.scrollX,t.pageY-window.scrollY),n=new a.DragMoveSensorEvent({clientX:t.pageX,clientY:t.pageY,target:r,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,n)}[u](e){if(this.touchMoved=!1,g=!1,document.removeEventListener(\"touchend\",this[u]),document.removeEventListener(\"touchcancel\",this[u]),document.removeEventListener(\"touchmove\",this[d]),this.currentContainer&&this.currentContainer.removeEventListener(\"contextmenu\",f),clearTimeout(this.tapTimeout),!this.dragging)return;const t=e.touches[0]||e.changedTouches[0],r=document.elementFromPoint(t.pageX-window.scrollX,t.pageY-window.scrollY);e.preventDefault();const n=new a.DragStopSensorEvent({clientX:t.pageX,clientY:t.pageY,target:r,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,n),this.currentContainer=null,this.dragging=!1}}function f(e){e.preventDefault(),e.stopPropagation()}t.default=h},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(17),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.DragPressureSensorEvent=t.DragStopSensorEvent=t.DragMoveSensorEvent=t.DragStartSensorEvent=t.SensorEvent=void 0;var n,o=r(3),i=(n=o)&&n.__esModule?n:{default:n};class s extends i.default{get originalEvent(){return this.data.originalEvent}get clientX(){return this.data.clientX}get clientY(){return this.data.clientY}get target(){return this.data.target}get container(){return this.data.container}get pressure(){return this.data.pressure}}t.SensorEvent=s;class a extends s{}t.DragStartSensorEvent=a,a.type=\"drag:start\";class l extends s{}t.DragMoveSensorEvent=l,l.type=\"drag:move\";class c extends s{}t.DragStopSensorEvent=c,c.type=\"drag:stop\";class u extends s{}t.DragPressureSensorEvent=u,u.type=\"drag:pressure\"},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(2),i=r(1),s=(n=i)&&n.__esModule?n:{default:n},a=r(0);const l=Symbol(\"onContextMenuWhileDragging\"),c=Symbol(\"onMouseDown\"),u=Symbol(\"onMouseMove\"),d=Symbol(\"onMouseUp\");class g extends s.default{constructor(e=[],t={}){super(e,t),this.mouseDown=!1,this.mouseDownTimeout=null,this.openedContextMenu=!1,this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this)}attach(){document.addEventListener(\"mousedown\",this[c],!0)}detach(){document.removeEventListener(\"mousedown\",this[c],!0)}[c](e){if(0!==e.button||e.ctrlKey||e.metaKey)return;document.addEventListener(\"mouseup\",this[d]);const t=document.elementFromPoint(e.clientX,e.clientY),r=(0,o.closest)(t,this.containers);r&&(document.addEventListener(\"dragstart\",h),this.mouseDown=!0,clearTimeout(this.mouseDownTimeout),this.mouseDownTimeout=setTimeout(()=>{if(!this.mouseDown)return;const n=new a.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n),this.currentContainer=r,this.dragging=!n.canceled(),this.dragging&&(document.addEventListener(\"contextmenu\",this[l]),document.addEventListener(\"mousemove\",this[u]))},this.options.delay))}[u](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY),r=new a.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}[d](e){if(this.mouseDown=Boolean(this.openedContextMenu),this.openedContextMenu)return void(this.openedContextMenu=!1);if(document.removeEventListener(\"mouseup\",this[d]),document.removeEventListener(\"dragstart\",h),!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY),r=new a.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r),document.removeEventListener(\"contextmenu\",this[l]),document.removeEventListener(\"mousemove\",this[u]),this.currentContainer=null,this.dragging=!1}[l](e){e.preventDefault(),this.openedContextMenu=!0}}function h(e){e.preventDefault()}t.default=g},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(20),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};t.default=class{constructor(e=[],t={}){this.containers=[...e],this.options=n({},t),this.dragging=!1,this.currentContainer=null}attach(){return this}detach(){return this}addContainer(...e){this.containers=[...this.containers,...e]}removeContainer(...e){this.containers=this.containers.filter(t=>!e.includes(t))}trigger(e,t){const r=document.createEvent(\"Event\");return r.detail=t,r.initEvent(t.type,!0,!0),e.dispatchEvent(r),this.lastEvent=t,t}}},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=function(e){return requestAnimationFrame(()=>{requestAnimationFrame(e)})}},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(23),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=function(e,t){if(!e)return null;const r=t,o=t,i=t,s=t,a=Boolean(\"string\"==typeof t),l=Boolean(\"function\"==typeof t),c=Boolean(t instanceof NodeList||t instanceof Array),u=Boolean(t instanceof HTMLElement);let d=e;do{if(d=d.correspondingUseElement||d.correspondingElement||d,(g=d)?a?n.call(g,r):c?[...i].includes(g):u?s===g:l&&o(g):g)return d;d=d.parentNode}while(d&&d!==document.body&&d!==document);var g;return null};const n=Element.prototype.matches||Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(25),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=t.scroll=t.onDragStop=t.onDragMove=t.onDragStart=void 0;var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(4),s=(n=i)&&n.__esModule?n:{default:n},a=r(2);const l=t.onDragStart=Symbol(\"onDragStart\"),c=t.onDragMove=Symbol(\"onDragMove\"),u=t.onDragStop=Symbol(\"onDragStop\"),d=t.scroll=Symbol(\"scroll\"),g=t.defaultOptions={speed:6,sensitivity:50,scrollableElements:[]};class h extends s.default{constructor(e){super(e),this.options=o({},g,this.getOptions()),this.currentMousePosition=null,this.scrollAnimationFrame=null,this.scrollableElement=null,this.findScrollableElementFrame=null,this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this)}attach(){this.draggable.on(\"drag:start\",this[l]).on(\"drag:move\",this[c]).on(\"drag:stop\",this[u])}detach(){this.draggable.off(\"drag:start\",this[l]).off(\"drag:move\",this[c]).off(\"drag:stop\",this[u])}getOptions(){return this.draggable.options.scrollable||{}}getScrollableElement(e){return this.hasDefinedScrollableElements()?(0,a.closest)(e,this.options.scrollableElements)||document.documentElement:function(e){if(!e)return f();const t=getComputedStyle(e).getPropertyValue(\"position\"),r=\"absolute\"===t,n=(0,a.closest)(e,e=>(!r||!function(e){return\"static\"===getComputedStyle(e).getPropertyValue(\"position\")}(e))&&function(e){const t=getComputedStyle(e,null),r=t.getPropertyValue(\"overflow\")+t.getPropertyValue(\"overflow-y\")+t.getPropertyValue(\"overflow-x\");return/(auto|scroll)/.test(r)}(e));return\"fixed\"!==t&&n?n:f()}(e)}hasDefinedScrollableElements(){return Boolean(0!==this.options.scrollableElements.length)}[l](e){this.findScrollableElementFrame=requestAnimationFrame(()=>{this.scrollableElement=this.getScrollableElement(e.source)})}[c](e){if(this.findScrollableElementFrame=requestAnimationFrame(()=>{this.scrollableElement=this.getScrollableElement(e.sensorEvent.target)}),!this.scrollableElement)return;const t=e.sensorEvent,r={x:0,y:0};\"ontouchstart\"in window&&(r.y=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,r.x=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0),this.currentMousePosition={clientX:t.clientX-r.x,clientY:t.clientY-r.y},this.scrollAnimationFrame=requestAnimationFrame(this[d])}[u](){cancelAnimationFrame(this.scrollAnimationFrame),cancelAnimationFrame(this.findScrollableElementFrame),this.scrollableElement=null,this.scrollAnimationFrame=null,this.findScrollableElementFrame=null,this.currentMousePosition=null}[d](){if(!this.scrollableElement||!this.currentMousePosition)return;cancelAnimationFrame(this.scrollAnimationFrame);const{speed:e,sensitivity:t}=this.options,r=this.scrollableElement.getBoundingClientRect(),n=r.bottom>window.innerHeight,o=r.top<0||n,i=f(),s=this.scrollableElement,a=this.currentMousePosition.clientX,l=this.currentMousePosition.clientY;if(s===document.body||s===document.documentElement||o){const{innerHeight:r,innerWidth:n}=window;l<t?i.scrollTop-=e:r-l<t&&(i.scrollTop+=e),a<t?i.scrollLeft-=e:n-a<t&&(i.scrollLeft+=e)}else{const{offsetHeight:n,offsetWidth:o}=s;r.top+n-l<t?s.scrollTop+=e:l-r.top<t&&(s.scrollTop-=e),r.left+o-a<t?s.scrollLeft+=e:a-r.left<t&&(s.scrollLeft-=e)}this.scrollAnimationFrame=requestAnimationFrame(this[d])}}function f(){return document.scrollingElement||document.documentElement}t.default=h},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=void 0;var n,o=r(27),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default,t.defaultOptions=o.defaultOptions},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.MirrorDestroyEvent=t.MirrorMoveEvent=t.MirrorAttachedEvent=t.MirrorCreatedEvent=t.MirrorCreateEvent=t.MirrorEvent=void 0;var n,o=r(3),i=(n=o)&&n.__esModule?n:{default:n};class s extends i.default{get source(){return this.data.source}get originalSource(){return this.data.originalSource}get sourceContainer(){return this.data.sourceContainer}get sensorEvent(){return this.data.sensorEvent}get dragEvent(){return this.data.dragEvent}get originalEvent(){return this.sensorEvent?this.sensorEvent.originalEvent:null}}t.MirrorEvent=s;class a extends s{}t.MirrorCreateEvent=a,a.type=\"mirror:create\";class l extends s{get mirror(){return this.data.mirror}}t.MirrorCreatedEvent=l,l.type=\"mirror:created\";class c extends s{get mirror(){return this.data.mirror}}t.MirrorAttachedEvent=c,c.type=\"mirror:attached\";class u extends s{get mirror(){return this.data.mirror}}t.MirrorMoveEvent=u,u.type=\"mirror:move\",u.cancelable=!0;class d extends s{get mirror(){return this.data.mirror}}t.MirrorDestroyEvent=d,d.type=\"mirror:destroy\",d.cancelable=!0},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(29);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=t.getAppendableContainer=t.onScroll=t.onMirrorMove=t.onMirrorCreated=t.onDragStop=t.onDragMove=t.onDragStart=void 0;var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(4),s=(n=i)&&n.__esModule?n:{default:n},a=r(30);function l(e,t){var r={};for(var n in e)t.indexOf(n)>=0||Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=e[n]);return r}const c=t.onDragStart=Symbol(\"onDragStart\"),u=t.onDragMove=Symbol(\"onDragMove\"),d=t.onDragStop=Symbol(\"onDragStop\"),g=t.onMirrorCreated=Symbol(\"onMirrorCreated\"),h=t.onMirrorMove=Symbol(\"onMirrorMove\"),f=t.onScroll=Symbol(\"onScroll\"),v=t.getAppendableContainer=Symbol(\"getAppendableContainer\"),m=t.defaultOptions={constrainDimensions:!1,xAxis:!0,yAxis:!0,cursorOffsetX:null,cursorOffsetY:null};class p extends s.default{constructor(e){super(e),this.options=o({},m,this.getOptions()),this.scrollOffset={x:0,y:0},this.initialScrollOffset={x:window.scrollX,y:window.scrollY},this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this),this[g]=this[g].bind(this),this[h]=this[h].bind(this),this[f]=this[f].bind(this)}attach(){this.draggable.on(\"drag:start\",this[c]).on(\"drag:move\",this[u]).on(\"drag:stop\",this[d]).on(\"mirror:created\",this[g]).on(\"mirror:move\",this[h])}detach(){this.draggable.off(\"drag:start\",this[c]).off(\"drag:move\",this[u]).off(\"drag:stop\",this[d]).off(\"mirror:created\",this[g]).off(\"mirror:move\",this[h])}getOptions(){return this.draggable.options.mirror||{}}[c](e){if(e.canceled())return;\"ontouchstart\"in window&&document.addEventListener(\"scroll\",this[f],!0),this.initialScrollOffset={x:window.scrollX,y:window.scrollY};const{source:t,originalSource:r,sourceContainer:n,sensorEvent:o}=e,i=new a.MirrorCreateEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e});if(this.draggable.trigger(i),function(e){return/^drag/.test(e.originalEvent.type)}(o)||i.canceled())return;const s=this[v](t)||n;this.mirror=t.cloneNode(!0);const l=new a.MirrorCreatedEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror}),c=new a.MirrorAttachedEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror});this.draggable.trigger(l),s.appendChild(this.mirror),this.draggable.trigger(c)}[u](e){if(!this.mirror||e.canceled())return;const{source:t,originalSource:r,sourceContainer:n,sensorEvent:o}=e,i=new a.MirrorMoveEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror});this.draggable.trigger(i)}[d](e){if(\"ontouchstart\"in window&&document.removeEventListener(\"scroll\",this[f],!0),this.initialScrollOffset={x:0,y:0},this.scrollOffset={x:0,y:0},!this.mirror)return;const{source:t,sourceContainer:r,sensorEvent:n}=e,o=new a.MirrorDestroyEvent({source:t,mirror:this.mirror,sourceContainer:r,sensorEvent:n,dragEvent:e});this.draggable.trigger(o),o.canceled()||this.mirror.parentNode.removeChild(this.mirror)}[f](){this.scrollOffset={x:window.scrollX-this.initialScrollOffset.x,y:window.scrollY-this.initialScrollOffset.y}}[g]({mirror:e,source:t,sensorEvent:r}){const n={mirror:e,source:t,sensorEvent:r,mirrorClass:this.draggable.getClassNameFor(\"mirror\"),scrollOffset:this.scrollOffset,options:this.options};return Promise.resolve(n).then(b).then(E).then(y).then(S).then(C({initial:!0})).then(O).then(e=>{let{mirrorOffset:t,initialX:r,initialY:n}=e,i=l(e,[\"mirrorOffset\",\"initialX\",\"initialY\"]);return this.mirrorOffset=t,this.initialX=r,this.initialY=n,o({mirrorOffset:t,initialX:r,initialY:n},i)})}[h](e){if(e.canceled())return null;const t={mirror:e.mirror,sensorEvent:e.sensorEvent,mirrorOffset:this.mirrorOffset,options:this.options,initialX:this.initialX,initialY:this.initialY,scrollOffset:this.scrollOffset};return Promise.resolve(t).then(C({raf:!0}))}[v](e){const t=this.options.appendTo;return\"string\"==typeof t?document.querySelector(t):t instanceof HTMLElement?t:\"function\"==typeof t?t(e):e.parentNode}}function b(e){let{source:t}=e,r=l(e,[\"source\"]);return w(e=>{const n=t.getBoundingClientRect();e(o({source:t,sourceRect:n},r))})}function E(e){let{sensorEvent:t,sourceRect:r,options:n}=e,i=l(e,[\"sensorEvent\",\"sourceRect\",\"options\"]);return w(e=>{const s=null===n.cursorOffsetY?t.clientY-r.top:n.cursorOffsetY,a=null===n.cursorOffsetX?t.clientX-r.left:n.cursorOffsetX;e(o({sensorEvent:t,sourceRect:r,mirrorOffset:{top:s,left:a},options:n},i))})}function y(e){let{mirror:t,source:r,options:n}=e,i=l(e,[\"mirror\",\"source\",\"options\"]);return w(e=>{let s,a;if(n.constrainDimensions){const e=getComputedStyle(r);s=e.getPropertyValue(\"height\"),a=e.getPropertyValue(\"width\")}t.style.position=\"fixed\",t.style.pointerEvents=\"none\",t.style.top=0,t.style.left=0,t.style.margin=0,n.constrainDimensions&&(t.style.height=s,t.style.width=a),e(o({mirror:t,source:r,options:n},i))})}function S(e){let{mirror:t,mirrorClass:r}=e,n=l(e,[\"mirror\",\"mirrorClass\"]);return w(e=>{t.classList.add(r),e(o({mirror:t,mirrorClass:r},n))})}function O(e){let{mirror:t}=e,r=l(e,[\"mirror\"]);return w(e=>{t.removeAttribute(\"id\"),delete t.id,e(o({mirror:t},r))})}function C({withFrame:e=!1,initial:t=!1}={}){return r=>{let{mirror:n,sensorEvent:i,mirrorOffset:s,initialY:a,initialX:c,scrollOffset:u,options:d}=r,g=l(r,[\"mirror\",\"sensorEvent\",\"mirrorOffset\",\"initialY\",\"initialX\",\"scrollOffset\",\"options\"]);return w(e=>{const r=o({mirror:n,sensorEvent:i,mirrorOffset:s,options:d},g);if(s){const e=i.clientX-s.left-u.x,o=i.clientY-s.top-u.y;d.xAxis&&d.yAxis||t?n.style.transform=`translate3d(${e}px, ${o}px, 0)`:d.xAxis&&!d.yAxis?n.style.transform=`translate3d(${e}px, ${a}px, 0)`:d.yAxis&&!d.xAxis&&(n.style.transform=`translate3d(${c}px, ${o}px, 0)`),t&&(r.initialX=e,r.initialY=o)}e(r)},{frame:e})}}function w(e,{raf:t=!1}={}){return new Promise((r,n)=>{t?requestAnimationFrame(()=>{e(r,n)}):e(r,n)})}t.default=p},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=void 0;var n,o=r(31),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default,t.defaultOptions=o.defaultOptions},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(4),s=(n=i)&&n.__esModule?n:{default:n};const a=Symbol(\"onInitialize\"),l=Symbol(\"onDestroy\"),c={};class u extends s.default{constructor(e){super(e),this.options=o({},c,this.getOptions()),this[a]=this[a].bind(this),this[l]=this[l].bind(this)}attach(){this.draggable.on(\"draggable:initialize\",this[a]).on(\"draggable:destroy\",this[l])}detach(){this.draggable.off(\"draggable:initialize\",this[a]).off(\"draggable:destroy\",this[l])}getOptions(){return this.draggable.options.focusable||{}}getElements(){return[...this.draggable.containers,...this.draggable.getDraggableElements()]}[a](){requestAnimationFrame(()=>{this.getElements().forEach(e=>function(e){Boolean(!e.getAttribute(\"tabindex\")&&-1===e.tabIndex)&&(d.push(e),e.tabIndex=0)}(e))})}[l](){requestAnimationFrame(()=>{this.getElements().forEach(e=>function(e){const t=d.indexOf(e);-1!==t&&(e.tabIndex=-1,d.splice(t,1))}(e))})}}t.default=u;const d=[]},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=r(33),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=class{constructor(e){this.draggable=e}attach(){throw new Error(\"Not Implemented\")}detach(){throw new Error(\"Not Implemented\")}}},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=void 0;var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(4),s=(n=i)&&n.__esModule?n:{default:n};const a=Symbol(\"onInitialize\"),l=Symbol(\"onDestroy\"),c=Symbol(\"announceEvent\"),u=Symbol(\"announceMessage\"),d=t.defaultOptions={expire:7e3};class g extends s.default{constructor(e){super(e),this.options=o({},d,this.getOptions()),this.originalTriggerMethod=this.draggable.trigger,this[a]=this[a].bind(this),this[l]=this[l].bind(this)}attach(){this.draggable.on(\"draggable:initialize\",this[a])}detach(){this.draggable.off(\"draggable:destroy\",this[l])}getOptions(){return this.draggable.options.announcements||{}}[c](e){const t=this.options[e.type];t&&\"string\"==typeof t&&this[u](t),t&&\"function\"==typeof t&&this[u](t(e))}[u](e){!function(e,{expire:t}){const r=document.createElement(\"div\");r.textContent=e,h.appendChild(r),setTimeout(()=>{h.removeChild(r)},t)}(e,{expire:this.options.expire})}[a](){this.draggable.trigger=e=>{try{this[c](e)}finally{this.originalTriggerMethod.call(this.draggable,e)}}}[l](){this.draggable.trigger=this.originalTriggerMethod}}t.default=g;const h=function(){const e=document.createElement(\"div\");return e.setAttribute(\"id\",\"draggable-live-region\"),e.setAttribute(\"aria-relevant\",\"additions\"),e.setAttribute(\"aria-atomic\",\"true\"),e.setAttribute(\"aria-live\",\"assertive\"),e.setAttribute(\"role\",\"log\"),e.style.position=\"fixed\",e.style.width=\"1px\",e.style.height=\"1px\",e.style.top=\"-1px\",e.style.overflow=\"hidden\",e}();document.addEventListener(\"DOMContentLoaded\",()=>{document.body.appendChild(h)})},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.defaultOptions=void 0;var n,o=r(36),i=(n=o)&&n.__esModule?n:{default:n};t.default=i.default,t.defaultOptions=o.defaultOptions},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.DraggableDestroyEvent=t.DraggableInitializedEvent=t.DraggableEvent=void 0;var n,o=r(3),i=(n=o)&&n.__esModule?n:{default:n};class s extends i.default{get draggable(){return this.data.draggable}}t.DraggableEvent=s,s.type=\"draggable\";class a extends s{}t.DraggableInitializedEvent=a,a.type=\"draggable:initialize\";class l extends s{}t.DraggableDestroyEvent=l,l.type=\"draggable:destroy\"},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.DragStopEvent=t.DragPressureEvent=t.DragOutContainerEvent=t.DragOverContainerEvent=t.DragOutEvent=t.DragOverEvent=t.DragMoveEvent=t.DragStartEvent=t.DragEvent=void 0;var n,o=r(3),i=(n=o)&&n.__esModule?n:{default:n};class s extends i.default{get source(){return this.data.source}get originalSource(){return this.data.originalSource}get mirror(){return this.data.mirror}get sourceContainer(){return this.data.sourceContainer}get sensorEvent(){return this.data.sensorEvent}get originalEvent(){return this.sensorEvent?this.sensorEvent.originalEvent:null}}t.DragEvent=s,s.type=\"drag\";class a extends s{}t.DragStartEvent=a,a.type=\"drag:start\",a.cancelable=!0;class l extends s{}t.DragMoveEvent=l,l.type=\"drag:move\";class c extends s{get overContainer(){return this.data.overContainer}get over(){return this.data.over}}t.DragOverEvent=c,c.type=\"drag:over\",c.cancelable=!0;class u extends s{get overContainer(){return this.data.overContainer}get over(){return this.data.over}}t.DragOutEvent=u,u.type=\"drag:out\";class d extends s{get overContainer(){return this.data.overContainer}}t.DragOverContainerEvent=d,d.type=\"drag:over:container\";class g extends s{get overContainer(){return this.data.overContainer}}t.DragOutContainerEvent=g,g.type=\"drag:out:container\";class h extends s{get pressure(){return this.data.pressure}}t.DragPressureEvent=h,h.type=\"drag:pressure\";class f extends s{}t.DragStopEvent=f,f.type=\"drag:stop\"},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(8);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}));var o=r(7);Object.keys(o).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}})}));var i=r(6);Object.keys(i).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})}));var s=r(5);Object.keys(s).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}})}));var a,l=r(12),c=(a=l)&&a.__esModule?a:{default:a};t.default=c.default},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n,o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i=r(40),s=(n=i)&&n.__esModule?n:{default:n},a=r(9);const l=Symbol(\"onDragStart\"),c=Symbol(\"onDragOverContainer\"),u=Symbol(\"onDragOver\"),d=Symbol(\"onDragStop\"),g={\"sortable:sorted\":function({dragEvent:e}){const t=e.source.textContent.trim()||e.source.id||\"sortable element\";if(e.over){const r=e.over.textContent.trim()||e.over.id||\"sortable element\";return e.source.compareDocumentPosition(e.over)&Node.DOCUMENT_POSITION_FOLLOWING?`Placed ${t} after ${r}`:`Placed ${t} before ${r}`}return`Placed ${t} into a different container`}};class h extends s.default{constructor(e=[],t={}){super(e,o({},t,{announcements:o({},g,t.announcements||{})})),this.startIndex=null,this.startContainer=null,this[l]=this[l].bind(this),this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[d]=this[d].bind(this),this.on(\"drag:start\",this[l]).on(\"drag:over:container\",this[c]).on(\"drag:over\",this[u]).on(\"drag:stop\",this[d])}destroy(){super.destroy(),this.off(\"drag:start\",this[l]).off(\"drag:over:container\",this[c]).off(\"drag:over\",this[u]).off(\"drag:stop\",this[d])}index(e){return this.getDraggableElementsForContainer(e.parentNode).indexOf(e)}[l](e){this.startContainer=e.source.parentNode,this.startIndex=this.index(e.source);const t=new a.SortableStartEvent({dragEvent:e,startIndex:this.startIndex,startContainer:this.startContainer});this.trigger(t),t.canceled()&&e.cancel()}[c](e){if(e.canceled())return;const{source:t,over:r,overContainer:n}=e,o=this.index(t),i=new a.SortableSortEvent({dragEvent:e,currentIndex:o,source:t,over:r});if(this.trigger(i),i.canceled())return;const s=v({source:t,over:r,overContainer:n,children:this.getDraggableElementsForContainer(n)});if(!s)return;const{oldContainer:l,newContainer:c}=s,u=this.index(e.source),d=new a.SortableSortedEvent({dragEvent:e,oldIndex:o,newIndex:u,oldContainer:l,newContainer:c});this.trigger(d)}[u](e){if(e.over===e.originalSource||e.over===e.source)return;const{source:t,over:r,overContainer:n}=e,o=this.index(t),i=new a.SortableSortEvent({dragEvent:e,currentIndex:o,source:t,over:r});if(this.trigger(i),i.canceled())return;const s=v({source:t,over:r,overContainer:n,children:this.getDraggableElementsForContainer(n)});if(!s)return;const{oldContainer:l,newContainer:c}=s,u=this.index(t),d=new a.SortableSortedEvent({dragEvent:e,oldIndex:o,newIndex:u,oldContainer:l,newContainer:c});this.trigger(d)}[d](e){const t=new a.SortableStopEvent({dragEvent:e,oldIndex:this.startIndex,newIndex:this.index(e.source),oldContainer:this.startContainer,newContainer:e.source.parentNode});this.trigger(t),this.startIndex=null,this.startContainer=null}}function f(e){return Array.prototype.indexOf.call(e.parentNode.children,e)}function v({source:e,over:t,overContainer:r,children:n}){const o=!n.length,i=e.parentNode!==r,s=t&&!i;return o?function(e,t){const r=e.parentNode;return t.appendChild(e),{oldContainer:r,newContainer:t}}(e,r):s?function(e,t){const r=f(e),n=f(t);return r<n?e.parentNode.insertBefore(e,t.nextElementSibling):e.parentNode.insertBefore(e,t),{oldContainer:e.parentNode,newContainer:e.parentNode}}(e,t):i?function(e,t,r){const n=e.parentNode;return t?t.parentNode.insertBefore(e,t):r.appendChild(e),{oldContainer:n,newContainer:e.parentNode}}(e,t,r):null}t.default=h},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};const o=Symbol(\"canceled\");class i{constructor(e){this[o]=!1,this.data=e}get type(){return this.constructor.type}get cancelable(){return this.constructor.cancelable}cancel(){this[o]=!0}canceled(){return Boolean(this[o])}clone(e){return new this.constructor(n({},this.data,e))}}t.default=i,i.type=\"event\",i.cancelable=!1},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0}),t.SortableStopEvent=t.SortableSortedEvent=t.SortableSortEvent=t.SortableStartEvent=t.SortableEvent=void 0;var n,o=r(3),i=(n=o)&&n.__esModule?n:{default:n};class s extends i.default{get dragEvent(){return this.data.dragEvent}}t.SortableEvent=s,s.type=\"sortable\";class a extends s{get startIndex(){return this.data.startIndex}get startContainer(){return this.data.startContainer}}t.SortableStartEvent=a,a.type=\"sortable:start\",a.cancelable=!0;class l extends s{get currentIndex(){return this.data.currentIndex}get over(){return this.data.oldIndex}get overContainer(){return this.data.newIndex}}t.SortableSortEvent=l,l.type=\"sortable:sort\",l.cancelable=!0;class c extends s{get oldIndex(){return this.data.oldIndex}get newIndex(){return this.data.newIndex}get oldContainer(){return this.data.oldContainer}get newContainer(){return this.data.newContainer}}t.SortableSortedEvent=c,c.type=\"sortable:sorted\";class u extends s{get oldIndex(){return this.data.oldIndex}get newIndex(){return this.data.newIndex}get oldContainer(){return this.data.oldContainer}get newContainer(){return this.data.newContainer}}t.SortableStopEvent=u,u.type=\"sortable:stop\"},function(e,t,r){Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(9);Object.keys(n).forEach((function(e){\"default\"!==e&&\"__esModule\"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})}));var o,i=r(41),s=(o=i)&&o.__esModule?o:{default:o};t.default=s.default}])},e.exports=r()})),r=(e=t)&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e;if(void 0===window.Livewire)throw\"Livewire Sortable Plugin: window.Livewire is undefined. Make sure @livewireScripts is placed above this script include\";window.Livewire.directive(\"sortable-group\",({el:e,directive:t,component:n})=>{if(t.modifiers.includes(\"item-group\")&&e.closest(\"[wire\\\\:sortable-group]\").livewire_sortable.addContainer(e),t.modifiers.length>0)return;let o={draggable:\"[wire\\\\:sortable-group\\\\.item]\"};e.querySelector(\"[wire\\\\:sortable-group\\\\.handle]\")&&(o.handle=\"[wire\\\\:sortable-group\\\\.handle]\"),(e.livewire_sortable=new r([],o)).on(\"sortable:stop\",()=>{setTimeout(()=>{let r=[];e.querySelectorAll(\"[wire\\\\:sortable-group\\\\.item-group]\").forEach((e,t)=>{let n=[];e.querySelectorAll(\"[wire\\\\:sortable-group\\\\.item]\").forEach((e,t)=>{n.push({order:t+1,value:e.getAttribute(\"wire:sortable-group.item\")})}),r.push({order:t+1,value:e.getAttribute(\"wire:sortable-group.item-group\"),items:n})}),n.$wire.call(t.method,r)},1)})}),window.Livewire.directive(\"sortable\",({el:e,directive:t,component:n})=>{if(t.modifiers.length>0)return;let o={draggable:\"[wire\\\\:sortable\\\\.item]\"};e.querySelector(\"[wire\\\\:sortable\\\\.handle]\")&&(o.handle=\"[wire\\\\:sortable\\\\.handle]\"),new r(e,o).on(\"sortable:stop\",()=>{setTimeout(()=>{let r=[];e.querySelectorAll(\"[wire\\\\:sortable\\\\.item]\").forEach((e,t)=>{r.push({order:t+1,value:e.getAttribute(\"wire:sortable.item\")})}),n.$wire.call(t.method,r)},1)})})}));\n//# sourceMappingURL=livewire-sortable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl2ZXdpcmUtc29ydGFibGUvZGlzdC9saXZld2lyZS1zb3J0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrRUFBYSxLQUFxQyxDQUFDLG9DQUFPLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQyxDQUFDLENBQUcsQ0FBQyxhQUFhLGFBQWEsc0JBQXNCLFlBQVksV0FBVyxzQkFBc0IsZ0JBQWdCLE1BQU0sb0JBQW9CLG1CQUFtQixTQUFTLGNBQWMsNEJBQTRCLFlBQVkscUJBQXFCLDJEQUEyRCx1Q0FBdUMscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQiw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLG1CQUFtQiw4QkFBOEIscURBQXFELDBCQUEwQiw2Q0FBNkMsc0JBQXNCLDZEQUE2RCxZQUFZLGVBQWUsU0FBUyxpQkFBaUIsaUNBQWlDLGlCQUFpQixZQUFZLFVBQVUsc0JBQXNCLG1CQUFtQixpREFBaUQsa0JBQWtCLGtCQUFrQixzQ0FBc0MsU0FBUyxFQUFFLFlBQVksb0NBQW9DLDREQUE0RCw2QkFBNkIsYUFBYSxFQUFFLEdBQUcsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLFlBQVksbUNBQW1DLDZCQUE2QixxQkFBcUIsRUFBRSxZQUFZLGNBQWMsMEJBQTBCLFdBQVcscURBQXFELDZCQUE2QixxQkFBcUIsRUFBRSxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSx1Q0FBdUMsV0FBVyxvQkFBb0IsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLFdBQVcsa0NBQWtDLDZCQUE2QixxQkFBcUIsRUFBRSxZQUFZLHVDQUF1Qyw2QkFBNkIscUJBQXFCLEVBQUUsWUFBWSx1Q0FBdUMsNkJBQTZCLHFCQUFxQixFQUFFLFlBQVksc0NBQXNDLDZCQUE2QixxQkFBcUIsRUFBRSxZQUFZLDRDQUE0Qyw2QkFBNkIscUJBQXFCLEVBQUUsV0FBVyxjQUFjLDBCQUEwQixXQUFXLG9DQUFvQyw0REFBNEQsNkJBQTZCLGFBQWEsRUFBRSxHQUFHLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLFlBQVksd0NBQXdDLDZCQUE2QixxQkFBcUIsd0RBQXdELDZCQUE2Qix5QkFBeUIsRUFBRSxZQUFZLHFDQUFxQyw2QkFBNkIscUJBQXFCLEVBQUUsWUFBWSxrQ0FBa0MsNkJBQTZCLHFCQUFxQixrREFBa0QsNkJBQTZCLHlCQUF5QixFQUFFLFlBQVksY0FBYywwQkFBMEIsV0FBVyxzQ0FBc0MsNkJBQTZCLHFCQUFxQixzREFBc0QsNkJBQTZCLHlCQUF5QixFQUFFLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLFlBQVksb0NBQW9DLDREQUE0RCw2QkFBNkIsYUFBYSxFQUFFLEdBQUcsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsWUFBWSxvQ0FBb0MsNERBQTRELDZCQUE2QixhQUFhLEVBQUUsR0FBRyxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSxZQUFZLG9DQUFvQyw0REFBNEQsNkJBQTZCLGFBQWEsRUFBRSxHQUFHLGlCQUFpQixzQ0FBc0MsU0FBUyxrQkFBa0IsY0FBYyxrQkFBa0IsV0FBVyxtRkFBbUYsU0FBUyxrQ0FBa0MsbUNBQW1DLFlBQVksV0FBVyw0Q0FBNEMsWUFBWSxXQUFXLHVDQUF1Qyx5Q0FBeUMscUJBQXFCLEtBQUssS0FBSyxhQUFhLElBQUksS0FBSyxTQUFTLFdBQVcsNEVBQTRFLE9BQU8sYUFBYSxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSx1Q0FBdUMsV0FBVyxvQkFBb0IsaUJBQWlCLHNDQUFzQyxTQUFTLDBCQUEwQixtQ0FBbUMsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIsc0VBQXNFLFNBQVMsZ0RBQWdELFVBQVUsc0JBQXNCLDBHQUEwRyw2QkFBNkIsOERBQThELDZCQUE2Qiw4REFBOEQsRUFBRSxJQUFJLGlZQUFpWSxxQkFBcUIsNkZBQTZGLFFBQVEsa0NBQWtDLEVBQUUsb0VBQW9FLEtBQUssK0lBQStJLG9CQUFvQixpQkFBaUIsTUFBTSxZQUFZLGdCQUFnQixvQkFBb0Isc0JBQXNCLEVBQUUsdVlBQXVZLDJFQUEyRSwwRkFBMEYseUNBQXlDLGVBQWUsRUFBRSwyQkFBMkIsU0FBUyxpRkFBaUYsVUFBVSx5TkFBeU4scUNBQXFDLGVBQWUsRUFBRSxrSUFBa0ksZ0JBQWdCLDhCQUE4Qix5RUFBeUUsbUJBQW1CLHFKQUFxSixnQkFBZ0Isc0RBQXNELHlFQUF5RSxtQkFBbUIscUpBQXFKLG1CQUFtQixvR0FBb0csc0JBQXNCLHVIQUF1SCxXQUFXLG9DQUFvQyxTQUFTLGtDQUFrQyxXQUFXLG9DQUFvQyxtQkFBbUIsK0JBQStCLGFBQWEsOEJBQThCLHVCQUF1Qiw0RkFBNEYsb0NBQW9DLDBHQUEwRyxPQUFPLGNBQWMscUJBQXFCLEdBQUcsdUNBQXVDLHdGQUF3RixrSUFBa0ksNFpBQTRaLDhCQUE4QixzRkFBc0YsRUFBRSxnS0FBZ0ssbVZBQW1WLG9CQUFvQixtQkFBbUIsRUFBRSxZQUFZLElBQUksU0FBUyxHQUFHLEVBQUUsT0FBTyx5QkFBeUIsY0FBYyxZQUFZLEdBQUcsZUFBZSw2QkFBNkIsc0ZBQXNGLEVBQUUsbUZBQW1GLHlPQUF5TyxNQUFNLDRCQUE0Qiw0R0FBNEcsRUFBRSxnSEFBZ0gsTUFBTSxxQ0FBcUMsOEhBQThILEVBQUUsa0lBQWtJLE1BQU0sd0RBQXdELHNDQUFzQyxzR0FBc0csRUFBRSw0Q0FBNEMsTUFBTSx3REFBd0QsNkJBQTZCLDZHQUE2RyxFQUFFLG9DQUFvQyxPQUFPLHlCQUF5QixpQkFBaUIsNkJBQTZCLHFIQUFxSCxFQUFFLHU4QkFBdThCLDRRQUE0USxzSkFBc0osT0FBTyx5QkFBeUIsb0hBQW9ILDJDQUEyQyxFQUFFLGlCQUFpQixjQUFjLGdCQUFnQixnQkFBZ0IscUhBQXFILHVCQUF1QiwyRkFBMkYsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsc0NBQXNDLFVBQVUsUUFBUSwrTUFBK00sMEJBQTBCLHFCQUFxQixFQUFFLCtMQUErTCxTQUFTLG9QQUFvUCw0RkFBNEYsU0FBUyxnUUFBZ1Esa0dBQWtHLE9BQU8scUNBQXFDLE9BQU8sd0JBQXdCLHVHQUF1Ryx5RUFBeUUsRUFBRSx3RkFBd0YsT0FBTyx5QkFBeUIsbUNBQW1DLGdHQUFnRyxFQUFFLG9HQUFvRyxPQUFPLHNGQUFzRixPQUFPLHlCQUF5QixvRkFBb0YsNkZBQTZGLEVBQUUsc0NBQXNDLE9BQU8sd0JBQXdCLG9FQUFvRSxnR0FBZ0csRUFBRSxrQkFBa0IsT0FBTyx5QkFBeUIsa0RBQWtELG9IQUFvSCxFQUFFLHVDQUF1QyxZQUFZLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLHVDQUF1QyxXQUFXLG9CQUFvQixpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSw2Q0FBNkMsVUFBVSxRQUFRLDhKQUE4SiwwQkFBMEIscUJBQXFCLEVBQUUsb1FBQW9RLFNBQVMsa0RBQWtELFNBQVMscURBQXFELE9BQU8saUZBQWlGLHVEQUF1RCwrRkFBK0Ysb0NBQW9DLDZGQUE2RixFQUFFLGdCQUFnQixxRkFBcUYsSUFBSSxPQUFPLHlCQUF5Qiw0R0FBNEcseUVBQXlFLEVBQUUsaUdBQWlHLE9BQU8seUJBQXlCLG1EQUFtRCw0R0FBNEcseUVBQXlFLEVBQUUsNkNBQTZDLE9BQU8sbUJBQW1CLE9BQU8sOERBQThELCtDQUErQyxrU0FBa1MsdURBQXVELDBDQUEwQyx1Q0FBdUMsc0JBQXNCLE1BQU0sVUFBVSxNQUFNLG9lQUFvZSxZQUFZLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLHVDQUF1QyxXQUFXLG9CQUFvQixpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSw2Q0FBNkMsVUFBVSxRQUFRLHNHQUFzRyxTQUFTLHdDQUF3QyxzQkFBc0IsRUFBRSxXQUFXLEVBQUUsMEJBQTBCLHFCQUFxQixFQUFFLGlNQUFpTSxTQUFTLGdEQUFnRCxTQUFTLG1EQUFtRCxPQUFPLGdEQUFnRCwyUUFBMlEsU0FBUyxXQUFXLDBCQUEwQixtRkFBbUYscUVBQXFFLEVBQUUsK0RBQStELE9BQU8sNENBQTRDLGtKQUFrSix5RkFBeUYsRUFBRSxzQ0FBc0MsT0FBTyx3VEFBd1QscUhBQXFILG1CQUFtQixtQ0FBbUMseUZBQXlGLEVBQUUsbUZBQW1GLGNBQWMsdUNBQXVDLFlBQVksaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUyxvSEFBb0gsc0NBQXNDLFdBQVcsMEJBQTBCLG9CQUFvQiwrQkFBK0IsY0FBYyx5QkFBeUIsY0FBYyx5QkFBeUIsYUFBYSx3QkFBd0IsZ0JBQWdCLDJCQUEyQixlQUFlLDJCQUEyQixnQkFBZ0IsbUJBQW1CLDZDQUE2QyxtQkFBbUIsMkNBQTJDLG1CQUFtQiwyQ0FBMkMsbUJBQW1CLG1EQUFtRCxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSw2Q0FBNkMsVUFBVSxRQUFRLG1IQUFtSCwwQkFBMEIscUJBQXFCLEVBQUUsOExBQThMLFNBQVMsa0RBQWtELFNBQVMscURBQXFELE9BQU8sNkNBQTZDLDZDQUE2QywwRkFBMEYseUlBQXlJLDBCQUEwQixvQ0FBb0MseUVBQXlFLEVBQUUsdUxBQXVMLHNCQUFzQixPQUFPLHlCQUF5QixvRkFBb0YsNkZBQTZGLEVBQUUsc0NBQXNDLE9BQU8sZ0hBQWdILHFIQUFxSCxvRkFBb0YsNkZBQTZGLEVBQUUsd0xBQXdMLE9BQU8sOENBQThDLGNBQWMsbUJBQW1CLFlBQVksaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLGlDQUFpQyxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsVUFBVSxnQkFBZ0IscUJBQXFCLEVBQUUsd0NBQXdDLGdEQUFnRCxTQUFTLFlBQVksU0FBUyxZQUFZLG1CQUFtQiwwQ0FBMEMsc0JBQXNCLDBEQUEwRCxhQUFhLHNDQUFzQyxvRkFBb0YsaUJBQWlCLHNDQUFzQyxTQUFTLHdCQUF3QixrQ0FBa0MseUJBQXlCLEdBQUcsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUywwQkFBMEIsa0JBQWtCLDZLQUE2SyxRQUFRLEdBQUcsOEhBQThILGVBQWUsMENBQTBDLE1BQU0sYUFBYSxzSkFBc0osaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsdUNBQXVDLFdBQVcsb0JBQW9CLGlCQUFpQixzQ0FBc0MsU0FBUywyRUFBMkUsbUNBQW1DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLGlDQUFpQyxVQUFVLFFBQVEsb0tBQW9LLDhDQUE4QywwQkFBMEIsZUFBZSwwQkFBMEIsaVFBQWlRLFNBQVMsd0ZBQXdGLFNBQVMsMkZBQTJGLGFBQWEsNkNBQTZDLHdCQUF3QixrSUFBa0ksaUJBQWlCLGlIQUFpSCxrRUFBa0Usa0JBQWtCLG9JQUFvSSw4QkFBOEIsS0FBSywyQkFBMkIsSUFBSSwrQkFBK0IsMkRBQTJELE9BQU8sMkRBQTJELDJEQUEyRCxFQUFFLE9BQU8sOERBQThELHVFQUF1RSxpQ0FBaUMseUJBQXlCLFNBQVMsc09BQXNPLDRDQUE0QywwREFBMEQsTUFBTSxxT0FBcU8sTUFBTSw4REFBOEQsZ0RBQWdELE1BQU0sc0JBQXNCLGlOQUFpTix1REFBdUQsTUFBTSwyQkFBMkIsUUFBUSx3RkFBd0YsS0FBSyxNQUFNLDZCQUE2QixHQUFHLGtIQUFrSCwwREFBMEQsYUFBYSwyREFBMkQsWUFBWSxpQkFBaUIsc0NBQXNDLFNBQVMsMEJBQTBCLHVDQUF1QyxXQUFXLHNEQUFzRCxpQkFBaUIsc0NBQXNDLFNBQVMsNkhBQTZILHNDQUFzQyxXQUFXLDBCQUEwQixhQUFhLHdCQUF3QixxQkFBcUIsZ0NBQWdDLHNCQUFzQixpQ0FBaUMsa0JBQWtCLDZCQUE2QixnQkFBZ0IsMkJBQTJCLG9CQUFvQiw2REFBNkQsZ0JBQWdCLG1CQUFtQiw2Q0FBNkMsa0JBQWtCLGFBQWEseUJBQXlCLCtDQUErQyxrQkFBa0IsYUFBYSx5QkFBeUIsaURBQWlELGtCQUFrQixhQUFhLHlCQUF5Qix5REFBeUQsa0JBQWtCLGFBQWEseUJBQXlCLCtEQUErRCxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSxZQUFZLG9DQUFvQyw0REFBNEQsNkJBQTZCLGFBQWEsRUFBRSxHQUFHLGlCQUFpQixzQ0FBc0MsU0FBUyx1SUFBdUksbUNBQW1DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLGlDQUFpQyxVQUFVLFNBQVMsZ0JBQWdCLFNBQVMsdUZBQXVGLFNBQVMsMFRBQTBULGdGQUFnRiwwQkFBMEIsZUFBZSwwQkFBMEIseUNBQXlDLFFBQVEsMkJBQTJCLGtDQUFrQyxtS0FBbUssU0FBUywrSUFBK0ksU0FBUyxvSkFBb0osYUFBYSx5Q0FBeUMsT0FBTyx1QkFBdUIsa0dBQWtHLG1DQUFtQyxNQUFNLDBEQUEwRCw4QkFBOEIsc0VBQXNFLEVBQUUseUNBQXlDLHlDQUF5Qyx5QkFBeUIsc0JBQXNCLDRCQUE0QixrQ0FBa0MseUZBQXlGLCtCQUErQix5RkFBeUYsRUFBRSwrRUFBK0UsT0FBTyxxQ0FBcUMsTUFBTSwwREFBMEQsNEJBQTRCLHlGQUF5RixFQUFFLDBCQUEwQixPQUFPLHdHQUF3RyxRQUFRLG9CQUFvQixRQUFRLHFCQUFxQixNQUFNLHlDQUF5QywrQkFBK0Isd0VBQXdFLEVBQUUsd0ZBQXdGLE1BQU0sbUJBQW1CLHlGQUF5RixLQUFLLGdDQUFnQyxFQUFFLFNBQVMsMElBQTBJLGtFQUFrRSxXQUFXLG9CQUFvQixJQUFJLHFDQUFxQyxpREFBaUQsOERBQThELHFDQUFxQyxJQUFJLEVBQUUsT0FBTyw0QkFBNEIsU0FBUyw0S0FBNEssa0NBQWtDLE9BQU8sR0FBRyxPQUFPLDhCQUE4QixzSEFBc0gsY0FBYyxJQUFJLFNBQVMscUJBQXFCLGFBQWEsa0NBQWtDLEtBQUssc0JBQXNCLEtBQUssRUFBRSxjQUFjLElBQUkscUNBQXFDLGlEQUFpRCxhQUFhLHlIQUF5SCxLQUFLLHlDQUF5QyxhQUFhLFdBQVcsS0FBSyxFQUFFLGNBQWMsSUFBSSw0QkFBNEIsd0NBQXdDLGFBQWEsUUFBUSwwQkFBMEIsNEJBQTRCLDZEQUE2RCxtS0FBbUssNEJBQTRCLEtBQUssRUFBRSxjQUFjLElBQUksdUJBQXVCLG1DQUFtQyxhQUFhLHdCQUF3Qix1QkFBdUIsS0FBSyxFQUFFLGNBQWMsSUFBSSxTQUFTLHFCQUFxQixhQUFhLHlDQUF5QyxTQUFTLEtBQUssRUFBRSxZQUFZLDRCQUE0QixHQUFHLEVBQUUsV0FBVyxJQUFJLHFGQUFxRixpR0FBaUcsYUFBYSxXQUFXLGdEQUFnRCxJQUFJLE1BQU0sbURBQW1ELHFEQUFxRCxFQUFFLE1BQU0sRUFBRSwyREFBMkQsRUFBRSxNQUFNLEVBQUUsNkRBQTZELEVBQUUsTUFBTSxFQUFFLHdDQUF3QyxLQUFLLEVBQUUsUUFBUSxHQUFHLGNBQWMsU0FBUyxHQUFHLEVBQUUsMkJBQTJCLDZCQUE2QixPQUFPLFNBQVMsRUFBRSxZQUFZLGlCQUFpQixzQ0FBc0MsU0FBUywwQkFBMEIsdUNBQXVDLFdBQVcsc0RBQXNELGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLG1DQUFtQyxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsU0FBUyxpQ0FBaUMsV0FBVywwREFBMEQsMEJBQTBCLGVBQWUsMEJBQTBCLDRFQUE0RSxTQUFTLGtGQUFrRixTQUFTLG9GQUFvRixhQUFhLDRDQUE0QyxjQUFjLDhFQUE4RSxNQUFNLDJCQUEyQiwwQ0FBMEMsZ0ZBQWdGLEtBQUssRUFBRSxNQUFNLDJCQUEyQiwwQ0FBMEMscUJBQXFCLHNDQUFzQyxLQUFLLEdBQUcsWUFBWSxXQUFXLGlCQUFpQixzQ0FBc0MsU0FBUyxFQUFFLHVDQUF1QyxXQUFXLG9CQUFvQixpQkFBaUIsc0NBQXNDLFNBQVMsa0JBQWtCLGVBQWUsaUJBQWlCLFNBQVMsbUNBQW1DLFNBQVMscUNBQXFDLGlCQUFpQixzQ0FBc0MsU0FBUywwQkFBMEIsbUNBQW1DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLGlDQUFpQyxXQUFXLCtIQUErSCxZQUFZLDBCQUEwQixlQUFlLDBCQUEwQiw4SEFBOEgsU0FBUyxrREFBa0QsU0FBUyxnREFBZ0QsYUFBYSxnREFBZ0QsT0FBTyw2QkFBNkIseUVBQXlFLE9BQU8sYUFBYSxTQUFTLEVBQUUsc0NBQXNDLGlEQUFpRCxpQkFBaUIsSUFBSSxJQUFJLDJCQUEyQixFQUFFLE1BQU0sMkJBQTJCLElBQUksV0FBVyxRQUFRLG9EQUFvRCxNQUFNLG1EQUFtRCxZQUFZLG1CQUFtQixzQ0FBc0MsMlRBQTJULEdBQUcsa0RBQWtELDZCQUE2QixFQUFFLGlCQUFpQixzQ0FBc0MsU0FBUywwQkFBMEIsdUNBQXVDLFdBQVcsc0RBQXNELGlCQUFpQixzQ0FBc0MsU0FBUyw4RUFBOEUsc0NBQXNDLFdBQVcsMEJBQTBCLGdCQUFnQiw0QkFBNEIsc0NBQXNDLG1CQUFtQiw0REFBNEQsbUJBQW1CLHFEQUFxRCxpQkFBaUIsc0NBQXNDLFNBQVMsMEtBQTBLLHNDQUFzQyxXQUFXLDBCQUEwQixhQUFhLHdCQUF3QixxQkFBcUIsZ0NBQWdDLGFBQWEsd0JBQXdCLHNCQUFzQixpQ0FBaUMsa0JBQWtCLDZCQUE2QixvQkFBb0IsNkRBQTZELDRCQUE0QixtQkFBbUIsdURBQXVELG1CQUFtQixxQ0FBcUMsa0JBQWtCLG9CQUFvQiwrQkFBK0IsV0FBVyx1QkFBdUIscURBQXFELGtCQUFrQixvQkFBb0IsK0JBQStCLFdBQVcsdUJBQXVCLG1DQUFtQyxrQkFBa0Isb0JBQW9CLGdDQUFnQyx3REFBd0Qsa0JBQWtCLG9CQUFvQixnQ0FBZ0Msc0RBQXNELGtCQUFrQixlQUFlLDJCQUEyQiw2Q0FBNkMsbUJBQW1CLHFDQUFxQyxpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSxXQUFXLG9DQUFvQyw0REFBNEQsNkJBQTZCLGFBQWEsRUFBRSxHQUFHLFdBQVcsb0NBQW9DLDREQUE0RCw2QkFBNkIsYUFBYSxFQUFFLEdBQUcsV0FBVyxvQ0FBb0MsNERBQTRELDZCQUE2QixhQUFhLEVBQUUsR0FBRyxXQUFXLG9DQUFvQyw0REFBNEQsNkJBQTZCLGFBQWEsRUFBRSxHQUFHLHVDQUF1QyxXQUFXLG9CQUFvQixpQkFBaUIsc0NBQXNDLFNBQVMsRUFBRSxtQ0FBbUMsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIsc0VBQXNFLFNBQVMsa0NBQWtDLFVBQVUsUUFBUSwrR0FBK0csNEJBQTRCLFlBQVksRUFBRSxxRUFBcUUsV0FBVyxpRUFBaUUsMkZBQTJGLEdBQUcsUUFBUSxFQUFFLFlBQVksR0FBRyxTQUFTLEVBQUUsRUFBRSxnQkFBZ0IsR0FBRyw4QkFBOEIsMEJBQTBCLHFCQUFxQixFQUFFLFlBQVksSUFBSSxrQkFBa0Isc0JBQXNCLEVBQUUsNlFBQTZRLFVBQVUsb0lBQW9JLFNBQVMsc0VBQXNFLE9BQU8sNkVBQTZFLGtDQUFrQywwRUFBMEUsRUFBRSx5Q0FBeUMsT0FBTyx1QkFBdUIsTUFBTSxnQ0FBZ0MsOENBQThDLDJDQUEyQyxFQUFFLHVDQUF1QyxXQUFXLGtGQUFrRixFQUFFLGFBQWEsTUFBTSw4QkFBOEIsdURBQXVELGdFQUFnRSxFQUFFLGdCQUFnQixPQUFPLHVEQUF1RCxNQUFNLGdDQUFnQyw4Q0FBOEMsMkNBQTJDLEVBQUUsdUNBQXVDLFdBQVcsa0ZBQWtGLEVBQUUsYUFBYSxNQUFNLDhCQUE4QixnREFBZ0QsZ0VBQWdFLEVBQUUsZ0JBQWdCLE9BQU8saUNBQWlDLHFJQUFxSSxFQUFFLCtEQUErRCxjQUFjLDZEQUE2RCxZQUFZLDJDQUEyQyxFQUFFLDZDQUE2Qyx1QkFBdUIscUJBQXFCLHlCQUF5QiwrQkFBK0Isc0JBQXNCLG9CQUFvQiw2RkFBNkYscURBQXFELHdCQUF3QixxQkFBcUIsMERBQTBELDBDQUEwQyxhQUFhLFlBQVksaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsaUNBQWlDLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxVQUFVLDJCQUEyQixRQUFRLGVBQWUsdUJBQXVCLFdBQVcsNkJBQTZCLGlCQUFpQixtQ0FBbUMsU0FBUyxXQUFXLFdBQVcsd0JBQXdCLFNBQVMsZ0NBQWdDLGdCQUFnQiwyQ0FBMkMsaUJBQWlCLHNDQUFzQyxTQUFTLDRHQUE0RyxzQ0FBc0MsV0FBVywwQkFBMEIsZ0JBQWdCLDRCQUE0QixvQ0FBb0Msa0JBQWtCLGlCQUFpQiw0QkFBNEIscUJBQXFCLGlDQUFpQywrREFBK0Qsa0JBQWtCLG1CQUFtQiw4QkFBOEIsV0FBVywwQkFBMEIsb0JBQW9CLDJCQUEyQiw2REFBNkQsa0JBQWtCLGVBQWUsMEJBQTBCLGVBQWUsMEJBQTBCLG1CQUFtQiw4QkFBOEIsbUJBQW1CLCtCQUErQixpREFBaUQsa0JBQWtCLGVBQWUsMEJBQTBCLGVBQWUsMEJBQTBCLG1CQUFtQiw4QkFBOEIsbUJBQW1CLCtCQUErQiw2Q0FBNkMsaUJBQWlCLHNDQUFzQyxTQUFTLEVBQUUsV0FBVyxvQ0FBb0MsNERBQTRELDZCQUE2QixhQUFhLEVBQUUsR0FBRyx1Q0FBdUMsV0FBVyxvQkFBb0IsR0FBRyxlQUFlLHdGQUF3RiwwSkFBMEosNkNBQTZDLDZCQUE2QixJQUFJLDBJQUEwSSxPQUFPLDRDQUE0Qyw2SkFBNkosZ0JBQWdCLFNBQVMsMkVBQTJFLFNBQVMscUVBQXFFLFFBQVEsMkRBQTJELEVBQUUsVUFBVSx5RUFBeUUsRUFBRSwyQkFBMkIsSUFBSSxFQUFFLHlDQUF5Qyw2QkFBNkIsSUFBSSwrQkFBK0IsT0FBTyxzQ0FBc0MsMEhBQTBILGdCQUFnQixTQUFTLCtEQUErRCxRQUFRLHFEQUFxRCxFQUFFLDJCQUEyQixJQUFJLEVBQUUsRUFBRTtBQUMvL2tEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdmV3aXJlLXNvcnRhYmxlL2Rpc3QvbGl2ZXdpcmUtc29ydGFibGUuanM/ZTZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKTplKCl9KChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlLHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSh0PXtleHBvcnRzOnt9fSx0LmV4cG9ydHMpLHQuZXhwb3J0c30oKGZ1bmN0aW9uKGUsdCl7dmFyIHI7d2luZG93LHI9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIG89dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKXIuZChuLG8sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxvKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz00NCl9KFtmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49cigxOSk7T2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJkZWZhdWx0XCIhPT1lJiZcIl9fZXNNb2R1bGVcIiE9PWUmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bZV19fSl9KSl9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMjIpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1yKDI2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNsb3Nlc3RcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaShuKS5kZWZhdWx0fX0pO3ZhciBvPXIoMjQpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicmVxdWVzdE5leHRBbmltYXRpb25GcmFtZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpKG8pLmRlZmF1bHR9fSl9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoNDIpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMzUpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1yKDEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiU2Vuc29yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMobikuZGVmYXVsdH19KTt2YXIgbz1yKDIxKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1vdXNlU2Vuc29yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMobykuZGVmYXVsdH19KTt2YXIgaT1yKDE4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIlRvdWNoU2Vuc29yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMoaSkuZGVmYXVsdH19KTt2YXIgcz1yKDE2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkRyYWdTZW5zb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYyhzKS5kZWZhdWx0fX0pO3ZhciBhPXIoMTQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiRm9yY2VUb3VjaFNlbnNvclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjKGEpLmRlZmF1bHR9fSk7dmFyIGw9cigwKTtmdW5jdGlvbiBjKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1PYmplY3Qua2V5cyhsKS5mb3JFYWNoKChmdW5jdGlvbihlKXtcImRlZmF1bHRcIiE9PWUmJlwiX19lc01vZHVsZVwiIT09ZSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbFtlXX19KX0pKX0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoMzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiQW5ub3VuY2VtZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEobikuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRBbm5vdW5jZW1lbnRPcHRpb25zXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdE9wdGlvbnN9fSk7dmFyIG89cigzNCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJGb2N1c2FibGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYShvKS5kZWZhdWx0fX0pO3ZhciBpPXIoMzIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTWlycm9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEoaSkuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRNaXJyb3JPcHRpb25zXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdE9wdGlvbnN9fSk7dmFyIHM9cigyOCk7ZnVuY3Rpb24gYShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJTY3JvbGxhYmxlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEocykuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRTY3JvbGxhYmxlT3B0aW9uc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHRPcHRpb25zfX0pfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49cigzOCk7T2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJkZWZhdWx0XCIhPT1lJiZcIl9fZXNNb2R1bGVcIiE9PWUmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bZV19fSl9KSl9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1yKDM5KTtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChmdW5jdGlvbihlKXtcImRlZmF1bHRcIiE9PWUmJlwiX19lc01vZHVsZVwiIT09ZSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbltlXX19KX0pKX0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoNDMpO09iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe1wiZGVmYXVsdFwiIT09ZSYmXCJfX2VzTW9kdWxlXCIhPT1lJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2VdfX0pfSkpfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jYWxsYmFja3M9e319b24oZSwuLi50KXtyZXR1cm4gdGhpcy5jYWxsYmFja3NbZV18fCh0aGlzLmNhbGxiYWNrc1tlXT1bXSksdGhpcy5jYWxsYmFja3NbZV0ucHVzaCguLi50KSx0aGlzfW9mZihlLHQpe2lmKCF0aGlzLmNhbGxiYWNrc1tlXSlyZXR1cm4gbnVsbDtjb25zdCByPXRoaXMuY2FsbGJhY2tzW2VdLnNsaWNlKDApO2ZvcihsZXQgbj0wO248ci5sZW5ndGg7bisrKXQ9PT1yW25dJiZ0aGlzLmNhbGxiYWNrc1tlXS5zcGxpY2UobiwxKTtyZXR1cm4gdGhpc310cmlnZ2VyKGUpe2lmKCF0aGlzLmNhbGxiYWNrc1tlLnR5cGVdKXJldHVybiBudWxsO2NvbnN0IHQ9Wy4uLnRoaXMuY2FsbGJhY2tzW2UudHlwZV1dLHI9W107Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pe2NvbnN0IG89dFtuXTt0cnl7byhlKX1jYXRjaChlKXtyLnB1c2goZSl9fXJldHVybiByLmxlbmd0aCYmY29uc29sZS5lcnJvcihgRHJhZ2dhYmxlIGNhdWdodCBlcnJvcnMgd2hpbGUgdHJpZ2dlcmluZyAnJHtlLnR5cGV9J2AsciksdGhpc319fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG4sbz1yKDEwKSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt0LmRlZmF1bHQ9aS5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0T3B0aW9ucz12b2lkIDA7dmFyIG4sbz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1hcmd1bWVudHNbdF07Zm9yKHZhciBuIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbikmJihlW25dPXJbbl0pfXJldHVybiBlfSxpPXIoMikscz1yKDYpLGE9cigxMSksbD0obj1hKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0sYz1yKDUpLHU9cig3KSxkPXIoOCk7Y29uc3QgZz1TeW1ib2woXCJvbkRyYWdTdGFydFwiKSxoPVN5bWJvbChcIm9uRHJhZ01vdmVcIiksZj1TeW1ib2woXCJvbkRyYWdTdG9wXCIpLHY9U3ltYm9sKFwib25EcmFnUHJlc3N1cmVcIiksbT17XCJkcmFnOnN0YXJ0XCI6ZT0+YFBpY2tlZCB1cCAke2Uuc291cmNlLnRleHRDb250ZW50LnRyaW0oKXx8ZS5zb3VyY2UuaWR8fFwiZHJhZ2dhYmxlIGVsZW1lbnRcIn1gLFwiZHJhZzpzdG9wXCI6ZT0+YFJlbGVhc2VkICR7ZS5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpfHxlLnNvdXJjZS5pZHx8XCJkcmFnZ2FibGUgZWxlbWVudFwifWB9LHA9e1wiY29udGFpbmVyOmRyYWdnaW5nXCI6XCJkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZ1wiLFwic291cmNlOmRyYWdnaW5nXCI6XCJkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZ1wiLFwic291cmNlOnBsYWNlZFwiOlwiZHJhZ2dhYmxlLXNvdXJjZS0tcGxhY2VkXCIsXCJjb250YWluZXI6cGxhY2VkXCI6XCJkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWRcIixcImJvZHk6ZHJhZ2dpbmdcIjpcImRyYWdnYWJsZS0taXMtZHJhZ2dpbmdcIixcImRyYWdnYWJsZTpvdmVyXCI6XCJkcmFnZ2FibGUtLW92ZXJcIixcImNvbnRhaW5lcjpvdmVyXCI6XCJkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyXCIsXCJzb3VyY2U6b3JpZ2luYWxcIjpcImRyYWdnYWJsZS0tb3JpZ2luYWxcIixtaXJyb3I6XCJkcmFnZ2FibGUtbWlycm9yXCJ9LGI9dC5kZWZhdWx0T3B0aW9ucz17ZHJhZ2dhYmxlOlwiLmRyYWdnYWJsZS1zb3VyY2VcIixoYW5kbGU6bnVsbCxkZWxheToxMDAscGxhY2VkVGltZW91dDo4MDAscGx1Z2luczpbXSxzZW5zb3JzOltdfTtjbGFzcyBFe2NvbnN0cnVjdG9yKGU9W2RvY3VtZW50LmJvZHldLHQ9e30pe2lmKGUgaW5zdGFuY2VvZiBOb2RlTGlzdHx8ZSBpbnN0YW5jZW9mIEFycmF5KXRoaXMuY29udGFpbmVycz1bLi4uZV07ZWxzZXtpZighKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpdGhyb3cgbmV3IEVycm9yKFwiRHJhZ2dhYmxlIGNvbnRhaW5lcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYE5vZGVMaXN0YCwgYEhUTUxFbGVtZW50W11gIG9yIGBIVE1MRWxlbWVudGBcIik7dGhpcy5jb250YWluZXJzPVtlXX10aGlzLm9wdGlvbnM9byh7fSxiLHQse2NsYXNzZXM6byh7fSxwLHQuY2xhc3Nlc3x8e30pLGFubm91bmNlbWVudHM6byh7fSxtLHQuYW5ub3VuY2VtZW50c3x8e30pfSksdGhpcy5lbWl0dGVyPW5ldyBsLmRlZmF1bHQsdGhpcy5kcmFnZ2luZz0hMSx0aGlzLnBsdWdpbnM9W10sdGhpcy5zZW5zb3JzPVtdLHRoaXNbZ109dGhpc1tnXS5iaW5kKHRoaXMpLHRoaXNbaF09dGhpc1toXS5iaW5kKHRoaXMpLHRoaXNbZl09dGhpc1tmXS5iaW5kKHRoaXMpLHRoaXNbdl09dGhpc1t2XS5iaW5kKHRoaXMpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnOnN0YXJ0XCIsdGhpc1tnXSwhMCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWc6bW92ZVwiLHRoaXNbaF0sITApLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnOnN0b3BcIix0aGlzW2ZdLCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZzpwcmVzc3VyZVwiLHRoaXNbdl0sITApO2NvbnN0IHI9T2JqZWN0LnZhbHVlcyhFLlBsdWdpbnMpLm1hcChlPT5lKSxuPVtjLk1vdXNlU2Vuc29yLGMuVG91Y2hTZW5zb3JdO3RoaXMuYWRkUGx1Z2luKC4uLnIsLi4udGhpcy5vcHRpb25zLnBsdWdpbnMpLHRoaXMuYWRkU2Vuc29yKC4uLm4sLi4udGhpcy5vcHRpb25zLnNlbnNvcnMpO2NvbnN0IGk9bmV3IHUuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCh7ZHJhZ2dhYmxlOnRoaXN9KTt0aGlzLm9uKFwibWlycm9yOmNyZWF0ZWRcIiwoe21pcnJvcjplfSk9PnRoaXMubWlycm9yPWUpLHRoaXMub24oXCJtaXJyb3I6ZGVzdHJveVwiLCgpPT50aGlzLm1pcnJvcj1udWxsKSx0aGlzLnRyaWdnZXIoaSl9ZGVzdHJveSgpe2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnOnN0YXJ0XCIsdGhpc1tnXSwhMCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWc6bW92ZVwiLHRoaXNbaF0sITApLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnOnN0b3BcIix0aGlzW2ZdLCEwKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZzpwcmVzc3VyZVwiLHRoaXNbdl0sITApO2NvbnN0IGU9bmV3IHUuRHJhZ2dhYmxlRGVzdHJveUV2ZW50KHtkcmFnZ2FibGU6dGhpc30pO3RoaXMudHJpZ2dlcihlKSx0aGlzLnJlbW92ZVBsdWdpbiguLi50aGlzLnBsdWdpbnMubWFwKGU9PmUuY29uc3RydWN0b3IpKSx0aGlzLnJlbW92ZVNlbnNvciguLi50aGlzLnNlbnNvcnMubWFwKGU9PmUuY29uc3RydWN0b3IpKX1hZGRQbHVnaW4oLi4uZSl7Y29uc3QgdD1lLm1hcChlPT5uZXcgZSh0aGlzKSk7cmV0dXJuIHQuZm9yRWFjaChlPT5lLmF0dGFjaCgpKSx0aGlzLnBsdWdpbnM9Wy4uLnRoaXMucGx1Z2lucywuLi50XSx0aGlzfXJlbW92ZVBsdWdpbiguLi5lKXtyZXR1cm4gdGhpcy5wbHVnaW5zLmZpbHRlcih0PT5lLmluY2x1ZGVzKHQuY29uc3RydWN0b3IpKS5mb3JFYWNoKGU9PmUuZGV0YWNoKCkpLHRoaXMucGx1Z2lucz10aGlzLnBsdWdpbnMuZmlsdGVyKHQ9PiFlLmluY2x1ZGVzKHQuY29uc3RydWN0b3IpKSx0aGlzfWFkZFNlbnNvciguLi5lKXtjb25zdCB0PWUubWFwKGU9Pm5ldyBlKHRoaXMuY29udGFpbmVycyx0aGlzLm9wdGlvbnMpKTtyZXR1cm4gdC5mb3JFYWNoKGU9PmUuYXR0YWNoKCkpLHRoaXMuc2Vuc29ycz1bLi4udGhpcy5zZW5zb3JzLC4uLnRdLHRoaXN9cmVtb3ZlU2Vuc29yKC4uLmUpe3JldHVybiB0aGlzLnNlbnNvcnMuZmlsdGVyKHQ9PmUuaW5jbHVkZXModC5jb25zdHJ1Y3RvcikpLmZvckVhY2goZT0+ZS5kZXRhY2goKSksdGhpcy5zZW5zb3JzPXRoaXMuc2Vuc29ycy5maWx0ZXIodD0+IWUuaW5jbHVkZXModC5jb25zdHJ1Y3RvcikpLHRoaXN9YWRkQ29udGFpbmVyKC4uLmUpe3JldHVybiB0aGlzLmNvbnRhaW5lcnM9Wy4uLnRoaXMuY29udGFpbmVycywuLi5lXSx0aGlzLnNlbnNvcnMuZm9yRWFjaCh0PT50LmFkZENvbnRhaW5lciguLi5lKSksdGhpc31yZW1vdmVDb250YWluZXIoLi4uZSl7cmV0dXJuIHRoaXMuY29udGFpbmVycz10aGlzLmNvbnRhaW5lcnMuZmlsdGVyKHQ9PiFlLmluY2x1ZGVzKHQpKSx0aGlzLnNlbnNvcnMuZm9yRWFjaCh0PT50LnJlbW92ZUNvbnRhaW5lciguLi5lKSksdGhpc31vbihlLC4uLnQpe3JldHVybiB0aGlzLmVtaXR0ZXIub24oZSwuLi50KSx0aGlzfW9mZihlLHQpe3JldHVybiB0aGlzLmVtaXR0ZXIub2ZmKGUsdCksdGhpc310cmlnZ2VyKGUpe3JldHVybiB0aGlzLmVtaXR0ZXIudHJpZ2dlcihlKSx0aGlzfWdldENsYXNzTmFtZUZvcihlKXtyZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzZXNbZV19aXNEcmFnZ2luZygpe3JldHVybiBCb29sZWFuKHRoaXMuZHJhZ2dpbmcpfWdldERyYWdnYWJsZUVsZW1lbnRzKCl7cmV0dXJuIHRoaXMuY29udGFpbmVycy5yZWR1Y2UoKGUsdCk9PlsuLi5lLC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIodCldLFtdKX1nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihlKXtyZXR1cm5bLi4uZS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpXS5maWx0ZXIoZT0+ZSE9PXRoaXMub3JpZ2luYWxTb3VyY2UmJmUhPT10aGlzLm1pcnJvcil9W2ddKGUpe2NvbnN0IHQ9eShlKSx7dGFyZ2V0OnIsY29udGFpbmVyOm59PXQ7aWYoIXRoaXMuY29udGFpbmVycy5pbmNsdWRlcyhuKSlyZXR1cm47aWYodGhpcy5vcHRpb25zLmhhbmRsZSYmciYmISgwLGkuY2xvc2VzdCkocix0aGlzLm9wdGlvbnMuaGFuZGxlKSlyZXR1cm4gdm9pZCB0LmNhbmNlbCgpO2lmKHRoaXMub3JpZ2luYWxTb3VyY2U9KDAsaS5jbG9zZXN0KShyLHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpLHRoaXMuc291cmNlQ29udGFpbmVyPW4sIXRoaXMub3JpZ2luYWxTb3VyY2UpcmV0dXJuIHZvaWQgdC5jYW5jZWwoKTt0aGlzLmxhc3RQbGFjZWRTb3VyY2UmJnRoaXMubGFzdFBsYWNlZENvbnRhaW5lciYmKGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCksdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJzb3VyY2U6cGxhY2VkXCIpKSx0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcihcImNvbnRhaW5lcjpwbGFjZWRcIikpKSx0aGlzLnNvdXJjZT10aGlzLm9yaWdpbmFsU291cmNlLmNsb25lTm9kZSghMCksdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSx0aGlzLm9yaWdpbmFsU291cmNlKSx0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7Y29uc3Qgcz1uZXcgZC5EcmFnU3RhcnRFdmVudCh7c291cmNlOnRoaXMuc291cmNlLG9yaWdpbmFsU291cmNlOnRoaXMub3JpZ2luYWxTb3VyY2Usc291cmNlQ29udGFpbmVyOm4sc2Vuc29yRXZlbnQ6dH0pO2lmKHRoaXMudHJpZ2dlcihzKSx0aGlzLmRyYWdnaW5nPSFzLmNhbmNlbGVkKCkscy5jYW5jZWxlZCgpKXJldHVybiB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKSx2b2lkKHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheT1udWxsKTt0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJzb3VyY2U6b3JpZ2luYWxcIikpLHRoaXMuc291cmNlLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJzb3VyY2U6ZHJhZ2dpbmdcIikpLHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJjb250YWluZXI6ZHJhZ2dpbmdcIikpLGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcihcImJvZHk6ZHJhZ2dpbmdcIikpLFMoZG9jdW1lbnQuYm9keSxcIm5vbmVcIikscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57Y29uc3QgdD15KGUpLmNsb25lKHt0YXJnZXQ6dGhpcy5zb3VyY2V9KTt0aGlzW2hdKG8oe30sZSx7ZGV0YWlsOnR9KSl9KX1baF0oZSl7aWYoIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO2NvbnN0IHQ9eShlKSx7Y29udGFpbmVyOnJ9PXQ7bGV0IG49dC50YXJnZXQ7Y29uc3Qgbz1uZXcgZC5EcmFnTW92ZUV2ZW50KHtzb3VyY2U6dGhpcy5zb3VyY2Usb3JpZ2luYWxTb3VyY2U6dGhpcy5vcmlnaW5hbFNvdXJjZSxzb3VyY2VDb250YWluZXI6cixzZW5zb3JFdmVudDp0fSk7dGhpcy50cmlnZ2VyKG8pLG8uY2FuY2VsZWQoKSYmdC5jYW5jZWwoKSxuPSgwLGkuY2xvc2VzdCkobix0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtjb25zdCBzPSgwLGkuY2xvc2VzdCkodC50YXJnZXQsdGhpcy5jb250YWluZXJzKSxhPXQub3ZlckNvbnRhaW5lcnx8cyxsPXRoaXMuY3VycmVudE92ZXJDb250YWluZXImJmEhPT10aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLGM9dGhpcy5jdXJyZW50T3ZlciYmbiE9PXRoaXMuY3VycmVudE92ZXIsdT1hJiZ0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyIT09YSxnPXMmJm4mJnRoaXMuY3VycmVudE92ZXIhPT1uO2lmKGMpe2NvbnN0IGU9bmV3IGQuRHJhZ091dEV2ZW50KHtzb3VyY2U6dGhpcy5zb3VyY2Usb3JpZ2luYWxTb3VyY2U6dGhpcy5vcmlnaW5hbFNvdXJjZSxzb3VyY2VDb250YWluZXI6cixzZW5zb3JFdmVudDp0LG92ZXI6dGhpcy5jdXJyZW50T3Zlcn0pO3RoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcihcImRyYWdnYWJsZTpvdmVyXCIpKSx0aGlzLmN1cnJlbnRPdmVyPW51bGwsdGhpcy50cmlnZ2VyKGUpfWlmKGwpe2NvbnN0IGU9bmV3IGQuRHJhZ091dENvbnRhaW5lckV2ZW50KHtzb3VyY2U6dGhpcy5zb3VyY2Usb3JpZ2luYWxTb3VyY2U6dGhpcy5vcmlnaW5hbFNvdXJjZSxzb3VyY2VDb250YWluZXI6cixzZW5zb3JFdmVudDp0LG92ZXJDb250YWluZXI6dGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcn0pO3RoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcihcImNvbnRhaW5lcjpvdmVyXCIpKSx0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyPW51bGwsdGhpcy50cmlnZ2VyKGUpfWlmKHUpe2EuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcihcImNvbnRhaW5lcjpvdmVyXCIpKTtjb25zdCBlPW5ldyBkLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQoe3NvdXJjZTp0aGlzLnNvdXJjZSxvcmlnaW5hbFNvdXJjZTp0aGlzLm9yaWdpbmFsU291cmNlLHNvdXJjZUNvbnRhaW5lcjpyLHNlbnNvckV2ZW50OnQsb3ZlckNvbnRhaW5lcjphfSk7dGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcj1hLHRoaXMudHJpZ2dlcihlKX1pZihnKXtuLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJkcmFnZ2FibGU6b3ZlclwiKSk7Y29uc3QgZT1uZXcgZC5EcmFnT3ZlckV2ZW50KHtzb3VyY2U6dGhpcy5zb3VyY2Usb3JpZ2luYWxTb3VyY2U6dGhpcy5vcmlnaW5hbFNvdXJjZSxzb3VyY2VDb250YWluZXI6cixzZW5zb3JFdmVudDp0LG92ZXJDb250YWluZXI6YSxvdmVyOm59KTt0aGlzLmN1cnJlbnRPdmVyPW4sdGhpcy50cmlnZ2VyKGUpfX1bZl0oZSl7aWYoIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO3RoaXMuZHJhZ2dpbmc9ITE7Y29uc3QgdD1uZXcgZC5EcmFnU3RvcEV2ZW50KHtzb3VyY2U6dGhpcy5zb3VyY2Usb3JpZ2luYWxTb3VyY2U6dGhpcy5vcmlnaW5hbFNvdXJjZSxzZW5zb3JFdmVudDplLnNlbnNvckV2ZW50LHNvdXJjZUNvbnRhaW5lcjp0aGlzLnNvdXJjZUNvbnRhaW5lcn0pO3RoaXMudHJpZ2dlcih0KSx0aGlzLnNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm9yaWdpbmFsU291cmNlLHRoaXMuc291cmNlKSx0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKSx0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXk9XCJcIix0aGlzLnNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKFwic291cmNlOmRyYWdnaW5nXCIpKSx0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJzb3VyY2U6b3JpZ2luYWxcIikpLHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcihcInNvdXJjZTpwbGFjZWRcIikpLHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJjb250YWluZXI6cGxhY2VkXCIpKSx0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKFwiY29udGFpbmVyOmRyYWdnaW5nXCIpKSxkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJib2R5OmRyYWdnaW5nXCIpKSxTKGRvY3VtZW50LmJvZHksXCJcIiksdGhpcy5jdXJyZW50T3ZlciYmdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKFwiZHJhZ2dhYmxlOm92ZXJcIikpLHRoaXMuY3VycmVudE92ZXJDb250YWluZXImJnRoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcihcImNvbnRhaW5lcjpvdmVyXCIpKSx0aGlzLmxhc3RQbGFjZWRTb3VyY2U9dGhpcy5vcmlnaW5hbFNvdXJjZSx0aGlzLmxhc3RQbGFjZWRDb250YWluZXI9dGhpcy5zb3VyY2VDb250YWluZXIsdGhpcy5wbGFjZWRUaW1lb3V0SUQ9c2V0VGltZW91dCgoKT0+e3RoaXMubGFzdFBsYWNlZFNvdXJjZSYmdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoXCJzb3VyY2U6cGxhY2VkXCIpKSx0aGlzLmxhc3RQbGFjZWRDb250YWluZXImJnRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKFwiY29udGFpbmVyOnBsYWNlZFwiKSksdGhpcy5sYXN0UGxhY2VkU291cmNlPW51bGwsdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyPW51bGx9LHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KSx0aGlzLnNvdXJjZT1udWxsLHRoaXMub3JpZ2luYWxTb3VyY2U9bnVsbCx0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyPW51bGwsdGhpcy5jdXJyZW50T3Zlcj1udWxsLHRoaXMuc291cmNlQ29udGFpbmVyPW51bGx9W3ZdKGUpe2lmKCF0aGlzLmRyYWdnaW5nKXJldHVybjtjb25zdCB0PXkoZSkscj10aGlzLnNvdXJjZXx8KDAsaS5jbG9zZXN0KSh0Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpLG49bmV3IGQuRHJhZ1ByZXNzdXJlRXZlbnQoe3NlbnNvckV2ZW50OnQsc291cmNlOnIscHJlc3N1cmU6dC5wcmVzc3VyZX0pO3RoaXMudHJpZ2dlcihuKX19ZnVuY3Rpb24geShlKXtyZXR1cm4gZS5kZXRhaWx9ZnVuY3Rpb24gUyhlLHQpe2Uuc3R5bGUud2Via2l0VXNlclNlbGVjdD10LGUuc3R5bGUubW96VXNlclNlbGVjdD10LGUuc3R5bGUubXNVc2VyU2VsZWN0PXQsZS5zdHlsZS5vVXNlclNlbGVjdD10LGUuc3R5bGUudXNlclNlbGVjdD10fXQuZGVmYXVsdD1FLEUuUGx1Z2lucz17QW5ub3VuY2VtZW50OnMuQW5ub3VuY2VtZW50LEZvY3VzYWJsZTpzLkZvY3VzYWJsZSxNaXJyb3I6cy5NaXJyb3IsU2Nyb2xsYWJsZTpzLlNjcm9sbGFibGV9fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG4sbz1yKDEpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigwKTtjb25zdCBhPVN5bWJvbChcIm9uTW91c2VGb3JjZVdpbGxCZWdpblwiKSxsPVN5bWJvbChcIm9uTW91c2VGb3JjZURvd25cIiksYz1TeW1ib2woXCJvbk1vdXNlRG93blwiKSx1PVN5bWJvbChcIm9uTW91c2VGb3JjZUNoYW5nZVwiKSxkPVN5bWJvbChcIm9uTW91c2VNb3ZlXCIpLGc9U3ltYm9sKFwib25Nb3VzZVVwXCIpLGg9U3ltYm9sKFwib25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlXCIpO2NsYXNzIGYgZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IoZT1bXSx0PXt9KXtzdXBlcihlLHQpLHRoaXMubWlnaHREcmFnPSExLHRoaXNbYV09dGhpc1thXS5iaW5kKHRoaXMpLHRoaXNbbF09dGhpc1tsXS5iaW5kKHRoaXMpLHRoaXNbY109dGhpc1tjXS5iaW5kKHRoaXMpLHRoaXNbdV09dGhpc1t1XS5iaW5kKHRoaXMpLHRoaXNbZF09dGhpc1tkXS5iaW5kKHRoaXMpLHRoaXNbZ109dGhpc1tnXS5iaW5kKHRoaXMpfWF0dGFjaCgpe2Zvcihjb25zdCBlIG9mIHRoaXMuY29udGFpbmVycyllLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luXCIsdGhpc1thXSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0bW91c2Vmb3JjZWRvd25cIix0aGlzW2xdLCExKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzW2NdLCEwKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZFwiLHRoaXNbdV0sITEpO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzW2RdKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXNbZ10pfWRldGFjaCgpe2Zvcihjb25zdCBlIG9mIHRoaXMuY29udGFpbmVycyllLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luXCIsdGhpc1thXSwhMSksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0bW91c2Vmb3JjZWRvd25cIix0aGlzW2xdLCExKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzW2NdLCEwKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZFwiLHRoaXNbdV0sITEpO2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzW2RdKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXNbZ10pfVthXShlKXtlLnByZXZlbnREZWZhdWx0KCksdGhpcy5taWdodERyYWc9ITB9W2xdKGUpe2lmKHRoaXMuZHJhZ2dpbmcpcmV0dXJuO2NvbnN0IHQ9ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsZS5jbGllbnRZKSxyPWUuY3VycmVudFRhcmdldCxuPW5ldyBzLkRyYWdTdGFydFNlbnNvckV2ZW50KHtjbGllbnRYOmUuY2xpZW50WCxjbGllbnRZOmUuY2xpZW50WSx0YXJnZXQ6dCxjb250YWluZXI6cixvcmlnaW5hbEV2ZW50OmV9KTt0aGlzLnRyaWdnZXIocixuKSx0aGlzLmN1cnJlbnRDb250YWluZXI9cix0aGlzLmRyYWdnaW5nPSFuLmNhbmNlbGVkKCksdGhpcy5taWdodERyYWc9ITF9W2ddKGUpe2lmKCF0aGlzLmRyYWdnaW5nKXJldHVybjtjb25zdCB0PW5ldyBzLkRyYWdTdG9wU2Vuc29yRXZlbnQoe2NsaWVudFg6ZS5jbGllbnRYLGNsaWVudFk6ZS5jbGllbnRZLHRhcmdldDpudWxsLGNvbnRhaW5lcjp0aGlzLmN1cnJlbnRDb250YWluZXIsb3JpZ2luYWxFdmVudDplfSk7dGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lcix0KSx0aGlzLmN1cnJlbnRDb250YWluZXI9bnVsbCx0aGlzLmRyYWdnaW5nPSExLHRoaXMubWlnaHREcmFnPSExfVtjXShlKXt0aGlzLm1pZ2h0RHJhZyYmKGUuc3RvcFByb3BhZ2F0aW9uKCksZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCkpfVtkXShlKXtpZighdGhpcy5kcmFnZ2luZylyZXR1cm47Y29uc3QgdD1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCxlLmNsaWVudFkpLHI9bmV3IHMuRHJhZ01vdmVTZW5zb3JFdmVudCh7Y2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnRoaXMuY3VycmVudENvbnRhaW5lcixvcmlnaW5hbEV2ZW50OmV9KTt0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLHIpfVt1XShlKXtpZih0aGlzLmRyYWdnaW5nKXJldHVybjtjb25zdCB0PWUudGFyZ2V0LHI9ZS5jdXJyZW50VGFyZ2V0LG49bmV3IHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe3ByZXNzdXJlOmUud2Via2l0Rm9yY2UsY2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnIsb3JpZ2luYWxFdmVudDplfSk7dGhpcy50cmlnZ2VyKHIsbil9W2hdKGUpe2lmKCF0aGlzLmRyYWdnaW5nKXJldHVybjtjb25zdCB0PWUudGFyZ2V0LHI9bmV3IHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe3ByZXNzdXJlOmUud2Via2l0Rm9yY2UsY2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnRoaXMuY3VycmVudENvbnRhaW5lcixvcmlnaW5hbEV2ZW50OmV9KTt0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLHIpfX10LmRlZmF1bHQ9Zn0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89cigxMyksaT0obj1vKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dC5kZWZhdWx0PWkuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89cigyKSxpPXIoMSkscz0obj1pKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0sYT1yKDApO2NvbnN0IGw9U3ltYm9sKFwib25Nb3VzZURvd25cIiksYz1TeW1ib2woXCJvbk1vdXNlVXBcIiksdT1TeW1ib2woXCJvbkRyYWdTdGFydFwiKSxkPVN5bWJvbChcIm9uRHJhZ092ZXJcIiksZz1TeW1ib2woXCJvbkRyYWdFbmRcIiksaD1TeW1ib2woXCJvbkRyb3BcIiksZj1TeW1ib2woXCJyZXNldFwiKTtjbGFzcyB2IGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGU9W10sdD17fSl7c3VwZXIoZSx0KSx0aGlzLm1vdXNlRG93blRpbWVvdXQ9bnVsbCx0aGlzLmRyYWdnYWJsZUVsZW1lbnQ9bnVsbCx0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ9bnVsbCx0aGlzW2xdPXRoaXNbbF0uYmluZCh0aGlzKSx0aGlzW2NdPXRoaXNbY10uYmluZCh0aGlzKSx0aGlzW3VdPXRoaXNbdV0uYmluZCh0aGlzKSx0aGlzW2RdPXRoaXNbZF0uYmluZCh0aGlzKSx0aGlzW2ddPXRoaXNbZ10uYmluZCh0aGlzKSx0aGlzW2hdPXRoaXNbaF0uYmluZCh0aGlzKX1hdHRhY2goKXtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpc1tsXSwhMCl9ZGV0YWNoKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXNbbF0sITApfVt1XShlKXtlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLFwiXCIpLGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ9dGhpcy5vcHRpb25zLnR5cGU7Y29uc3QgdD1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCxlLmNsaWVudFkpO2lmKHRoaXMuY3VycmVudENvbnRhaW5lcj0oMCxvLmNsb3Nlc3QpKGUudGFyZ2V0LHRoaXMuY29udGFpbmVycyksIXRoaXMuY3VycmVudENvbnRhaW5lcilyZXR1cm47Y29uc3Qgcj1uZXcgYS5EcmFnU3RhcnRTZW5zb3JFdmVudCh7Y2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnRoaXMuY3VycmVudENvbnRhaW5lcixvcmlnaW5hbEV2ZW50OmV9KTtzZXRUaW1lb3V0KCgpPT57dGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lcixyKSxyLmNhbmNlbGVkKCk/dGhpcy5kcmFnZ2luZz0hMTp0aGlzLmRyYWdnaW5nPSEwfSwwKX1bZF0oZSl7aWYoIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO2NvbnN0IHQ9ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsZS5jbGllbnRZKSxyPXRoaXMuY3VycmVudENvbnRhaW5lcixuPW5ldyBhLkRyYWdNb3ZlU2Vuc29yRXZlbnQoe2NsaWVudFg6ZS5jbGllbnRYLGNsaWVudFk6ZS5jbGllbnRZLHRhcmdldDp0LGNvbnRhaW5lcjpyLG9yaWdpbmFsRXZlbnQ6ZX0pO3RoaXMudHJpZ2dlcihyLG4pLG4uY2FuY2VsZWQoKXx8KGUucHJldmVudERlZmF1bHQoKSxlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0PXRoaXMub3B0aW9ucy50eXBlKX1bZ10oZSl7aWYoIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpc1tjXSwhMCk7Y29uc3QgdD1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCxlLmNsaWVudFkpLHI9dGhpcy5jdXJyZW50Q29udGFpbmVyLG49bmV3IGEuRHJhZ1N0b3BTZW5zb3JFdmVudCh7Y2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnIsb3JpZ2luYWxFdmVudDplfSk7dGhpcy50cmlnZ2VyKHIsbiksdGhpcy5kcmFnZ2luZz0hMSx0aGlzW2ZdKCl9W2hdKGUpe2UucHJldmVudERlZmF1bHQoKX1bbF0oZSl7aWYoZS50YXJnZXQmJihlLnRhcmdldC5mb3JtfHxlLnRhcmdldC5jb250ZW50ZWRpdGFibGUpKXJldHVybjtjb25zdCB0PSgwLG8uY2xvc2VzdCkoZS50YXJnZXQsZT0+ZS5kcmFnZ2FibGUpO3QmJih0LmRyYWdnYWJsZT0hMSx0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ9dCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzW2NdLCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsdGhpc1t1XSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsdGhpc1tkXSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIix0aGlzW2ddLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLHRoaXNbaF0sITEpO2NvbnN0IHI9KDAsby5jbG9zZXN0KShlLnRhcmdldCx0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtyJiYodGhpcy5tb3VzZURvd25UaW1lb3V0PXNldFRpbWVvdXQoKCk9PntyLmRyYWdnYWJsZT0hMCx0aGlzLmRyYWdnYWJsZUVsZW1lbnQ9cn0sdGhpcy5vcHRpb25zLmRlbGF5KSl9W2NdKCl7dGhpc1tmXSgpfVtmXSgpe2NsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpc1tjXSwhMCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLHRoaXNbdV0sITEpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLHRoaXNbZF0sITEpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsdGhpc1tnXSwhMSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyb3BcIix0aGlzW2hdLCExKSx0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQmJih0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlPSEwLHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudD1udWxsKSx0aGlzLmRyYWdnYWJsZUVsZW1lbnQmJih0aGlzLmRyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlPSExLHRoaXMuZHJhZ2dhYmxlRWxlbWVudD1udWxsKX19dC5kZWZhdWx0PXZ9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMTUpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMiksaT1yKDEpLHM9KG49aSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LGE9cigwKTtjb25zdCBsPVN5bWJvbChcIm9uVG91Y2hTdGFydFwiKSxjPVN5bWJvbChcIm9uVG91Y2hIb2xkXCIpLHU9U3ltYm9sKFwib25Ub3VjaEVuZFwiKSxkPVN5bWJvbChcIm9uVG91Y2hNb3ZlXCIpO2xldCBnPSExO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZT0+e2cmJmUucHJldmVudERlZmF1bHQoKX0se3Bhc3NpdmU6ITF9KTtjbGFzcyBoIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGU9W10sdD17fSl7c3VwZXIoZSx0KSx0aGlzLmN1cnJlbnRTY3JvbGxhYmxlUGFyZW50PW51bGwsdGhpcy50YXBUaW1lb3V0PW51bGwsdGhpcy50b3VjaE1vdmVkPSExLHRoaXNbbF09dGhpc1tsXS5iaW5kKHRoaXMpLHRoaXNbY109dGhpc1tjXS5iaW5kKHRoaXMpLHRoaXNbdV09dGhpc1t1XS5iaW5kKHRoaXMpLHRoaXNbZF09dGhpc1tkXS5iaW5kKHRoaXMpfWF0dGFjaCgpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpc1tsXSl9ZGV0YWNoKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzW2xdKX1bbF0oZSl7Y29uc3QgdD0oMCxvLmNsb3Nlc3QpKGUudGFyZ2V0LHRoaXMuY29udGFpbmVycyk7dCYmKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzW2RdKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzW3VdKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIix0aGlzW3VdKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLGYpLHRoaXMuY3VycmVudENvbnRhaW5lcj10LHRoaXMudGFwVGltZW91dD1zZXRUaW1lb3V0KHRoaXNbY10oZSx0KSx0aGlzLm9wdGlvbnMuZGVsYXkpKX1bY10oZSx0KXtyZXR1cm4oKT0+e2lmKHRoaXMudG91Y2hNb3ZlZClyZXR1cm47Y29uc3Qgcj1lLnRvdWNoZXNbMF18fGUuY2hhbmdlZFRvdWNoZXNbMF0sbj1lLnRhcmdldCxvPW5ldyBhLkRyYWdTdGFydFNlbnNvckV2ZW50KHtjbGllbnRYOnIucGFnZVgsY2xpZW50WTpyLnBhZ2VZLHRhcmdldDpuLGNvbnRhaW5lcjp0LG9yaWdpbmFsRXZlbnQ6ZX0pO3RoaXMudHJpZ2dlcih0LG8pLHRoaXMuZHJhZ2dpbmc9IW8uY2FuY2VsZWQoKSxnPXRoaXMuZHJhZ2dpbmd9fVtkXShlKXtpZih0aGlzLnRvdWNoTW92ZWQ9ITAsIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO2NvbnN0IHQ9ZS50b3VjaGVzWzBdfHxlLmNoYW5nZWRUb3VjaGVzWzBdLHI9ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0LnBhZ2VYLXdpbmRvdy5zY3JvbGxYLHQucGFnZVktd2luZG93LnNjcm9sbFkpLG49bmV3IGEuRHJhZ01vdmVTZW5zb3JFdmVudCh7Y2xpZW50WDp0LnBhZ2VYLGNsaWVudFk6dC5wYWdlWSx0YXJnZXQ6cixjb250YWluZXI6dGhpcy5jdXJyZW50Q29udGFpbmVyLG9yaWdpbmFsRXZlbnQ6ZX0pO3RoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsbil9W3VdKGUpe2lmKHRoaXMudG91Y2hNb3ZlZD0hMSxnPSExLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXNbdV0pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLHRoaXNbdV0pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzW2RdKSx0aGlzLmN1cnJlbnRDb250YWluZXImJnRoaXMuY3VycmVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIixmKSxjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KSwhdGhpcy5kcmFnZ2luZylyZXR1cm47Y29uc3QgdD1lLnRvdWNoZXNbMF18fGUuY2hhbmdlZFRvdWNoZXNbMF0scj1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHQucGFnZVgtd2luZG93LnNjcm9sbFgsdC5wYWdlWS13aW5kb3cuc2Nyb2xsWSk7ZS5wcmV2ZW50RGVmYXVsdCgpO2NvbnN0IG49bmV3IGEuRHJhZ1N0b3BTZW5zb3JFdmVudCh7Y2xpZW50WDp0LnBhZ2VYLGNsaWVudFk6dC5wYWdlWSx0YXJnZXQ6cixjb250YWluZXI6dGhpcy5jdXJyZW50Q29udGFpbmVyLG9yaWdpbmFsRXZlbnQ6ZX0pO3RoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsbiksdGhpcy5jdXJyZW50Q29udGFpbmVyPW51bGwsdGhpcy5kcmFnZ2luZz0hMX19ZnVuY3Rpb24gZihlKXtlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKX10LmRlZmF1bHQ9aH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89cigxNyksaT0obj1vKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dC5kZWZhdWx0PWkuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ9dC5EcmFnU3RvcFNlbnNvckV2ZW50PXQuRHJhZ01vdmVTZW5zb3JFdmVudD10LkRyYWdTdGFydFNlbnNvckV2ZW50PXQuU2Vuc29yRXZlbnQ9dm9pZCAwO3ZhciBuLG89cigzKSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtjbGFzcyBzIGV4dGVuZHMgaS5kZWZhdWx0e2dldCBvcmlnaW5hbEV2ZW50KCl7cmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbEV2ZW50fWdldCBjbGllbnRYKCl7cmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYfWdldCBjbGllbnRZKCl7cmV0dXJuIHRoaXMuZGF0YS5jbGllbnRZfWdldCB0YXJnZXQoKXtyZXR1cm4gdGhpcy5kYXRhLnRhcmdldH1nZXQgY29udGFpbmVyKCl7cmV0dXJuIHRoaXMuZGF0YS5jb250YWluZXJ9Z2V0IHByZXNzdXJlKCl7cmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZX19dC5TZW5zb3JFdmVudD1zO2NsYXNzIGEgZXh0ZW5kcyBze310LkRyYWdTdGFydFNlbnNvckV2ZW50PWEsYS50eXBlPVwiZHJhZzpzdGFydFwiO2NsYXNzIGwgZXh0ZW5kcyBze310LkRyYWdNb3ZlU2Vuc29yRXZlbnQ9bCxsLnR5cGU9XCJkcmFnOm1vdmVcIjtjbGFzcyBjIGV4dGVuZHMgc3t9dC5EcmFnU3RvcFNlbnNvckV2ZW50PWMsYy50eXBlPVwiZHJhZzpzdG9wXCI7Y2xhc3MgdSBleHRlbmRzIHN7fXQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ9dSx1LnR5cGU9XCJkcmFnOnByZXNzdXJlXCJ9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMiksaT1yKDEpLHM9KG49aSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LGE9cigwKTtjb25zdCBsPVN5bWJvbChcIm9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXCIpLGM9U3ltYm9sKFwib25Nb3VzZURvd25cIiksdT1TeW1ib2woXCJvbk1vdXNlTW92ZVwiKSxkPVN5bWJvbChcIm9uTW91c2VVcFwiKTtjbGFzcyBnIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGU9W10sdD17fSl7c3VwZXIoZSx0KSx0aGlzLm1vdXNlRG93bj0hMSx0aGlzLm1vdXNlRG93blRpbWVvdXQ9bnVsbCx0aGlzLm9wZW5lZENvbnRleHRNZW51PSExLHRoaXNbbF09dGhpc1tsXS5iaW5kKHRoaXMpLHRoaXNbY109dGhpc1tjXS5iaW5kKHRoaXMpLHRoaXNbdV09dGhpc1t1XS5iaW5kKHRoaXMpLHRoaXNbZF09dGhpc1tkXS5iaW5kKHRoaXMpfWF0dGFjaCgpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzW2NdLCEwKX1kZXRhY2goKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpc1tjXSwhMCl9W2NdKGUpe2lmKDAhPT1lLmJ1dHRvbnx8ZS5jdHJsS2V5fHxlLm1ldGFLZXkpcmV0dXJuO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpc1tkXSk7Y29uc3QgdD1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCxlLmNsaWVudFkpLHI9KDAsby5jbG9zZXN0KSh0LHRoaXMuY29udGFpbmVycyk7ciYmKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIixoKSx0aGlzLm1vdXNlRG93bj0hMCxjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KSx0aGlzLm1vdXNlRG93blRpbWVvdXQ9c2V0VGltZW91dCgoKT0+e2lmKCF0aGlzLm1vdXNlRG93bilyZXR1cm47Y29uc3Qgbj1uZXcgYS5EcmFnU3RhcnRTZW5zb3JFdmVudCh7Y2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFksdGFyZ2V0OnQsY29udGFpbmVyOnIsb3JpZ2luYWxFdmVudDplfSk7dGhpcy50cmlnZ2VyKHIsbiksdGhpcy5jdXJyZW50Q29udGFpbmVyPXIsdGhpcy5kcmFnZ2luZz0hbi5jYW5jZWxlZCgpLHRoaXMuZHJhZ2dpbmcmJihkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIix0aGlzW2xdKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpc1t1XSkpfSx0aGlzLm9wdGlvbnMuZGVsYXkpKX1bdV0oZSl7aWYoIXRoaXMuZHJhZ2dpbmcpcmV0dXJuO2NvbnN0IHQ9ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsZS5jbGllbnRZKSxyPW5ldyBhLkRyYWdNb3ZlU2Vuc29yRXZlbnQoe2NsaWVudFg6ZS5jbGllbnRYLGNsaWVudFk6ZS5jbGllbnRZLHRhcmdldDp0LGNvbnRhaW5lcjp0aGlzLmN1cnJlbnRDb250YWluZXIsb3JpZ2luYWxFdmVudDplfSk7dGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lcixyKX1bZF0oZSl7aWYodGhpcy5tb3VzZURvd249Qm9vbGVhbih0aGlzLm9wZW5lZENvbnRleHRNZW51KSx0aGlzLm9wZW5lZENvbnRleHRNZW51KXJldHVybiB2b2lkKHRoaXMub3BlbmVkQ29udGV4dE1lbnU9ITEpO2lmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpc1tkXSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLGgpLCF0aGlzLmRyYWdnaW5nKXJldHVybjtjb25zdCB0PWRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLGUuY2xpZW50WSkscj1uZXcgYS5EcmFnU3RvcFNlbnNvckV2ZW50KHtjbGllbnRYOmUuY2xpZW50WCxjbGllbnRZOmUuY2xpZW50WSx0YXJnZXQ6dCxjb250YWluZXI6dGhpcy5jdXJyZW50Q29udGFpbmVyLG9yaWdpbmFsRXZlbnQ6ZX0pO3RoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsciksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsdGhpc1tsXSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXNbdV0pLHRoaXMuY3VycmVudENvbnRhaW5lcj1udWxsLHRoaXMuZHJhZ2dpbmc9ITF9W2xdKGUpe2UucHJldmVudERlZmF1bHQoKSx0aGlzLm9wZW5lZENvbnRleHRNZW51PSEwfX1mdW5jdGlvbiBoKGUpe2UucHJldmVudERlZmF1bHQoKX10LmRlZmF1bHQ9Z30sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89cigyMCksaT0obj1vKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dC5kZWZhdWx0PWkuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9O3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihlPVtdLHQ9e30pe3RoaXMuY29udGFpbmVycz1bLi4uZV0sdGhpcy5vcHRpb25zPW4oe30sdCksdGhpcy5kcmFnZ2luZz0hMSx0aGlzLmN1cnJlbnRDb250YWluZXI9bnVsbH1hdHRhY2goKXtyZXR1cm4gdGhpc31kZXRhY2goKXtyZXR1cm4gdGhpc31hZGRDb250YWluZXIoLi4uZSl7dGhpcy5jb250YWluZXJzPVsuLi50aGlzLmNvbnRhaW5lcnMsLi4uZV19cmVtb3ZlQ29udGFpbmVyKC4uLmUpe3RoaXMuY29udGFpbmVycz10aGlzLmNvbnRhaW5lcnMuZmlsdGVyKHQ9PiFlLmluY2x1ZGVzKHQpKX10cmlnZ2VyKGUsdCl7Y29uc3Qgcj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO3JldHVybiByLmRldGFpbD10LHIuaW5pdEV2ZW50KHQudHlwZSwhMCwhMCksZS5kaXNwYXRjaEV2ZW50KHIpLHRoaXMubGFzdEV2ZW50PXQsdH19fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKGUpe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSl9KX19LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMjMpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm4gbnVsbDtjb25zdCByPXQsbz10LGk9dCxzPXQsYT1Cb29sZWFuKFwic3RyaW5nXCI9PXR5cGVvZiB0KSxsPUJvb2xlYW4oXCJmdW5jdGlvblwiPT10eXBlb2YgdCksYz1Cb29sZWFuKHQgaW5zdGFuY2VvZiBOb2RlTGlzdHx8dCBpbnN0YW5jZW9mIEFycmF5KSx1PUJvb2xlYW4odCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtsZXQgZD1lO2Rve2lmKGQ9ZC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudHx8ZC5jb3JyZXNwb25kaW5nRWxlbWVudHx8ZCwoZz1kKT9hP24uY2FsbChnLHIpOmM/Wy4uLmldLmluY2x1ZGVzKGcpOnU/cz09PWc6bCYmbyhnKTpnKXJldHVybiBkO2Q9ZC5wYXJlbnROb2RlfXdoaWxlKGQmJmQhPT1kb2N1bWVudC5ib2R5JiZkIT09ZG9jdW1lbnQpO3ZhciBnO3JldHVybiBudWxsfTtjb25zdCBuPUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN8fEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8RWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yfHxFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3Rvcn0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89cigyNSksaT0obj1vKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dC5kZWZhdWx0PWkuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdE9wdGlvbnM9dC5zY3JvbGw9dC5vbkRyYWdTdG9wPXQub25EcmFnTW92ZT10Lm9uRHJhZ1N0YXJ0PXZvaWQgMDt2YXIgbixvPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9LGk9cig0KSxzPShuPWkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxhPXIoMik7Y29uc3QgbD10Lm9uRHJhZ1N0YXJ0PVN5bWJvbChcIm9uRHJhZ1N0YXJ0XCIpLGM9dC5vbkRyYWdNb3ZlPVN5bWJvbChcIm9uRHJhZ01vdmVcIiksdT10Lm9uRHJhZ1N0b3A9U3ltYm9sKFwib25EcmFnU3RvcFwiKSxkPXQuc2Nyb2xsPVN5bWJvbChcInNjcm9sbFwiKSxnPXQuZGVmYXVsdE9wdGlvbnM9e3NwZWVkOjYsc2Vuc2l0aXZpdHk6NTAsc2Nyb2xsYWJsZUVsZW1lbnRzOltdfTtjbGFzcyBoIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMub3B0aW9ucz1vKHt9LGcsdGhpcy5nZXRPcHRpb25zKCkpLHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb249bnVsbCx0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lPW51bGwsdGhpcy5zY3JvbGxhYmxlRWxlbWVudD1udWxsLHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWU9bnVsbCx0aGlzW2xdPXRoaXNbbF0uYmluZCh0aGlzKSx0aGlzW2NdPXRoaXNbY10uYmluZCh0aGlzKSx0aGlzW3VdPXRoaXNbdV0uYmluZCh0aGlzKSx0aGlzW2RdPXRoaXNbZF0uYmluZCh0aGlzKX1hdHRhY2goKXt0aGlzLmRyYWdnYWJsZS5vbihcImRyYWc6c3RhcnRcIix0aGlzW2xdKS5vbihcImRyYWc6bW92ZVwiLHRoaXNbY10pLm9uKFwiZHJhZzpzdG9wXCIsdGhpc1t1XSl9ZGV0YWNoKCl7dGhpcy5kcmFnZ2FibGUub2ZmKFwiZHJhZzpzdGFydFwiLHRoaXNbbF0pLm9mZihcImRyYWc6bW92ZVwiLHRoaXNbY10pLm9mZihcImRyYWc6c3RvcFwiLHRoaXNbdV0pfWdldE9wdGlvbnMoKXtyZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zY3JvbGxhYmxlfHx7fX1nZXRTY3JvbGxhYmxlRWxlbWVudChlKXtyZXR1cm4gdGhpcy5oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCk/KDAsYS5jbG9zZXN0KShlLHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpfHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ6ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIGYoKTtjb25zdCB0PWdldENvbXB1dGVkU3R5bGUoZSkuZ2V0UHJvcGVydHlWYWx1ZShcInBvc2l0aW9uXCIpLHI9XCJhYnNvbHV0ZVwiPT09dCxuPSgwLGEuY2xvc2VzdCkoZSxlPT4oIXJ8fCFmdW5jdGlvbihlKXtyZXR1cm5cInN0YXRpY1wiPT09Z2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKFwicG9zaXRpb25cIil9KGUpKSYmZnVuY3Rpb24oZSl7Y29uc3QgdD1nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkscj10LmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvd1wiKSt0LmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvdy15XCIpK3QuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93LXhcIik7cmV0dXJuLyhhdXRvfHNjcm9sbCkvLnRlc3Qocil9KGUpKTtyZXR1cm5cImZpeGVkXCIhPT10JiZuP246ZigpfShlKX1oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCl7cmV0dXJuIEJvb2xlYW4oMCE9PXRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMubGVuZ3RoKX1bbF0oZSl7dGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pnt0aGlzLnNjcm9sbGFibGVFbGVtZW50PXRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZS5zb3VyY2UpfSl9W2NdKGUpe2lmKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dGhpcy5zY3JvbGxhYmxlRWxlbWVudD10aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGUuc2Vuc29yRXZlbnQudGFyZ2V0KX0pLCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KXJldHVybjtjb25zdCB0PWUuc2Vuc29yRXZlbnQscj17eDowLHk6MH07XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvdyYmKHIueT13aW5kb3cucGFnZVlPZmZzZXR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wfHwwLHIueD13aW5kb3cucGFnZVhPZmZzZXR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fHxkb2N1bWVudC5ib2R5LnNjcm9sbExlZnR8fDApLHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb249e2NsaWVudFg6dC5jbGllbnRYLXIueCxjbGllbnRZOnQuY2xpZW50WS1yLnl9LHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbZF0pfVt1XSgpe2NhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpLGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUpLHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQ9bnVsbCx0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lPW51bGwsdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZT1udWxsLHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb249bnVsbH1bZF0oKXtpZighdGhpcy5zY3JvbGxhYmxlRWxlbWVudHx8IXRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24pcmV0dXJuO2NhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO2NvbnN0e3NwZWVkOmUsc2Vuc2l0aXZpdHk6dH09dGhpcy5vcHRpb25zLHI9dGhpcy5zY3JvbGxhYmxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPXIuYm90dG9tPndpbmRvdy5pbm5lckhlaWdodCxvPXIudG9wPDB8fG4saT1mKCkscz10aGlzLnNjcm9sbGFibGVFbGVtZW50LGE9dGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYLGw9dGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRZO2lmKHM9PT1kb2N1bWVudC5ib2R5fHxzPT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxvKXtjb25zdHtpbm5lckhlaWdodDpyLGlubmVyV2lkdGg6bn09d2luZG93O2w8dD9pLnNjcm9sbFRvcC09ZTpyLWw8dCYmKGkuc2Nyb2xsVG9wKz1lKSxhPHQ/aS5zY3JvbGxMZWZ0LT1lOm4tYTx0JiYoaS5zY3JvbGxMZWZ0Kz1lKX1lbHNle2NvbnN0e29mZnNldEhlaWdodDpuLG9mZnNldFdpZHRoOm99PXM7ci50b3Arbi1sPHQ/cy5zY3JvbGxUb3ArPWU6bC1yLnRvcDx0JiYocy5zY3JvbGxUb3AtPWUpLHIubGVmdCtvLWE8dD9zLnNjcm9sbExlZnQrPWU6YS1yLmxlZnQ8dCYmKHMuc2Nyb2xsTGVmdC09ZSl9dGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tkXSl9fWZ1bmN0aW9uIGYoKXtyZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fXQuZGVmYXVsdD1ofSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0T3B0aW9ucz12b2lkIDA7dmFyIG4sbz1yKDI3KSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt0LmRlZmF1bHQ9aS5kZWZhdWx0LHQuZGVmYXVsdE9wdGlvbnM9by5kZWZhdWx0T3B0aW9uc30sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWlycm9yRGVzdHJveUV2ZW50PXQuTWlycm9yTW92ZUV2ZW50PXQuTWlycm9yQXR0YWNoZWRFdmVudD10Lk1pcnJvckNyZWF0ZWRFdmVudD10Lk1pcnJvckNyZWF0ZUV2ZW50PXQuTWlycm9yRXZlbnQ9dm9pZCAwO3ZhciBuLG89cigzKSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtjbGFzcyBzIGV4dGVuZHMgaS5kZWZhdWx0e2dldCBzb3VyY2UoKXtyZXR1cm4gdGhpcy5kYXRhLnNvdXJjZX1nZXQgb3JpZ2luYWxTb3VyY2UoKXtyZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlfWdldCBzb3VyY2VDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcn1nZXQgc2Vuc29yRXZlbnQoKXtyZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50fWdldCBkcmFnRXZlbnQoKXtyZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudH1nZXQgb3JpZ2luYWxFdmVudCgpe3JldHVybiB0aGlzLnNlbnNvckV2ZW50P3RoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDpudWxsfX10Lk1pcnJvckV2ZW50PXM7Y2xhc3MgYSBleHRlbmRzIHN7fXQuTWlycm9yQ3JlYXRlRXZlbnQ9YSxhLnR5cGU9XCJtaXJyb3I6Y3JlYXRlXCI7Y2xhc3MgbCBleHRlbmRzIHN7Z2V0IG1pcnJvcigpe3JldHVybiB0aGlzLmRhdGEubWlycm9yfX10Lk1pcnJvckNyZWF0ZWRFdmVudD1sLGwudHlwZT1cIm1pcnJvcjpjcmVhdGVkXCI7Y2xhc3MgYyBleHRlbmRzIHN7Z2V0IG1pcnJvcigpe3JldHVybiB0aGlzLmRhdGEubWlycm9yfX10Lk1pcnJvckF0dGFjaGVkRXZlbnQ9YyxjLnR5cGU9XCJtaXJyb3I6YXR0YWNoZWRcIjtjbGFzcyB1IGV4dGVuZHMgc3tnZXQgbWlycm9yKCl7cmV0dXJuIHRoaXMuZGF0YS5taXJyb3J9fXQuTWlycm9yTW92ZUV2ZW50PXUsdS50eXBlPVwibWlycm9yOm1vdmVcIix1LmNhbmNlbGFibGU9ITA7Y2xhc3MgZCBleHRlbmRzIHN7Z2V0IG1pcnJvcigpe3JldHVybiB0aGlzLmRhdGEubWlycm9yfX10Lk1pcnJvckRlc3Ryb3lFdmVudD1kLGQudHlwZT1cIm1pcnJvcjpkZXN0cm95XCIsZC5jYW5jZWxhYmxlPSEwfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49cigyOSk7T2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJkZWZhdWx0XCIhPT1lJiZcIl9fZXNNb2R1bGVcIiE9PWUmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bZV19fSl9KSl9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHRPcHRpb25zPXQuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcj10Lm9uU2Nyb2xsPXQub25NaXJyb3JNb3ZlPXQub25NaXJyb3JDcmVhdGVkPXQub25EcmFnU3RvcD10Lm9uRHJhZ01vdmU9dC5vbkRyYWdTdGFydD12b2lkIDA7dmFyIG4sbz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1hcmd1bWVudHNbdF07Zm9yKHZhciBuIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbikmJihlW25dPXJbbl0pfXJldHVybiBlfSxpPXIoNCkscz0obj1pKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0sYT1yKDMwKTtmdW5jdGlvbiBsKGUsdCl7dmFyIHI9e307Zm9yKHZhciBuIGluIGUpdC5pbmRleE9mKG4pPj0wfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmKHJbbl09ZVtuXSk7cmV0dXJuIHJ9Y29uc3QgYz10Lm9uRHJhZ1N0YXJ0PVN5bWJvbChcIm9uRHJhZ1N0YXJ0XCIpLHU9dC5vbkRyYWdNb3ZlPVN5bWJvbChcIm9uRHJhZ01vdmVcIiksZD10Lm9uRHJhZ1N0b3A9U3ltYm9sKFwib25EcmFnU3RvcFwiKSxnPXQub25NaXJyb3JDcmVhdGVkPVN5bWJvbChcIm9uTWlycm9yQ3JlYXRlZFwiKSxoPXQub25NaXJyb3JNb3ZlPVN5bWJvbChcIm9uTWlycm9yTW92ZVwiKSxmPXQub25TY3JvbGw9U3ltYm9sKFwib25TY3JvbGxcIiksdj10LmdldEFwcGVuZGFibGVDb250YWluZXI9U3ltYm9sKFwiZ2V0QXBwZW5kYWJsZUNvbnRhaW5lclwiKSxtPXQuZGVmYXVsdE9wdGlvbnM9e2NvbnN0cmFpbkRpbWVuc2lvbnM6ITEseEF4aXM6ITAseUF4aXM6ITAsY3Vyc29yT2Zmc2V0WDpudWxsLGN1cnNvck9mZnNldFk6bnVsbH07Y2xhc3MgcCBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLm9wdGlvbnM9byh7fSxtLHRoaXMuZ2V0T3B0aW9ucygpKSx0aGlzLnNjcm9sbE9mZnNldD17eDowLHk6MH0sdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0PXt4OndpbmRvdy5zY3JvbGxYLHk6d2luZG93LnNjcm9sbFl9LHRoaXNbY109dGhpc1tjXS5iaW5kKHRoaXMpLHRoaXNbdV09dGhpc1t1XS5iaW5kKHRoaXMpLHRoaXNbZF09dGhpc1tkXS5iaW5kKHRoaXMpLHRoaXNbZ109dGhpc1tnXS5iaW5kKHRoaXMpLHRoaXNbaF09dGhpc1toXS5iaW5kKHRoaXMpLHRoaXNbZl09dGhpc1tmXS5iaW5kKHRoaXMpfWF0dGFjaCgpe3RoaXMuZHJhZ2dhYmxlLm9uKFwiZHJhZzpzdGFydFwiLHRoaXNbY10pLm9uKFwiZHJhZzptb3ZlXCIsdGhpc1t1XSkub24oXCJkcmFnOnN0b3BcIix0aGlzW2RdKS5vbihcIm1pcnJvcjpjcmVhdGVkXCIsdGhpc1tnXSkub24oXCJtaXJyb3I6bW92ZVwiLHRoaXNbaF0pfWRldGFjaCgpe3RoaXMuZHJhZ2dhYmxlLm9mZihcImRyYWc6c3RhcnRcIix0aGlzW2NdKS5vZmYoXCJkcmFnOm1vdmVcIix0aGlzW3VdKS5vZmYoXCJkcmFnOnN0b3BcIix0aGlzW2RdKS5vZmYoXCJtaXJyb3I6Y3JlYXRlZFwiLHRoaXNbZ10pLm9mZihcIm1pcnJvcjptb3ZlXCIsdGhpc1toXSl9Z2V0T3B0aW9ucygpe3JldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLm1pcnJvcnx8e319W2NdKGUpe2lmKGUuY2FuY2VsZWQoKSlyZXR1cm47XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvdyYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXNbZl0sITApLHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldD17eDp3aW5kb3cuc2Nyb2xsWCx5OndpbmRvdy5zY3JvbGxZfTtjb25zdHtzb3VyY2U6dCxvcmlnaW5hbFNvdXJjZTpyLHNvdXJjZUNvbnRhaW5lcjpuLHNlbnNvckV2ZW50Om99PWUsaT1uZXcgYS5NaXJyb3JDcmVhdGVFdmVudCh7c291cmNlOnQsb3JpZ2luYWxTb3VyY2U6cixzb3VyY2VDb250YWluZXI6bixzZW5zb3JFdmVudDpvLGRyYWdFdmVudDplfSk7aWYodGhpcy5kcmFnZ2FibGUudHJpZ2dlcihpKSxmdW5jdGlvbihlKXtyZXR1cm4vXmRyYWcvLnRlc3QoZS5vcmlnaW5hbEV2ZW50LnR5cGUpfShvKXx8aS5jYW5jZWxlZCgpKXJldHVybjtjb25zdCBzPXRoaXNbdl0odCl8fG47dGhpcy5taXJyb3I9dC5jbG9uZU5vZGUoITApO2NvbnN0IGw9bmV3IGEuTWlycm9yQ3JlYXRlZEV2ZW50KHtzb3VyY2U6dCxvcmlnaW5hbFNvdXJjZTpyLHNvdXJjZUNvbnRhaW5lcjpuLHNlbnNvckV2ZW50Om8sZHJhZ0V2ZW50OmUsbWlycm9yOnRoaXMubWlycm9yfSksYz1uZXcgYS5NaXJyb3JBdHRhY2hlZEV2ZW50KHtzb3VyY2U6dCxvcmlnaW5hbFNvdXJjZTpyLHNvdXJjZUNvbnRhaW5lcjpuLHNlbnNvckV2ZW50Om8sZHJhZ0V2ZW50OmUsbWlycm9yOnRoaXMubWlycm9yfSk7dGhpcy5kcmFnZ2FibGUudHJpZ2dlcihsKSxzLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKSx0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGMpfVt1XShlKXtpZighdGhpcy5taXJyb3J8fGUuY2FuY2VsZWQoKSlyZXR1cm47Y29uc3R7c291cmNlOnQsb3JpZ2luYWxTb3VyY2U6cixzb3VyY2VDb250YWluZXI6bixzZW5zb3JFdmVudDpvfT1lLGk9bmV3IGEuTWlycm9yTW92ZUV2ZW50KHtzb3VyY2U6dCxvcmlnaW5hbFNvdXJjZTpyLHNvdXJjZUNvbnRhaW5lcjpuLHNlbnNvckV2ZW50Om8sZHJhZ0V2ZW50OmUsbWlycm9yOnRoaXMubWlycm9yfSk7dGhpcy5kcmFnZ2FibGUudHJpZ2dlcihpKX1bZF0oZSl7aWYoXCJvbnRvdWNoc3RhcnRcImluIHdpbmRvdyYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXNbZl0sITApLHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldD17eDowLHk6MH0sdGhpcy5zY3JvbGxPZmZzZXQ9e3g6MCx5OjB9LCF0aGlzLm1pcnJvcilyZXR1cm47Y29uc3R7c291cmNlOnQsc291cmNlQ29udGFpbmVyOnIsc2Vuc29yRXZlbnQ6bn09ZSxvPW5ldyBhLk1pcnJvckRlc3Ryb3lFdmVudCh7c291cmNlOnQsbWlycm9yOnRoaXMubWlycm9yLHNvdXJjZUNvbnRhaW5lcjpyLHNlbnNvckV2ZW50Om4sZHJhZ0V2ZW50OmV9KTt0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG8pLG8uY2FuY2VsZWQoKXx8dGhpcy5taXJyb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1pcnJvcil9W2ZdKCl7dGhpcy5zY3JvbGxPZmZzZXQ9e3g6d2luZG93LnNjcm9sbFgtdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngseTp3aW5kb3cuc2Nyb2xsWS10aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueX19W2ddKHttaXJyb3I6ZSxzb3VyY2U6dCxzZW5zb3JFdmVudDpyfSl7Y29uc3Qgbj17bWlycm9yOmUsc291cmNlOnQsc2Vuc29yRXZlbnQ6cixtaXJyb3JDbGFzczp0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVGb3IoXCJtaXJyb3JcIiksc2Nyb2xsT2Zmc2V0OnRoaXMuc2Nyb2xsT2Zmc2V0LG9wdGlvbnM6dGhpcy5vcHRpb25zfTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4pLnRoZW4oYikudGhlbihFKS50aGVuKHkpLnRoZW4oUykudGhlbihDKHtpbml0aWFsOiEwfSkpLnRoZW4oTykudGhlbihlPT57bGV0e21pcnJvck9mZnNldDp0LGluaXRpYWxYOnIsaW5pdGlhbFk6bn09ZSxpPWwoZSxbXCJtaXJyb3JPZmZzZXRcIixcImluaXRpYWxYXCIsXCJpbml0aWFsWVwiXSk7cmV0dXJuIHRoaXMubWlycm9yT2Zmc2V0PXQsdGhpcy5pbml0aWFsWD1yLHRoaXMuaW5pdGlhbFk9bixvKHttaXJyb3JPZmZzZXQ6dCxpbml0aWFsWDpyLGluaXRpYWxZOm59LGkpfSl9W2hdKGUpe2lmKGUuY2FuY2VsZWQoKSlyZXR1cm4gbnVsbDtjb25zdCB0PXttaXJyb3I6ZS5taXJyb3Isc2Vuc29yRXZlbnQ6ZS5zZW5zb3JFdmVudCxtaXJyb3JPZmZzZXQ6dGhpcy5taXJyb3JPZmZzZXQsb3B0aW9uczp0aGlzLm9wdGlvbnMsaW5pdGlhbFg6dGhpcy5pbml0aWFsWCxpbml0aWFsWTp0aGlzLmluaXRpYWxZLHNjcm9sbE9mZnNldDp0aGlzLnNjcm9sbE9mZnNldH07cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0KS50aGVuKEMoe3JhZjohMH0pKX1bdl0oZSl7Y29uc3QgdD10aGlzLm9wdGlvbnMuYXBwZW5kVG87cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KTp0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ/dDpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3QoZSk6ZS5wYXJlbnROb2RlfX1mdW5jdGlvbiBiKGUpe2xldHtzb3VyY2U6dH09ZSxyPWwoZSxbXCJzb3VyY2VcIl0pO3JldHVybiB3KGU9Pntjb25zdCBuPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZShvKHtzb3VyY2U6dCxzb3VyY2VSZWN0Om59LHIpKX0pfWZ1bmN0aW9uIEUoZSl7bGV0e3NlbnNvckV2ZW50OnQsc291cmNlUmVjdDpyLG9wdGlvbnM6bn09ZSxpPWwoZSxbXCJzZW5zb3JFdmVudFwiLFwic291cmNlUmVjdFwiLFwib3B0aW9uc1wiXSk7cmV0dXJuIHcoZT0+e2NvbnN0IHM9bnVsbD09PW4uY3Vyc29yT2Zmc2V0WT90LmNsaWVudFktci50b3A6bi5jdXJzb3JPZmZzZXRZLGE9bnVsbD09PW4uY3Vyc29yT2Zmc2V0WD90LmNsaWVudFgtci5sZWZ0Om4uY3Vyc29yT2Zmc2V0WDtlKG8oe3NlbnNvckV2ZW50OnQsc291cmNlUmVjdDpyLG1pcnJvck9mZnNldDp7dG9wOnMsbGVmdDphfSxvcHRpb25zOm59LGkpKX0pfWZ1bmN0aW9uIHkoZSl7bGV0e21pcnJvcjp0LHNvdXJjZTpyLG9wdGlvbnM6bn09ZSxpPWwoZSxbXCJtaXJyb3JcIixcInNvdXJjZVwiLFwib3B0aW9uc1wiXSk7cmV0dXJuIHcoZT0+e2xldCBzLGE7aWYobi5jb25zdHJhaW5EaW1lbnNpb25zKXtjb25zdCBlPWdldENvbXB1dGVkU3R5bGUocik7cz1lLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksYT1lLmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKX10LnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIix0LnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsdC5zdHlsZS50b3A9MCx0LnN0eWxlLmxlZnQ9MCx0LnN0eWxlLm1hcmdpbj0wLG4uY29uc3RyYWluRGltZW5zaW9ucyYmKHQuc3R5bGUuaGVpZ2h0PXMsdC5zdHlsZS53aWR0aD1hKSxlKG8oe21pcnJvcjp0LHNvdXJjZTpyLG9wdGlvbnM6bn0saSkpfSl9ZnVuY3Rpb24gUyhlKXtsZXR7bWlycm9yOnQsbWlycm9yQ2xhc3M6cn09ZSxuPWwoZSxbXCJtaXJyb3JcIixcIm1pcnJvckNsYXNzXCJdKTtyZXR1cm4gdyhlPT57dC5jbGFzc0xpc3QuYWRkKHIpLGUobyh7bWlycm9yOnQsbWlycm9yQ2xhc3M6cn0sbikpfSl9ZnVuY3Rpb24gTyhlKXtsZXR7bWlycm9yOnR9PWUscj1sKGUsW1wibWlycm9yXCJdKTtyZXR1cm4gdyhlPT57dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKSxkZWxldGUgdC5pZCxlKG8oe21pcnJvcjp0fSxyKSl9KX1mdW5jdGlvbiBDKHt3aXRoRnJhbWU6ZT0hMSxpbml0aWFsOnQ9ITF9PXt9KXtyZXR1cm4gcj0+e2xldHttaXJyb3I6bixzZW5zb3JFdmVudDppLG1pcnJvck9mZnNldDpzLGluaXRpYWxZOmEsaW5pdGlhbFg6YyxzY3JvbGxPZmZzZXQ6dSxvcHRpb25zOmR9PXIsZz1sKHIsW1wibWlycm9yXCIsXCJzZW5zb3JFdmVudFwiLFwibWlycm9yT2Zmc2V0XCIsXCJpbml0aWFsWVwiLFwiaW5pdGlhbFhcIixcInNjcm9sbE9mZnNldFwiLFwib3B0aW9uc1wiXSk7cmV0dXJuIHcoZT0+e2NvbnN0IHI9byh7bWlycm9yOm4sc2Vuc29yRXZlbnQ6aSxtaXJyb3JPZmZzZXQ6cyxvcHRpb25zOmR9LGcpO2lmKHMpe2NvbnN0IGU9aS5jbGllbnRYLXMubGVmdC11Lngsbz1pLmNsaWVudFktcy50b3AtdS55O2QueEF4aXMmJmQueUF4aXN8fHQ/bi5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZTNkKCR7ZX1weCwgJHtvfXB4LCAwKWA6ZC54QXhpcyYmIWQueUF4aXM/bi5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZTNkKCR7ZX1weCwgJHthfXB4LCAwKWA6ZC55QXhpcyYmIWQueEF4aXMmJihuLnN0eWxlLnRyYW5zZm9ybT1gdHJhbnNsYXRlM2QoJHtjfXB4LCAke299cHgsIDApYCksdCYmKHIuaW5pdGlhbFg9ZSxyLmluaXRpYWxZPW8pfWUocil9LHtmcmFtZTplfSl9fWZ1bmN0aW9uIHcoZSx7cmFmOnQ9ITF9PXt9KXtyZXR1cm4gbmV3IFByb21pc2UoKHIsbik9Pnt0P3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e2UocixuKX0pOmUocixuKX0pfXQuZGVmYXVsdD1wfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0T3B0aW9ucz12b2lkIDA7dmFyIG4sbz1yKDMxKSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt0LmRlZmF1bHQ9aS5kZWZhdWx0LHQuZGVmYXVsdE9wdGlvbnM9by5kZWZhdWx0T3B0aW9uc30sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9YXJndW1lbnRzW3RdO2Zvcih2YXIgbiBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLG4pJiYoZVtuXT1yW25dKX1yZXR1cm4gZX0saT1yKDQpLHM9KG49aSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O2NvbnN0IGE9U3ltYm9sKFwib25Jbml0aWFsaXplXCIpLGw9U3ltYm9sKFwib25EZXN0cm95XCIpLGM9e307Y2xhc3MgdSBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLm9wdGlvbnM9byh7fSxjLHRoaXMuZ2V0T3B0aW9ucygpKSx0aGlzW2FdPXRoaXNbYV0uYmluZCh0aGlzKSx0aGlzW2xdPXRoaXNbbF0uYmluZCh0aGlzKX1hdHRhY2goKXt0aGlzLmRyYWdnYWJsZS5vbihcImRyYWdnYWJsZTppbml0aWFsaXplXCIsdGhpc1thXSkub24oXCJkcmFnZ2FibGU6ZGVzdHJveVwiLHRoaXNbbF0pfWRldGFjaCgpe3RoaXMuZHJhZ2dhYmxlLm9mZihcImRyYWdnYWJsZTppbml0aWFsaXplXCIsdGhpc1thXSkub2ZmKFwiZHJhZ2dhYmxlOmRlc3Ryb3lcIix0aGlzW2xdKX1nZXRPcHRpb25zKCl7cmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuZm9jdXNhYmxlfHx7fX1nZXRFbGVtZW50cygpe3JldHVyblsuLi50aGlzLmRyYWdnYWJsZS5jb250YWluZXJzLC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldfVthXSgpe3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3RoaXMuZ2V0RWxlbWVudHMoKS5mb3JFYWNoKGU9PmZ1bmN0aW9uKGUpe0Jvb2xlYW4oIWUuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikmJi0xPT09ZS50YWJJbmRleCkmJihkLnB1c2goZSksZS50YWJJbmRleD0wKX0oZSkpfSl9W2xdKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZT0+ZnVuY3Rpb24oZSl7Y29uc3QgdD1kLmluZGV4T2YoZSk7LTEhPT10JiYoZS50YWJJbmRleD0tMSxkLnNwbGljZSh0LDEpKX0oZSkpfSl9fXQuZGVmYXVsdD11O2NvbnN0IGQ9W119LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbixvPXIoMzMpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3QuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5kcmFnZ2FibGU9ZX1hdHRhY2goKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWRcIil9ZGV0YWNoKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpfX19LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHRPcHRpb25zPXZvaWQgMDt2YXIgbixvPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9LGk9cig0KSxzPShuPWkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtjb25zdCBhPVN5bWJvbChcIm9uSW5pdGlhbGl6ZVwiKSxsPVN5bWJvbChcIm9uRGVzdHJveVwiKSxjPVN5bWJvbChcImFubm91bmNlRXZlbnRcIiksdT1TeW1ib2woXCJhbm5vdW5jZU1lc3NhZ2VcIiksZD10LmRlZmF1bHRPcHRpb25zPXtleHBpcmU6N2UzfTtjbGFzcyBnIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMub3B0aW9ucz1vKHt9LGQsdGhpcy5nZXRPcHRpb25zKCkpLHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kPXRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIsdGhpc1thXT10aGlzW2FdLmJpbmQodGhpcyksdGhpc1tsXT10aGlzW2xdLmJpbmQodGhpcyl9YXR0YWNoKCl7dGhpcy5kcmFnZ2FibGUub24oXCJkcmFnZ2FibGU6aW5pdGlhbGl6ZVwiLHRoaXNbYV0pfWRldGFjaCgpe3RoaXMuZHJhZ2dhYmxlLm9mZihcImRyYWdnYWJsZTpkZXN0cm95XCIsdGhpc1tsXSl9Z2V0T3B0aW9ucygpe3JldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmFubm91bmNlbWVudHN8fHt9fVtjXShlKXtjb25zdCB0PXRoaXMub3B0aW9uc1tlLnR5cGVdO3QmJlwic3RyaW5nXCI9PXR5cGVvZiB0JiZ0aGlzW3VdKHQpLHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJnRoaXNbdV0odChlKSl9W3VdKGUpeyFmdW5jdGlvbihlLHtleHBpcmU6dH0pe2NvbnN0IHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyLnRleHRDb250ZW50PWUsaC5hcHBlbmRDaGlsZChyKSxzZXRUaW1lb3V0KCgpPT57aC5yZW1vdmVDaGlsZChyKX0sdCl9KGUse2V4cGlyZTp0aGlzLm9wdGlvbnMuZXhwaXJlfSl9W2FdKCl7dGhpcy5kcmFnZ2FibGUudHJpZ2dlcj1lPT57dHJ5e3RoaXNbY10oZSl9ZmluYWxseXt0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZC5jYWxsKHRoaXMuZHJhZ2dhYmxlLGUpfX19W2xdKCl7dGhpcy5kcmFnZ2FibGUudHJpZ2dlcj10aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZH19dC5kZWZhdWx0PWc7Y29uc3QgaD1mdW5jdGlvbigpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLFwiZHJhZ2dhYmxlLWxpdmUtcmVnaW9uXCIpLGUuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLFwiYWRkaXRpb25zXCIpLGUuc2V0QXR0cmlidXRlKFwiYXJpYS1hdG9taWNcIixcInRydWVcIiksZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIixcImFzc2VydGl2ZVwiKSxlLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImxvZ1wiKSxlLnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIixlLnN0eWxlLndpZHRoPVwiMXB4XCIsZS5zdHlsZS5oZWlnaHQ9XCIxcHhcIixlLnN0eWxlLnRvcD1cIi0xcHhcIixlLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsZX0oKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCgpPT57ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoKX0pfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0T3B0aW9ucz12b2lkIDA7dmFyIG4sbz1yKDM2KSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt0LmRlZmF1bHQ9aS5kZWZhdWx0LHQuZGVmYXVsdE9wdGlvbnM9by5kZWZhdWx0T3B0aW9uc30sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRHJhZ2dhYmxlRGVzdHJveUV2ZW50PXQuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudD10LkRyYWdnYWJsZUV2ZW50PXZvaWQgMDt2YXIgbixvPXIoMyksaT0obj1vKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07Y2xhc3MgcyBleHRlbmRzIGkuZGVmYXVsdHtnZXQgZHJhZ2dhYmxlKCl7cmV0dXJuIHRoaXMuZGF0YS5kcmFnZ2FibGV9fXQuRHJhZ2dhYmxlRXZlbnQ9cyxzLnR5cGU9XCJkcmFnZ2FibGVcIjtjbGFzcyBhIGV4dGVuZHMgc3t9dC5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50PWEsYS50eXBlPVwiZHJhZ2dhYmxlOmluaXRpYWxpemVcIjtjbGFzcyBsIGV4dGVuZHMgc3t9dC5EcmFnZ2FibGVEZXN0cm95RXZlbnQ9bCxsLnR5cGU9XCJkcmFnZ2FibGU6ZGVzdHJveVwifSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5EcmFnU3RvcEV2ZW50PXQuRHJhZ1ByZXNzdXJlRXZlbnQ9dC5EcmFnT3V0Q29udGFpbmVyRXZlbnQ9dC5EcmFnT3ZlckNvbnRhaW5lckV2ZW50PXQuRHJhZ091dEV2ZW50PXQuRHJhZ092ZXJFdmVudD10LkRyYWdNb3ZlRXZlbnQ9dC5EcmFnU3RhcnRFdmVudD10LkRyYWdFdmVudD12b2lkIDA7dmFyIG4sbz1yKDMpLGk9KG49bykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O2NsYXNzIHMgZXh0ZW5kcyBpLmRlZmF1bHR7Z2V0IHNvdXJjZSgpe3JldHVybiB0aGlzLmRhdGEuc291cmNlfWdldCBvcmlnaW5hbFNvdXJjZSgpe3JldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2V9Z2V0IG1pcnJvcigpe3JldHVybiB0aGlzLmRhdGEubWlycm9yfWdldCBzb3VyY2VDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcn1nZXQgc2Vuc29yRXZlbnQoKXtyZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50fWdldCBvcmlnaW5hbEV2ZW50KCl7cmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQ/dGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50Om51bGx9fXQuRHJhZ0V2ZW50PXMscy50eXBlPVwiZHJhZ1wiO2NsYXNzIGEgZXh0ZW5kcyBze310LkRyYWdTdGFydEV2ZW50PWEsYS50eXBlPVwiZHJhZzpzdGFydFwiLGEuY2FuY2VsYWJsZT0hMDtjbGFzcyBsIGV4dGVuZHMgc3t9dC5EcmFnTW92ZUV2ZW50PWwsbC50eXBlPVwiZHJhZzptb3ZlXCI7Y2xhc3MgYyBleHRlbmRzIHN7Z2V0IG92ZXJDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXJ9Z2V0IG92ZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm92ZXJ9fXQuRHJhZ092ZXJFdmVudD1jLGMudHlwZT1cImRyYWc6b3ZlclwiLGMuY2FuY2VsYWJsZT0hMDtjbGFzcyB1IGV4dGVuZHMgc3tnZXQgb3ZlckNvbnRhaW5lcigpe3JldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcn1nZXQgb3Zlcigpe3JldHVybiB0aGlzLmRhdGEub3Zlcn19dC5EcmFnT3V0RXZlbnQ9dSx1LnR5cGU9XCJkcmFnOm91dFwiO2NsYXNzIGQgZXh0ZW5kcyBze2dldCBvdmVyQ29udGFpbmVyKCl7cmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyfX10LkRyYWdPdmVyQ29udGFpbmVyRXZlbnQ9ZCxkLnR5cGU9XCJkcmFnOm92ZXI6Y29udGFpbmVyXCI7Y2xhc3MgZyBleHRlbmRzIHN7Z2V0IG92ZXJDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXJ9fXQuRHJhZ091dENvbnRhaW5lckV2ZW50PWcsZy50eXBlPVwiZHJhZzpvdXQ6Y29udGFpbmVyXCI7Y2xhc3MgaCBleHRlbmRzIHN7Z2V0IHByZXNzdXJlKCl7cmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZX19dC5EcmFnUHJlc3N1cmVFdmVudD1oLGgudHlwZT1cImRyYWc6cHJlc3N1cmVcIjtjbGFzcyBmIGV4dGVuZHMgc3t9dC5EcmFnU3RvcEV2ZW50PWYsZi50eXBlPVwiZHJhZzpzdG9wXCJ9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1yKDgpO09iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe1wiZGVmYXVsdFwiIT09ZSYmXCJfX2VzTW9kdWxlXCIhPT1lJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2VdfX0pfSkpO3ZhciBvPXIoNyk7T2JqZWN0LmtleXMobykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJkZWZhdWx0XCIhPT1lJiZcIl9fZXNNb2R1bGVcIiE9PWUmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG9bZV19fSl9KSk7dmFyIGk9cig2KTtPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtcImRlZmF1bHRcIiE9PWUmJlwiX19lc01vZHVsZVwiIT09ZSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaVtlXX19KX0pKTt2YXIgcz1yKDUpO09iamVjdC5rZXlzKHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe1wiZGVmYXVsdFwiIT09ZSYmXCJfX2VzTW9kdWxlXCIhPT1lJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzW2VdfX0pfSkpO3ZhciBhLGw9cigxMiksYz0oYT1sKSYmYS5fX2VzTW9kdWxlP2E6e2RlZmF1bHQ6YX07dC5kZWZhdWx0PWMuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9YXJndW1lbnRzW3RdO2Zvcih2YXIgbiBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLG4pJiYoZVtuXT1yW25dKX1yZXR1cm4gZX0saT1yKDQwKSxzPShuPWkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxhPXIoOSk7Y29uc3QgbD1TeW1ib2woXCJvbkRyYWdTdGFydFwiKSxjPVN5bWJvbChcIm9uRHJhZ092ZXJDb250YWluZXJcIiksdT1TeW1ib2woXCJvbkRyYWdPdmVyXCIpLGQ9U3ltYm9sKFwib25EcmFnU3RvcFwiKSxnPXtcInNvcnRhYmxlOnNvcnRlZFwiOmZ1bmN0aW9uKHtkcmFnRXZlbnQ6ZX0pe2NvbnN0IHQ9ZS5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpfHxlLnNvdXJjZS5pZHx8XCJzb3J0YWJsZSBlbGVtZW50XCI7aWYoZS5vdmVyKXtjb25zdCByPWUub3Zlci50ZXh0Q29udGVudC50cmltKCl8fGUub3Zlci5pZHx8XCJzb3J0YWJsZSBlbGVtZW50XCI7cmV0dXJuIGUuc291cmNlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUub3ZlcikmTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc/YFBsYWNlZCAke3R9IGFmdGVyICR7cn1gOmBQbGFjZWQgJHt0fSBiZWZvcmUgJHtyfWB9cmV0dXJuYFBsYWNlZCAke3R9IGludG8gYSBkaWZmZXJlbnQgY29udGFpbmVyYH19O2NsYXNzIGggZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoZT1bXSx0PXt9KXtzdXBlcihlLG8oe30sdCx7YW5ub3VuY2VtZW50czpvKHt9LGcsdC5hbm5vdW5jZW1lbnRzfHx7fSl9KSksdGhpcy5zdGFydEluZGV4PW51bGwsdGhpcy5zdGFydENvbnRhaW5lcj1udWxsLHRoaXNbbF09dGhpc1tsXS5iaW5kKHRoaXMpLHRoaXNbY109dGhpc1tjXS5iaW5kKHRoaXMpLHRoaXNbdV09dGhpc1t1XS5iaW5kKHRoaXMpLHRoaXNbZF09dGhpc1tkXS5iaW5kKHRoaXMpLHRoaXMub24oXCJkcmFnOnN0YXJ0XCIsdGhpc1tsXSkub24oXCJkcmFnOm92ZXI6Y29udGFpbmVyXCIsdGhpc1tjXSkub24oXCJkcmFnOm92ZXJcIix0aGlzW3VdKS5vbihcImRyYWc6c3RvcFwiLHRoaXNbZF0pfWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5vZmYoXCJkcmFnOnN0YXJ0XCIsdGhpc1tsXSkub2ZmKFwiZHJhZzpvdmVyOmNvbnRhaW5lclwiLHRoaXNbY10pLm9mZihcImRyYWc6b3ZlclwiLHRoaXNbdV0pLm9mZihcImRyYWc6c3RvcFwiLHRoaXNbZF0pfWluZGV4KGUpe3JldHVybiB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGUucGFyZW50Tm9kZSkuaW5kZXhPZihlKX1bbF0oZSl7dGhpcy5zdGFydENvbnRhaW5lcj1lLnNvdXJjZS5wYXJlbnROb2RlLHRoaXMuc3RhcnRJbmRleD10aGlzLmluZGV4KGUuc291cmNlKTtjb25zdCB0PW5ldyBhLlNvcnRhYmxlU3RhcnRFdmVudCh7ZHJhZ0V2ZW50OmUsc3RhcnRJbmRleDp0aGlzLnN0YXJ0SW5kZXgsc3RhcnRDb250YWluZXI6dGhpcy5zdGFydENvbnRhaW5lcn0pO3RoaXMudHJpZ2dlcih0KSx0LmNhbmNlbGVkKCkmJmUuY2FuY2VsKCl9W2NdKGUpe2lmKGUuY2FuY2VsZWQoKSlyZXR1cm47Y29uc3R7c291cmNlOnQsb3ZlcjpyLG92ZXJDb250YWluZXI6bn09ZSxvPXRoaXMuaW5kZXgodCksaT1uZXcgYS5Tb3J0YWJsZVNvcnRFdmVudCh7ZHJhZ0V2ZW50OmUsY3VycmVudEluZGV4Om8sc291cmNlOnQsb3ZlcjpyfSk7aWYodGhpcy50cmlnZ2VyKGkpLGkuY2FuY2VsZWQoKSlyZXR1cm47Y29uc3Qgcz12KHtzb3VyY2U6dCxvdmVyOnIsb3ZlckNvbnRhaW5lcjpuLGNoaWxkcmVuOnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIobil9KTtpZighcylyZXR1cm47Y29uc3R7b2xkQ29udGFpbmVyOmwsbmV3Q29udGFpbmVyOmN9PXMsdT10aGlzLmluZGV4KGUuc291cmNlKSxkPW5ldyBhLlNvcnRhYmxlU29ydGVkRXZlbnQoe2RyYWdFdmVudDplLG9sZEluZGV4Om8sbmV3SW5kZXg6dSxvbGRDb250YWluZXI6bCxuZXdDb250YWluZXI6Y30pO3RoaXMudHJpZ2dlcihkKX1bdV0oZSl7aWYoZS5vdmVyPT09ZS5vcmlnaW5hbFNvdXJjZXx8ZS5vdmVyPT09ZS5zb3VyY2UpcmV0dXJuO2NvbnN0e3NvdXJjZTp0LG92ZXI6cixvdmVyQ29udGFpbmVyOm59PWUsbz10aGlzLmluZGV4KHQpLGk9bmV3IGEuU29ydGFibGVTb3J0RXZlbnQoe2RyYWdFdmVudDplLGN1cnJlbnRJbmRleDpvLHNvdXJjZTp0LG92ZXI6cn0pO2lmKHRoaXMudHJpZ2dlcihpKSxpLmNhbmNlbGVkKCkpcmV0dXJuO2NvbnN0IHM9dih7c291cmNlOnQsb3ZlcjpyLG92ZXJDb250YWluZXI6bixjaGlsZHJlbjp0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG4pfSk7aWYoIXMpcmV0dXJuO2NvbnN0e29sZENvbnRhaW5lcjpsLG5ld0NvbnRhaW5lcjpjfT1zLHU9dGhpcy5pbmRleCh0KSxkPW5ldyBhLlNvcnRhYmxlU29ydGVkRXZlbnQoe2RyYWdFdmVudDplLG9sZEluZGV4Om8sbmV3SW5kZXg6dSxvbGRDb250YWluZXI6bCxuZXdDb250YWluZXI6Y30pO3RoaXMudHJpZ2dlcihkKX1bZF0oZSl7Y29uc3QgdD1uZXcgYS5Tb3J0YWJsZVN0b3BFdmVudCh7ZHJhZ0V2ZW50OmUsb2xkSW5kZXg6dGhpcy5zdGFydEluZGV4LG5ld0luZGV4OnRoaXMuaW5kZXgoZS5zb3VyY2UpLG9sZENvbnRhaW5lcjp0aGlzLnN0YXJ0Q29udGFpbmVyLG5ld0NvbnRhaW5lcjplLnNvdXJjZS5wYXJlbnROb2RlfSk7dGhpcy50cmlnZ2VyKHQpLHRoaXMuc3RhcnRJbmRleD1udWxsLHRoaXMuc3RhcnRDb250YWluZXI9bnVsbH19ZnVuY3Rpb24gZihlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLnBhcmVudE5vZGUuY2hpbGRyZW4sZSl9ZnVuY3Rpb24gdih7c291cmNlOmUsb3Zlcjp0LG92ZXJDb250YWluZXI6cixjaGlsZHJlbjpufSl7Y29uc3Qgbz0hbi5sZW5ndGgsaT1lLnBhcmVudE5vZGUhPT1yLHM9dCYmIWk7cmV0dXJuIG8/ZnVuY3Rpb24oZSx0KXtjb25zdCByPWUucGFyZW50Tm9kZTtyZXR1cm4gdC5hcHBlbmRDaGlsZChlKSx7b2xkQ29udGFpbmVyOnIsbmV3Q29udGFpbmVyOnR9fShlLHIpOnM/ZnVuY3Rpb24oZSx0KXtjb25zdCByPWYoZSksbj1mKHQpO3JldHVybiByPG4/ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHQubmV4dEVsZW1lbnRTaWJsaW5nKTplLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdCkse29sZENvbnRhaW5lcjplLnBhcmVudE5vZGUsbmV3Q29udGFpbmVyOmUucGFyZW50Tm9kZX19KGUsdCk6aT9mdW5jdGlvbihlLHQscil7Y29uc3Qgbj1lLnBhcmVudE5vZGU7cmV0dXJuIHQ/dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHQpOnIuYXBwZW5kQ2hpbGQoZSkse29sZENvbnRhaW5lcjpuLG5ld0NvbnRhaW5lcjplLnBhcmVudE5vZGV9fShlLHQscik6bnVsbH10LmRlZmF1bHQ9aH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9O2NvbnN0IG89U3ltYm9sKFwiY2FuY2VsZWRcIik7Y2xhc3MgaXtjb25zdHJ1Y3RvcihlKXt0aGlzW29dPSExLHRoaXMuZGF0YT1lfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZX1nZXQgY2FuY2VsYWJsZSgpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbmNlbGFibGV9Y2FuY2VsKCl7dGhpc1tvXT0hMH1jYW5jZWxlZCgpe3JldHVybiBCb29sZWFuKHRoaXNbb10pfWNsb25lKGUpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihuKHt9LHRoaXMuZGF0YSxlKSl9fXQuZGVmYXVsdD1pLGkudHlwZT1cImV2ZW50XCIsaS5jYW5jZWxhYmxlPSExfSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Tb3J0YWJsZVN0b3BFdmVudD10LlNvcnRhYmxlU29ydGVkRXZlbnQ9dC5Tb3J0YWJsZVNvcnRFdmVudD10LlNvcnRhYmxlU3RhcnRFdmVudD10LlNvcnRhYmxlRXZlbnQ9dm9pZCAwO3ZhciBuLG89cigzKSxpPShuPW8pJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtjbGFzcyBzIGV4dGVuZHMgaS5kZWZhdWx0e2dldCBkcmFnRXZlbnQoKXtyZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudH19dC5Tb3J0YWJsZUV2ZW50PXMscy50eXBlPVwic29ydGFibGVcIjtjbGFzcyBhIGV4dGVuZHMgc3tnZXQgc3RhcnRJbmRleCgpe3JldHVybiB0aGlzLmRhdGEuc3RhcnRJbmRleH1nZXQgc3RhcnRDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLnN0YXJ0Q29udGFpbmVyfX10LlNvcnRhYmxlU3RhcnRFdmVudD1hLGEudHlwZT1cInNvcnRhYmxlOnN0YXJ0XCIsYS5jYW5jZWxhYmxlPSEwO2NsYXNzIGwgZXh0ZW5kcyBze2dldCBjdXJyZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5kYXRhLmN1cnJlbnRJbmRleH1nZXQgb3Zlcigpe3JldHVybiB0aGlzLmRhdGEub2xkSW5kZXh9Z2V0IG92ZXJDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4fX10LlNvcnRhYmxlU29ydEV2ZW50PWwsbC50eXBlPVwic29ydGFibGU6c29ydFwiLGwuY2FuY2VsYWJsZT0hMDtjbGFzcyBjIGV4dGVuZHMgc3tnZXQgb2xkSW5kZXgoKXtyZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4fWdldCBuZXdJbmRleCgpe3JldHVybiB0aGlzLmRhdGEubmV3SW5kZXh9Z2V0IG9sZENvbnRhaW5lcigpe3JldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyfWdldCBuZXdDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcn19dC5Tb3J0YWJsZVNvcnRlZEV2ZW50PWMsYy50eXBlPVwic29ydGFibGU6c29ydGVkXCI7Y2xhc3MgdSBleHRlbmRzIHN7Z2V0IG9sZEluZGV4KCl7cmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleH1nZXQgbmV3SW5kZXgoKXtyZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4fWdldCBvbGRDb250YWluZXIoKXtyZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcn1nZXQgbmV3Q29udGFpbmVyKCl7cmV0dXJuIHRoaXMuZGF0YS5uZXdDb250YWluZXJ9fXQuU29ydGFibGVTdG9wRXZlbnQ9dSx1LnR5cGU9XCJzb3J0YWJsZTpzdG9wXCJ9LGZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1yKDkpO09iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe1wiZGVmYXVsdFwiIT09ZSYmXCJfX2VzTW9kdWxlXCIhPT1lJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2VdfX0pfSkpO3ZhciBvLGk9cig0MSkscz0obz1pKSYmby5fX2VzTW9kdWxlP286e2RlZmF1bHQ6b307dC5kZWZhdWx0PXMuZGVmYXVsdH1dKX0sZS5leHBvcnRzPXIoKX0pKSxyPShlPXQpJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZGVmYXVsdFwiKT9lLmRlZmF1bHQ6ZTtpZih2b2lkIDA9PT13aW5kb3cuTGl2ZXdpcmUpdGhyb3dcIkxpdmV3aXJlIFNvcnRhYmxlIFBsdWdpbjogd2luZG93LkxpdmV3aXJlIGlzIHVuZGVmaW5lZC4gTWFrZSBzdXJlIEBsaXZld2lyZVNjcmlwdHMgaXMgcGxhY2VkIGFib3ZlIHRoaXMgc2NyaXB0IGluY2x1ZGVcIjt3aW5kb3cuTGl2ZXdpcmUuZGlyZWN0aXZlKFwic29ydGFibGUtZ3JvdXBcIiwoe2VsOmUsZGlyZWN0aXZlOnQsY29tcG9uZW50Om59KT0+e2lmKHQubW9kaWZpZXJzLmluY2x1ZGVzKFwiaXRlbS1ncm91cFwiKSYmZS5jbG9zZXN0KFwiW3dpcmVcXFxcOnNvcnRhYmxlLWdyb3VwXVwiKS5saXZld2lyZV9zb3J0YWJsZS5hZGRDb250YWluZXIoZSksdC5tb2RpZmllcnMubGVuZ3RoPjApcmV0dXJuO2xldCBvPXtkcmFnZ2FibGU6XCJbd2lyZVxcXFw6c29ydGFibGUtZ3JvdXBcXFxcLml0ZW1dXCJ9O2UucXVlcnlTZWxlY3RvcihcIlt3aXJlXFxcXDpzb3J0YWJsZS1ncm91cFxcXFwuaGFuZGxlXVwiKSYmKG8uaGFuZGxlPVwiW3dpcmVcXFxcOnNvcnRhYmxlLWdyb3VwXFxcXC5oYW5kbGVdXCIpLChlLmxpdmV3aXJlX3NvcnRhYmxlPW5ldyByKFtdLG8pKS5vbihcInNvcnRhYmxlOnN0b3BcIiwoKT0+e3NldFRpbWVvdXQoKCk9PntsZXQgcj1bXTtlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbd2lyZVxcXFw6c29ydGFibGUtZ3JvdXBcXFxcLml0ZW0tZ3JvdXBdXCIpLmZvckVhY2goKGUsdCk9PntsZXQgbj1bXTtlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbd2lyZVxcXFw6c29ydGFibGUtZ3JvdXBcXFxcLml0ZW1dXCIpLmZvckVhY2goKGUsdCk9PntuLnB1c2goe29yZGVyOnQrMSx2YWx1ZTplLmdldEF0dHJpYnV0ZShcIndpcmU6c29ydGFibGUtZ3JvdXAuaXRlbVwiKX0pfSksci5wdXNoKHtvcmRlcjp0KzEsdmFsdWU6ZS5nZXRBdHRyaWJ1dGUoXCJ3aXJlOnNvcnRhYmxlLWdyb3VwLml0ZW0tZ3JvdXBcIiksaXRlbXM6bn0pfSksbi4kd2lyZS5jYWxsKHQubWV0aG9kLHIpfSwxKX0pfSksd2luZG93LkxpdmV3aXJlLmRpcmVjdGl2ZShcInNvcnRhYmxlXCIsKHtlbDplLGRpcmVjdGl2ZTp0LGNvbXBvbmVudDpufSk9PntpZih0Lm1vZGlmaWVycy5sZW5ndGg+MClyZXR1cm47bGV0IG89e2RyYWdnYWJsZTpcIlt3aXJlXFxcXDpzb3J0YWJsZVxcXFwuaXRlbV1cIn07ZS5xdWVyeVNlbGVjdG9yKFwiW3dpcmVcXFxcOnNvcnRhYmxlXFxcXC5oYW5kbGVdXCIpJiYoby5oYW5kbGU9XCJbd2lyZVxcXFw6c29ydGFibGVcXFxcLmhhbmRsZV1cIiksbmV3IHIoZSxvKS5vbihcInNvcnRhYmxlOnN0b3BcIiwoKT0+e3NldFRpbWVvdXQoKCk9PntsZXQgcj1bXTtlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbd2lyZVxcXFw6c29ydGFibGVcXFxcLml0ZW1dXCIpLmZvckVhY2goKGUsdCk9PntyLnB1c2goe29yZGVyOnQrMSx2YWx1ZTplLmdldEF0dHJpYnV0ZShcIndpcmU6c29ydGFibGUuaXRlbVwiKX0pfSksbi4kd2lyZS5jYWxsKHQubWV0aG9kLHIpfSwxKX0pfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXZld2lyZS1zb3J0YWJsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/livewire-sortable/dist/livewire-sortable.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/admin.js");
/******/ 	
/******/ })()
;